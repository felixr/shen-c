"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.<defprolog> (V1619) (let Parse_shen.<predicate*> (shen.<predicate*> V1619) (if (not (= (fail) Parse_shen.<predicate*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<predicate*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (hd (shen.prolog->shen (map (lambda Parse_X (shen.insert-predicate (shen.hdtl Parse_shen.<predicate*>) Parse_X)) (shen.hdtl Parse_shen.<clauses*>))))) (fail))) (fail))))

(defun shen.prolog-error (V1628 V1629) (cond ((and (cons? V1629) (and (cons? (tl V1629)) (= () (tl (tl V1629))))) (simple-error (cn "prolog syntax error in " (shen.app V1628 (cn " here:

 " (shen.app (shen.next-50 50 (hd V1629)) "
" shen.a)) shen.a)))) (true (simple-error (cn "prolog syntax error in " (shen.app V1628 "
" shen.a))))))

(defun shen.next-50 (V1636 V1637) (cond ((= () V1637) "") ((= 0 V1636) "") ((cons? V1637) (cn (shen.decons-string (hd V1637)) (shen.next-50 (- V1636 1) (tl V1637)))) (true (shen.f_error shen.next-50))))

(defun shen.decons-string (V1639) (cond ((and (cons? V1639) (and (= cons (hd V1639)) (and (cons? (tl V1639)) (and (cons? (tl (tl V1639))) (= () (tl (tl (tl V1639)))))))) (shen.app (shen.eval-cons V1639) " " shen.s)) (true (shen.app V1639 " " shen.r))))

(defun shen.insert-predicate (V1642 V1643) (cond ((and (cons? V1643) (and (cons? (tl V1643)) (= () (tl (tl V1643))))) (cons (cons V1642 (hd V1643)) (cons :- (tl V1643)))) (true (shen.f_error shen.insert-predicate))))

(defun shen.<predicate*> (V1645) (if (cons? (hd V1645)) (let Parse_X (hd (hd V1645)) (shen.pair (hd (shen.pair (tl (hd V1645)) (shen.hdtl V1645))) Parse_X)) (fail)))

(defun shen.<clauses*> (V1647) (let YaccParse (let Parse_shen.<clause*> (shen.<clause*> V1647) (if (not (= (fail) Parse_shen.<clause*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<clause*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (cons (shen.hdtl Parse_shen.<clause*>) (shen.hdtl Parse_shen.<clauses*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1647) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<clause*> (V1649) (let Parse_shen.<head*> (shen.<head*> V1649) (if (not (= (fail) Parse_shen.<head*>)) (if (and (cons? (hd Parse_shen.<head*>)) (= <-- (hd (hd Parse_shen.<head*>)))) (let Parse_shen.<body*> (shen.<body*> (shen.pair (tl (hd Parse_shen.<head*>)) (shen.hdtl Parse_shen.<head*>))) (if (not (= (fail) Parse_shen.<body*>)) (let Parse_shen.<end*> (shen.<end*> Parse_shen.<body*>) (if (not (= (fail) Parse_shen.<end*>)) (shen.pair (hd Parse_shen.<end*>) (cons (shen.hdtl Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<body*>) ()))) (fail))) (fail))) (fail)) (fail))))

(defun shen.<head*> (V1651) (let YaccParse (let Parse_shen.<term*> (shen.<term*> V1651) (if (not (= (fail) Parse_shen.<term*>)) (let Parse_shen.<head*> (shen.<head*> Parse_shen.<term*>) (if (not (= (fail) Parse_shen.<head*>)) (shen.pair (hd Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<term*>) (shen.hdtl Parse_shen.<head*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1651) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<term*> (V1653) (if (cons? (hd V1653)) (let Parse_X (hd (hd V1653)) (if (and (not (= <-- Parse_X)) (shen.legitimate-term? Parse_X)) (shen.pair (hd (shen.pair (tl (hd V1653)) (shen.hdtl V1653))) (shen.eval-cons Parse_X)) (fail))) (fail)))

(defun shen.legitimate-term? (V1659) (cond ((and (cons? V1659) (and (= cons (hd V1659)) (and (cons? (tl V1659)) (and (cons? (tl (tl V1659))) (= () (tl (tl (tl V1659)))))))) (and (shen.legitimate-term? (hd (tl V1659))) (shen.legitimate-term? (hd (tl (tl V1659)))))) ((and (cons? V1659) (and (= mode (hd V1659)) (and (cons? (tl V1659)) (and (cons? (tl (tl V1659))) (and (= + (hd (tl (tl V1659)))) (= () (tl (tl (tl V1659))))))))) (shen.legitimate-term? (hd (tl V1659)))) ((and (cons? V1659) (and (= mode (hd V1659)) (and (cons? (tl V1659)) (and (cons? (tl (tl V1659))) (and (= - (hd (tl (tl V1659)))) (= () (tl (tl (tl V1659))))))))) (shen.legitimate-term? (hd (tl V1659)))) ((cons? V1659) false) (true true)))

(defun shen.eval-cons (V1661) (cond ((and (cons? V1661) (and (= cons (hd V1661)) (and (cons? (tl V1661)) (and (cons? (tl (tl V1661))) (= () (tl (tl (tl V1661)))))))) (cons (shen.eval-cons (hd (tl V1661))) (shen.eval-cons (hd (tl (tl V1661)))))) ((and (cons? V1661) (and (= mode (hd V1661)) (and (cons? (tl V1661)) (and (cons? (tl (tl V1661))) (= () (tl (tl (tl V1661)))))))) (cons mode (cons (shen.eval-cons (hd (tl V1661))) (tl (tl V1661))))) (true V1661)))

(defun shen.<body*> (V1663) (let YaccParse (let Parse_shen.<literal*> (shen.<literal*> V1663) (if (not (= (fail) Parse_shen.<literal*>)) (let Parse_shen.<body*> (shen.<body*> Parse_shen.<literal*>) (if (not (= (fail) Parse_shen.<body*>)) (shen.pair (hd Parse_shen.<body*>) (cons (shen.hdtl Parse_shen.<literal*>) (shen.hdtl Parse_shen.<body*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1663) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<literal*> (V1665) (let YaccParse (if (and (cons? (hd V1665)) (= ! (hd (hd V1665)))) (shen.pair (hd (shen.pair (tl (hd V1665)) (shen.hdtl V1665))) (cons cut (cons (intern "Throwcontrol") ()))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V1665)) (let Parse_X (hd (hd V1665)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V1665)) (shen.hdtl V1665))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<end*> (V1667) (if (cons? (hd V1667)) (let Parse_X (hd (hd V1667)) (if (= Parse_X ;) (shen.pair (hd (shen.pair (tl (hd V1667)) (shen.hdtl V1667))) Parse_X) (fail))) (fail)))

(defun cut (V1671 V1672 V1673) (let Result (thaw V1673) (if (= Result false) V1671 Result)))

(defun shen.insert_modes (V1675) (cond ((and (cons? V1675) (and (= mode (hd V1675)) (and (cons? (tl V1675)) (and (cons? (tl (tl V1675))) (= () (tl (tl (tl V1675)))))))) V1675) ((= () V1675) ()) ((cons? V1675) (cons (cons mode (cons (hd V1675) (cons + ()))) (cons mode (cons (shen.insert_modes (tl V1675)) (cons - ()))))) (true V1675)))

(defun shen.s-prolog (V1677) (map (lambda X (eval X)) (shen.prolog->shen V1677)))

(defun shen.prolog->shen (V1679) (map (lambda X (shen.compile_prolog_procedure X)) (shen.group_clauses (map (lambda X (shen.s-prolog_clause X)) (mapcan (lambda X (shen.head_abstraction X)) V1679)))))

(defun shen.s-prolog_clause (V1681) (cond ((and (cons? V1681) (and (cons? (tl V1681)) (and (= :- (hd (tl V1681))) (and (cons? (tl (tl V1681))) (= () (tl (tl (tl V1681)))))))) (cons (hd V1681) (cons :- (cons (map (lambda X (shen.s-prolog_literal X)) (hd (tl (tl V1681)))) ())))) (true (shen.f_error shen.s-prolog_clause))))

(defun shen.head_abstraction (V1683) (cond ((and (cons? V1683) (and (cons? (tl V1683)) (and (= :- (hd (tl V1683))) (and (cons? (tl (tl V1683))) (and (= () (tl (tl (tl V1683)))) (< (shen.complexity_head (hd V1683)) (value shen.*maxcomplexity*))))))) (cons V1683 ())) ((and (cons? V1683) (and (cons? (hd V1683)) (and (cons? (tl V1683)) (and (= :- (hd (tl V1683))) (and (cons? (tl (tl V1683))) (= () (tl (tl (tl V1683))))))))) (let Terms (map (lambda Y (gensym V)) (tl (hd V1683))) (let XTerms (shen.rcons_form (shen.remove_modes (tl (hd V1683)))) (let Literal (cons unify (cons (shen.cons_form Terms) (cons XTerms ()))) (let Clause (cons (cons (hd (hd V1683)) Terms) (cons :- (cons (cons Literal (hd (tl (tl V1683)))) ()))) (cons Clause ())))))) (true (shen.f_error shen.head_abstraction))))

(defun shen.complexity_head (V1689) (cond ((cons? V1689) (shen.product (map (lambda X (shen.complexity X)) (tl V1689)))) (true (shen.f_error shen.complexity_head))))

(defun shen.complexity (V1698) (cond ((and (cons? V1698) (and (= mode (hd V1698)) (and (cons? (tl V1698)) (and (cons? (hd (tl V1698))) (and (= mode (hd (hd (tl V1698)))) (and (cons? (tl (hd (tl V1698)))) (and (cons? (tl (tl (hd (tl V1698))))) (and (= () (tl (tl (tl (hd (tl V1698)))))) (and (cons? (tl (tl V1698))) (= () (tl (tl (tl V1698))))))))))))) (shen.complexity (hd (tl V1698)))) ((and (cons? V1698) (and (= mode (hd V1698)) (and (cons? (tl V1698)) (and (cons? (hd (tl V1698))) (and (cons? (tl (tl V1698))) (and (= + (hd (tl (tl V1698)))) (= () (tl (tl (tl V1698)))))))))) (* 2 (* (shen.complexity (cons mode (cons (hd (hd (tl V1698))) (tl (tl V1698))))) (shen.complexity (cons mode (cons (tl (hd (tl V1698))) (tl (tl V1698)))))))) ((and (cons? V1698) (and (= mode (hd V1698)) (and (cons? (tl V1698)) (and (cons? (hd (tl V1698))) (and (cons? (tl (tl V1698))) (and (= - (hd (tl (tl V1698)))) (= () (tl (tl (tl V1698)))))))))) (* (shen.complexity (cons mode (cons (hd (hd (tl V1698))) (tl (tl V1698))))) (shen.complexity (cons mode (cons (tl (hd (tl V1698))) (tl (tl V1698))))))) ((and (cons? V1698) (and (= mode (hd V1698)) (and (cons? (tl V1698)) (and (cons? (tl (tl V1698))) (and (= () (tl (tl (tl V1698)))) (variable? (hd (tl V1698)))))))) 1) ((and (cons? V1698) (and (= mode (hd V1698)) (and (cons? (tl V1698)) (and (cons? (tl (tl V1698))) (and (= + (hd (tl (tl V1698)))) (= () (tl (tl (tl V1698))))))))) 2) ((and (cons? V1698) (and (= mode (hd V1698)) (and (cons? (tl V1698)) (and (cons? (tl (tl V1698))) (and (= - (hd (tl (tl V1698)))) (= () (tl (tl (tl V1698))))))))) 1) (true (shen.complexity (cons mode (cons V1698 (cons + ())))))))

(defun shen.product (V1700) (cond ((= () V1700) 1) ((cons? V1700) (* (hd V1700) (shen.product (tl V1700)))) (true (shen.f_error shen.product))))

(defun shen.s-prolog_literal (V1702) (cond ((and (cons? V1702) (and (= is (hd V1702)) (and (cons? (tl V1702)) (and (cons? (tl (tl V1702))) (= () (tl (tl (tl V1702)))))))) (cons bind (cons (hd (tl V1702)) (cons (shen.insert_deref (hd (tl (tl V1702)))) ())))) ((and (cons? V1702) (and (= when (hd V1702)) (and (cons? (tl V1702)) (= () (tl (tl V1702)))))) (cons fwhen (cons (shen.insert_deref (hd (tl V1702))) ()))) ((and (cons? V1702) (and (= bind (hd V1702)) (and (cons? (tl V1702)) (and (cons? (tl (tl V1702))) (= () (tl (tl (tl V1702)))))))) (cons bind (cons (hd (tl V1702)) (cons (shen.insert_lazyderef (hd (tl (tl V1702)))) ())))) ((and (cons? V1702) (and (= fwhen (hd V1702)) (and (cons? (tl V1702)) (= () (tl (tl V1702)))))) (cons fwhen (cons (shen.insert_lazyderef (hd (tl V1702))) ()))) ((cons? V1702) V1702) (true (shen.f_error shen.s-prolog_literal))))

(defun shen.insert_deref (V1704) (cond ((variable? V1704) (cons shen.deref (cons V1704 (cons ProcessN ())))) ((cons? V1704) (cons (shen.insert_deref (hd V1704)) (shen.insert_deref (tl V1704)))) (true V1704)))

(defun shen.insert_lazyderef (V1706) (cond ((variable? V1706) (cons shen.lazyderef (cons V1706 (cons ProcessN ())))) ((cons? V1706) (cons (shen.insert_lazyderef (hd V1706)) (shen.insert_lazyderef (tl V1706)))) (true V1706)))

(defun shen.group_clauses (V1708) (cond ((= () V1708) ()) ((cons? V1708) (let Group (shen.collect (lambda X (shen.same_predicate? (hd V1708) X)) V1708) (let Rest (difference V1708 Group) (cons Group (shen.group_clauses Rest))))) (true (shen.f_error shen.group_clauses))))

(defun shen.collect (V1713 V1714) (cond ((= () V1714) ()) ((cons? V1714) (if (V1713 (hd V1714)) (cons (hd V1714) (shen.collect V1713 (tl V1714))) (shen.collect V1713 (tl V1714)))) (true (shen.f_error shen.collect))))

(defun shen.same_predicate? (V1733 V1734) (cond ((and (cons? V1733) (and (cons? (hd V1733)) (and (cons? V1734) (cons? (hd V1734))))) (= (hd (hd V1733)) (hd (hd V1734)))) (true (shen.f_error shen.same_predicate?))))

(defun shen.compile_prolog_procedure (V1736) (let F (shen.procedure_name V1736) (let Shen (shen.clauses-to-shen F V1736) Shen)))

(defun shen.procedure_name (V1750) (cond ((and (cons? V1750) (and (cons? (hd V1750)) (cons? (hd (hd V1750))))) (hd (hd (hd V1750)))) (true (shen.f_error shen.procedure_name))))

(defun shen.clauses-to-shen (V1753 V1754) (let Linear (map (lambda X (shen.linearise-clause X)) V1754) (let Arity (shen.prolog-aritycheck V1753 (map (lambda X (head X)) V1754)) (let Parameters (shen.parameters Arity) (let AUM_instructions (map (lambda X (shen.aum X Parameters)) Linear) (let Code (shen.catch-cut (shen.nest-disjunct (map (lambda X (shen.aum_to_shen X)) AUM_instructions))) (let ShenDef (cons define (cons V1753 (append Parameters (append (cons ProcessN (cons Continuation ())) (cons -> (cons Code ())))))) ShenDef)))))))

(defun shen.catch-cut (V1756) (cond ((not (shen.occurs? cut V1756)) V1756) (true (cons let (cons Throwcontrol (cons (cons shen.catchpoint ()) (cons (cons shen.cutpoint (cons Throwcontrol (cons V1756 ()))) ())))))))

(defun shen.catchpoint () (set shen.*catch* (+ 1 (value shen.*catch*))))

(defun shen.cutpoint (V1764 V1765) (cond ((= V1765 V1764) false) (true V1765)))

(defun shen.nest-disjunct (V1767) (cond ((and (cons? V1767) (= () (tl V1767))) (hd V1767)) ((cons? V1767) (shen.lisp-or (hd V1767) (shen.nest-disjunct (tl V1767)))) (true (shen.f_error shen.nest-disjunct))))

(defun shen.lisp-or (V1770 V1771) (cons let (cons Case (cons V1770 (cons (cons if (cons (cons = (cons Case (cons false ()))) (cons V1771 (cons Case ())))) ())))))

(defun shen.prolog-aritycheck (V1776 V1777) (cond ((and (cons? V1777) (= () (tl V1777))) (- (length (hd V1777)) 1)) ((and (cons? V1777) (cons? (tl V1777))) (if (= (length (hd V1777)) (length (hd (tl V1777)))) (shen.prolog-aritycheck V1776 (tl V1777)) (simple-error (cn "arity error in prolog procedure " (shen.app (cons V1776 ()) "
" shen.a))))) (true (shen.f_error shen.prolog-aritycheck))))

(defun shen.linearise-clause (V1779) (cond ((and (cons? V1779) (and (cons? (tl V1779)) (and (= :- (hd (tl V1779))) (and (cons? (tl (tl V1779))) (= () (tl (tl (tl V1779)))))))) (let Linear (shen.linearise (cons (hd V1779) (tl (tl V1779)))) (shen.clause_form Linear))) (true (shen.f_error shen.linearise-clause))))

(defun shen.clause_form (V1781) (cond ((and (cons? V1781) (and (cons? (tl V1781)) (= () (tl (tl V1781))))) (cons (shen.explicit_modes (hd V1781)) (cons :- (cons (shen.cf_help (hd (tl V1781))) ())))) (true (shen.f_error shen.clause_form))))

(defun shen.explicit_modes (V1783) (cond ((cons? V1783) (cons (hd V1783) (map (lambda X (shen.em_help X)) (tl V1783)))) (true (shen.f_error shen.explicit_modes))))

(defun shen.em_help (V1785) (cond ((and (cons? V1785) (and (= mode (hd V1785)) (and (cons? (tl V1785)) (and (cons? (tl (tl V1785))) (= () (tl (tl (tl V1785)))))))) V1785) (true (cons mode (cons V1785 (cons + ()))))))

(defun shen.cf_help (V1787) (cond ((and (cons? V1787) (and (= where (hd V1787)) (and (cons? (tl V1787)) (and (cons? (hd (tl V1787))) (and (= = (hd (hd (tl V1787)))) (and (cons? (tl (hd (tl V1787)))) (and (cons? (tl (tl (hd (tl V1787))))) (and (= () (tl (tl (tl (hd (tl V1787)))))) (and (cons? (tl (tl V1787))) (= () (tl (tl (tl V1787))))))))))))) (cons (cons (if (value shen.*occurs*) unify! unify) (tl (hd (tl V1787)))) (shen.cf_help (hd (tl (tl V1787)))))) (true V1787)))

(defun occurs-check (V1793) (cond ((= + V1793) (set shen.*occurs* true)) ((= - V1793) (set shen.*occurs* false)) (true (simple-error "occurs-check expects + or -
"))))

(defun shen.aum (V1796 V1797) (cond ((and (cons? V1796) (and (cons? (hd V1796)) (and (cons? (tl V1796)) (and (= :- (hd (tl V1796))) (and (cons? (tl (tl V1796))) (= () (tl (tl (tl V1796))))))))) (let MuApplication (shen.make_mu_application (cons shen.mu (cons (tl (hd V1796)) (cons (shen.continuation_call (tl (hd V1796)) (hd (tl (tl V1796)))) ()))) V1797) (shen.mu_reduction MuApplication +))) (true (shen.f_error shen.aum))))

(defun shen.continuation_call (V1800 V1801) (let VTerms (cons ProcessN (shen.extract_vars V1800)) (let VBody (shen.extract_vars V1801) (let Free (remove Throwcontrol (difference VBody VTerms)) (shen.cc_help Free V1801)))))

(defun remove (V1804 V1805) (shen.remove-h V1804 V1805 ()))

(defun shen.remove-h (V1812 V1813 V1814) (cond ((= () V1813) (reverse V1814)) ((and (cons? V1813) (= (hd V1813) V1812)) (shen.remove-h (hd V1813) (tl V1813) V1814)) ((cons? V1813) (shen.remove-h V1812 (tl V1813) (cons (hd V1813) V1814))) (true (shen.f_error shen.remove-h))))

(defun shen.cc_help (V1817 V1818) (cond ((and (= () V1817) (= () V1818)) (cons shen.pop (cons shen.the (cons shen.stack ())))) ((= () V1818) (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V1817 (cons and (cons shen.then (cons (cons shen.pop (cons shen.the (cons shen.stack ()))) ()))))))))) ((= () V1817) (cons call (cons shen.the (cons shen.continuation (cons V1818 ()))))) (true (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V1817 (cons and (cons shen.then (cons (cons call (cons shen.the (cons shen.continuation (cons V1818 ())))) ())))))))))))

(defun shen.make_mu_application (V1821 V1822) (cond ((and (cons? V1821) (and (= shen.mu (hd V1821)) (and (cons? (tl V1821)) (and (= () (hd (tl V1821))) (and (cons? (tl (tl V1821))) (and (= () (tl (tl (tl V1821)))) (= () V1822))))))) (hd (tl (tl V1821)))) ((and (cons? V1821) (and (= shen.mu (hd V1821)) (and (cons? (tl V1821)) (and (cons? (hd (tl V1821))) (and (cons? (tl (tl V1821))) (and (= () (tl (tl (tl V1821)))) (cons? V1822))))))) (cons (cons shen.mu (cons (hd (hd (tl V1821))) (cons (shen.make_mu_application (cons shen.mu (cons (tl (hd (tl V1821))) (tl (tl V1821)))) (tl V1822)) ()))) (cons (hd V1822) ()))) (true (shen.f_error shen.make_mu_application))))

(defun shen.mu_reduction (V1831 V1832) (cond ((and (cons? V1831) (and (cons? (hd V1831)) (and (= shen.mu (hd (hd V1831))) (and (cons? (tl (hd V1831))) (and (cons? (hd (tl (hd V1831)))) (and (= mode (hd (hd (tl (hd V1831))))) (and (cons? (tl (hd (tl (hd V1831))))) (and (cons? (tl (tl (hd (tl (hd V1831)))))) (and (= () (tl (tl (tl (hd (tl (hd V1831))))))) (and (cons? (tl (tl (hd V1831)))) (and (= () (tl (tl (tl (hd V1831))))) (and (cons? (tl V1831)) (= () (tl (tl V1831))))))))))))))) (shen.mu_reduction (cons (cons shen.mu (cons (hd (tl (hd (tl (hd V1831))))) (tl (tl (hd V1831))))) (tl V1831)) (hd (tl (tl (hd (tl (hd V1831)))))))) ((and (cons? V1831) (and (cons? (hd V1831)) (and (= shen.mu (hd (hd V1831))) (and (cons? (tl (hd V1831))) (and (cons? (tl (tl (hd V1831)))) (and (= () (tl (tl (tl (hd V1831))))) (and (cons? (tl V1831)) (and (= () (tl (tl V1831))) (= _ (hd (tl (hd V1831)))))))))))) (shen.mu_reduction (hd (tl (tl (hd V1831)))) V1832)) ((and (cons? V1831) (and (cons? (hd V1831)) (and (= shen.mu (hd (hd V1831))) (and (cons? (tl (hd V1831))) (and (cons? (tl (tl (hd V1831)))) (and (= () (tl (tl (tl (hd V1831))))) (and (cons? (tl V1831)) (and (= () (tl (tl V1831))) (shen.ephemeral_variable? (hd (tl (hd V1831))) (hd (tl V1831))))))))))) (subst (hd (tl V1831)) (hd (tl (hd V1831))) (shen.mu_reduction (hd (tl (tl (hd V1831)))) V1832))) ((and (cons? V1831) (and (cons? (hd V1831)) (and (= shen.mu (hd (hd V1831))) (and (cons? (tl (hd V1831))) (and (cons? (tl (tl (hd V1831)))) (and (= () (tl (tl (tl (hd V1831))))) (and (cons? (tl V1831)) (and (= () (tl (tl V1831))) (variable? (hd (tl (hd V1831)))))))))))) (cons let (cons (hd (tl (hd V1831))) (cons shen.be (cons (hd (tl V1831)) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1831)))) V1832) ()))))))) ((and (cons? V1831) (and (cons? (hd V1831)) (and (= shen.mu (hd (hd V1831))) (and (cons? (tl (hd V1831))) (and (cons? (tl (tl (hd V1831)))) (and (= () (tl (tl (tl (hd V1831))))) (and (cons? (tl V1831)) (and (= () (tl (tl V1831))) (and (= - V1832) (shen.prolog_constant? (hd (tl (hd V1831))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1831))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V1831))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V1831)))) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V1831) (and (cons? (hd V1831)) (and (= shen.mu (hd (hd V1831))) (and (cons? (tl (hd V1831))) (and (cons? (tl (tl (hd V1831)))) (and (= () (tl (tl (tl (hd V1831))))) (and (cons? (tl V1831)) (and (= () (tl (tl V1831))) (and (= + V1832) (shen.prolog_constant? (hd (tl (hd V1831))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1831))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V1831))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V1831)))) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (hd (tl (hd V1831))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1831)))) +) ())))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) ((and (cons? V1831) (and (cons? (hd V1831)) (and (= shen.mu (hd (hd V1831))) (and (cons? (tl (hd V1831))) (and (cons? (hd (tl (hd V1831)))) (and (cons? (tl (tl (hd V1831)))) (and (= () (tl (tl (tl (hd V1831))))) (and (cons? (tl V1831)) (and (= () (tl (tl V1831))) (= - V1832)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1831))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V1831)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V1831)))) (tl (tl (hd V1831))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V1831) (and (cons? (hd V1831)) (and (= shen.mu (hd (hd V1831))) (and (cons? (tl (hd V1831))) (and (cons? (hd (tl (hd V1831)))) (and (cons? (tl (tl (hd V1831)))) (and (= () (tl (tl (tl (hd V1831))))) (and (cons? (tl V1831)) (and (= () (tl (tl V1831))) (= + V1832)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1831))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V1831)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V1831)))) (tl (tl (hd V1831))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (shen.extract_vars (hd (tl (hd V1831)))) (cons and (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (shen.rcons_form (shen.remove_modes (hd (tl (hd V1831))))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1831)))) +) ())))))) ())))))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) (true V1831)))

(defun shen.rcons_form (V1834) (cond ((cons? V1834) (cons cons (cons (shen.rcons_form (hd V1834)) (cons (shen.rcons_form (tl V1834)) ())))) (true V1834)))

(defun shen.remove_modes (V1836) (cond ((and (cons? V1836) (and (= mode (hd V1836)) (and (cons? (tl V1836)) (and (cons? (tl (tl V1836))) (and (= + (hd (tl (tl V1836)))) (= () (tl (tl (tl V1836))))))))) (shen.remove_modes (hd (tl V1836)))) ((and (cons? V1836) (and (= mode (hd V1836)) (and (cons? (tl V1836)) (and (cons? (tl (tl V1836))) (and (= - (hd (tl (tl V1836)))) (= () (tl (tl (tl V1836))))))))) (shen.remove_modes (hd (tl V1836)))) ((cons? V1836) (cons (shen.remove_modes (hd V1836)) (shen.remove_modes (tl V1836)))) (true V1836)))

(defun shen.ephemeral_variable? (V1839 V1840) (and (variable? V1839) (variable? V1840)))

(defun shen.prolog_constant? (V1850) (cond ((cons? V1850) false) (true true)))

(defun shen.aum_to_shen (V1852) (cond ((and (cons? V1852) (and (= let (hd V1852)) (and (cons? (tl V1852)) (and (cons? (tl (tl V1852))) (and (= shen.be (hd (tl (tl V1852)))) (and (cons? (tl (tl (tl V1852)))) (and (cons? (tl (tl (tl (tl V1852))))) (and (= in (hd (tl (tl (tl (tl V1852)))))) (and (cons? (tl (tl (tl (tl (tl V1852)))))) (= () (tl (tl (tl (tl (tl (tl V1852)))))))))))))))) (cons let (cons (hd (tl V1852)) (cons (shen.aum_to_shen (hd (tl (tl (tl V1852))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1852))))))) ()))))) ((and (cons? V1852) (and (= shen.the (hd V1852)) (and (cons? (tl V1852)) (and (= shen.result (hd (tl V1852))) (and (cons? (tl (tl V1852))) (and (= shen.of (hd (tl (tl V1852)))) (and (cons? (tl (tl (tl V1852)))) (and (= shen.dereferencing (hd (tl (tl (tl V1852))))) (and (cons? (tl (tl (tl (tl V1852))))) (= () (tl (tl (tl (tl (tl V1852))))))))))))))) (cons shen.lazyderef (cons (shen.aum_to_shen (hd (tl (tl (tl (tl V1852)))))) (cons ProcessN ())))) ((and (cons? V1852) (and (= if (hd V1852)) (and (cons? (tl V1852)) (and (cons? (tl (tl V1852))) (and (= shen.then (hd (tl (tl V1852)))) (and (cons? (tl (tl (tl V1852)))) (and (cons? (tl (tl (tl (tl V1852))))) (and (= shen.else (hd (tl (tl (tl (tl V1852)))))) (and (cons? (tl (tl (tl (tl (tl V1852)))))) (= () (tl (tl (tl (tl (tl (tl V1852)))))))))))))))) (cons if (cons (shen.aum_to_shen (hd (tl V1852))) (cons (shen.aum_to_shen (hd (tl (tl (tl V1852))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1852))))))) ()))))) ((and (cons? V1852) (and (cons? (tl V1852)) (and (= is (hd (tl V1852))) (and (cons? (tl (tl V1852))) (and (= shen.a (hd (tl (tl V1852)))) (and (cons? (tl (tl (tl V1852)))) (and (= shen.variable (hd (tl (tl (tl V1852))))) (= () (tl (tl (tl (tl V1852)))))))))))) (cons shen.pvar? (cons (hd V1852) ()))) ((and (cons? V1852) (and (cons? (tl V1852)) (and (= is (hd (tl V1852))) (and (cons? (tl (tl V1852))) (and (= shen.a (hd (tl (tl V1852)))) (and (cons? (tl (tl (tl V1852)))) (and (= shen.non-empty (hd (tl (tl (tl V1852))))) (and (cons? (tl (tl (tl (tl V1852))))) (and (= list (hd (tl (tl (tl (tl V1852)))))) (= () (tl (tl (tl (tl (tl V1852))))))))))))))) (cons cons? (cons (hd V1852) ()))) ((and (cons? V1852) (and (= shen.rename (hd V1852)) (and (cons? (tl V1852)) (and (= shen.the (hd (tl V1852))) (and (cons? (tl (tl V1852))) (and (= shen.variables (hd (tl (tl V1852)))) (and (cons? (tl (tl (tl V1852)))) (and (= in (hd (tl (tl (tl V1852))))) (and (cons? (tl (tl (tl (tl V1852))))) (and (= () (hd (tl (tl (tl (tl V1852)))))) (and (cons? (tl (tl (tl (tl (tl V1852)))))) (and (= and (hd (tl (tl (tl (tl (tl V1852))))))) (and (cons? (tl (tl (tl (tl (tl (tl V1852))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V1852)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V1852)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V1852)))))))))))))))))))))))) (shen.aum_to_shen (hd (tl (tl (tl (tl (tl (tl (tl V1852)))))))))) ((and (cons? V1852) (and (= shen.rename (hd V1852)) (and (cons? (tl V1852)) (and (= shen.the (hd (tl V1852))) (and (cons? (tl (tl V1852))) (and (= shen.variables (hd (tl (tl V1852)))) (and (cons? (tl (tl (tl V1852)))) (and (= in (hd (tl (tl (tl V1852))))) (and (cons? (tl (tl (tl (tl V1852))))) (and (cons? (hd (tl (tl (tl (tl V1852)))))) (and (cons? (tl (tl (tl (tl (tl V1852)))))) (and (= and (hd (tl (tl (tl (tl (tl V1852))))))) (and (cons? (tl (tl (tl (tl (tl (tl V1852))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V1852)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V1852)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V1852)))))))))))))))))))))))) (cons let (cons (hd (hd (tl (tl (tl (tl V1852)))))) (cons (cons shen.newpv (cons ProcessN ())) (cons (shen.aum_to_shen (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (tl (hd (tl (tl (tl (tl V1852)))))) (tl (tl (tl (tl (tl V1852))))))))))) ()))))) ((and (cons? V1852) (and (= bind (hd V1852)) (and (cons? (tl V1852)) (and (cons? (tl (tl V1852))) (and (= shen.to (hd (tl (tl V1852)))) (and (cons? (tl (tl (tl V1852)))) (and (cons? (tl (tl (tl (tl V1852))))) (and (= in (hd (tl (tl (tl (tl V1852)))))) (and (cons? (tl (tl (tl (tl (tl V1852)))))) (= () (tl (tl (tl (tl (tl (tl V1852)))))))))))))))) (cons do (cons (cons shen.bindv (cons (hd (tl V1852)) (cons (shen.chwild (hd (tl (tl (tl V1852))))) (cons ProcessN ())))) (cons (cons let (cons Result (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1852))))))) (cons (cons do (cons (cons shen.unbindv (cons (hd (tl V1852)) (cons ProcessN ()))) (cons Result ()))) ())))) ())))) ((and (cons? V1852) (and (cons? (tl V1852)) (and (= is (hd (tl V1852))) (and (cons? (tl (tl V1852))) (and (= identical (hd (tl (tl V1852)))) (and (cons? (tl (tl (tl V1852)))) (and (= shen.to (hd (tl (tl (tl V1852))))) (and (cons? (tl (tl (tl (tl V1852))))) (= () (tl (tl (tl (tl (tl V1852)))))))))))))) (cons = (cons (hd (tl (tl (tl (tl V1852))))) (cons (hd V1852) ())))) ((= shen.failed! V1852) false) ((and (cons? V1852) (and (= shen.the (hd V1852)) (and (cons? (tl V1852)) (and (= head (hd (tl V1852))) (and (cons? (tl (tl V1852))) (and (= shen.of (hd (tl (tl V1852)))) (and (cons? (tl (tl (tl V1852)))) (= () (tl (tl (tl (tl V1852)))))))))))) (cons hd (tl (tl (tl V1852))))) ((and (cons? V1852) (and (= shen.the (hd V1852)) (and (cons? (tl V1852)) (and (= tail (hd (tl V1852))) (and (cons? (tl (tl V1852))) (and (= shen.of (hd (tl (tl V1852)))) (and (cons? (tl (tl (tl V1852)))) (= () (tl (tl (tl (tl V1852)))))))))))) (cons tl (tl (tl (tl V1852))))) ((and (cons? V1852) (and (= shen.pop (hd V1852)) (and (cons? (tl V1852)) (and (= shen.the (hd (tl V1852))) (and (cons? (tl (tl V1852))) (and (= shen.stack (hd (tl (tl V1852)))) (= () (tl (tl (tl V1852)))))))))) (cons do (cons (cons shen.incinfs ()) (cons (cons thaw (cons Continuation ())) ())))) ((and (cons? V1852) (and (= call (hd V1852)) (and (cons? (tl V1852)) (and (= shen.the (hd (tl V1852))) (and (cons? (tl (tl V1852))) (and (= shen.continuation (hd (tl (tl V1852)))) (and (cons? (tl (tl (tl V1852)))) (= () (tl (tl (tl (tl V1852)))))))))))) (cons do (cons (cons shen.incinfs ()) (cons (shen.call_the_continuation (shen.chwild (hd (tl (tl (tl V1852))))) ProcessN Continuation) ())))) (true V1852)))

(defun shen.chwild (V1854) (cond ((= V1854 _) (cons shen.newpv (cons ProcessN ()))) ((cons? V1854) (map (lambda Z (shen.chwild Z)) V1854)) (true V1854)))

(defun shen.newpv (V1856) (let Count+1 (+ (<-address (value shen.*varcounter*) V1856) 1) (let IncVar (address-> (value shen.*varcounter*) V1856 Count+1) (let Vector (<-address (value shen.*prologvectors*) V1856) (let ResizeVectorIfNeeded (if (= Count+1 (limit Vector)) (shen.resizeprocessvector V1856 Count+1) shen.skip) (shen.mk-pvar Count+1))))))

(defun shen.resizeprocessvector (V1859 V1860) (let Vector (<-address (value shen.*prologvectors*) V1859) (let BigVector (shen.resize-vector Vector (+ V1860 V1860) shen.-null-) (address-> (value shen.*prologvectors*) V1859 BigVector))))

(defun shen.resize-vector (V1864 V1865 V1866) (let BigVector (address-> (absvector (+ 1 V1865)) 0 V1865) (shen.copy-vector V1864 BigVector (limit V1864) V1865 V1866)))

(defun shen.copy-vector (V1872 V1873 V1874 V1875 V1876) (shen.copy-vector-stage-2 (+ 1 V1874) (+ V1875 1) V1876 (shen.copy-vector-stage-1 1 V1872 V1873 (+ 1 V1874))))

(defun shen.copy-vector-stage-1 (V1884 V1885 V1886 V1887) (cond ((= V1887 V1884) V1886) (true (shen.copy-vector-stage-1 (+ 1 V1884) V1885 (address-> V1886 V1884 (<-address V1885 V1884)) V1887))))

(defun shen.copy-vector-stage-2 (V1895 V1896 V1897 V1898) (cond ((= V1896 V1895) V1898) (true (shen.copy-vector-stage-2 (+ V1895 1) V1896 V1897 (address-> V1898 V1895 V1897)))))

(defun shen.mk-pvar (V1900) (address-> (address-> (absvector 2) 0 shen.pvar) 1 V1900))

(defun shen.pvar? (V1902) (trap-error (and (absvector? V1902) (= (<-address V1902 0) shen.pvar)) (lambda E false)))

(defun shen.bindv (V1906 V1907 V1908) (let Vector (<-address (value shen.*prologvectors*) V1908) (address-> Vector (<-address V1906 1) V1907)))

(defun shen.unbindv (V1911 V1912) (let Vector (<-address (value shen.*prologvectors*) V1912) (address-> Vector (<-address V1911 1) shen.-null-)))

(defun shen.incinfs () (set shen.*infs* (+ 1 (value shen.*infs*))))

(defun shen.call_the_continuation (V1916 V1917 V1918) (cond ((and (cons? V1916) (and (cons? (hd V1916)) (= () (tl V1916)))) (cons (hd (hd V1916)) (append (tl (hd V1916)) (cons V1917 (cons V1918 ()))))) ((and (cons? V1916) (cons? (hd V1916))) (let NewContinuation (shen.newcontinuation (tl V1916) V1917 V1918) (cons (hd (hd V1916)) (append (tl (hd V1916)) (cons V1917 (cons NewContinuation ())))))) (true (shen.f_error shen.call_the_continuation))))

(defun shen.newcontinuation (V1922 V1923 V1924) (cond ((= () V1922) V1924) ((and (cons? V1922) (cons? (hd V1922))) (cons freeze (cons (cons (hd (hd V1922)) (append (tl (hd V1922)) (cons V1923 (cons (shen.newcontinuation (tl V1922) V1923 V1924) ())))) ()))) (true (shen.f_error shen.newcontinuation))))

(defun return (V1932 V1933 V1934) (shen.deref V1932 V1933))

(defun shen.measure&return (V1942 V1943 V1944) (do (shen.prhush (shen.app (value shen.*infs*) " inferences
" shen.a) (stoutput)) (shen.deref V1942 V1943)))

(defun unify (V1949 V1950 V1951 V1952) (shen.lzy= (shen.lazyderef V1949 V1951) (shen.lazyderef V1950 V1951) V1951 V1952))

(defun shen.lzy= (V1974 V1975 V1976 V1977) (cond ((= V1975 V1974) (thaw V1977)) ((shen.pvar? V1974) (bind V1974 V1975 V1976 V1977)) ((shen.pvar? V1975) (bind V1975 V1974 V1976 V1977)) ((and (cons? V1974) (cons? V1975)) (shen.lzy= (shen.lazyderef (hd V1974) V1976) (shen.lazyderef (hd V1975) V1976) V1976 (freeze (shen.lzy= (shen.lazyderef (tl V1974) V1976) (shen.lazyderef (tl V1975) V1976) V1976 V1977)))) (true false)))

(defun shen.deref (V1980 V1981) (cond ((cons? V1980) (cons (shen.deref (hd V1980) V1981) (shen.deref (tl V1980) V1981))) (true (if (shen.pvar? V1980) (let Value (shen.valvector V1980 V1981) (if (= Value shen.-null-) V1980 (shen.deref Value V1981))) V1980))))

(defun shen.lazyderef (V1984 V1985) (if (shen.pvar? V1984) (let Value (shen.valvector V1984 V1985) (if (= Value shen.-null-) V1984 (shen.lazyderef Value V1985))) V1984))

(defun shen.valvector (V1988 V1989) (<-address (<-address (value shen.*prologvectors*) V1989) (<-address V1988 1)))

(defun unify! (V1994 V1995 V1996 V1997) (shen.lzy=! (shen.lazyderef V1994 V1996) (shen.lazyderef V1995 V1996) V1996 V1997))

(defun shen.lzy=! (V2019 V2020 V2021 V2022) (cond ((= V2020 V2019) (thaw V2022)) ((and (shen.pvar? V2019) (not (shen.occurs? V2019 (shen.deref V2020 V2021)))) (bind V2019 V2020 V2021 V2022)) ((and (shen.pvar? V2020) (not (shen.occurs? V2020 (shen.deref V2019 V2021)))) (bind V2020 V2019 V2021 V2022)) ((and (cons? V2019) (cons? V2020)) (shen.lzy=! (shen.lazyderef (hd V2019) V2021) (shen.lazyderef (hd V2020) V2021) V2021 (freeze (shen.lzy=! (shen.lazyderef (tl V2019) V2021) (shen.lazyderef (tl V2020) V2021) V2021 V2022)))) (true false)))

(defun shen.occurs? (V2034 V2035) (cond ((= V2035 V2034) true) ((cons? V2035) (or (shen.occurs? V2034 (hd V2035)) (shen.occurs? V2034 (tl V2035)))) (true false)))

(defun identical (V2040 V2041 V2042 V2043) (shen.lzy== (shen.lazyderef V2040 V2042) (shen.lazyderef V2041 V2042) V2042 V2043))

(defun shen.lzy== (V2065 V2066 V2067 V2068) (cond ((= V2066 V2065) (thaw V2068)) ((and (cons? V2065) (cons? V2066)) (shen.lzy== (shen.lazyderef (hd V2065) V2067) (shen.lazyderef (hd V2066) V2067) V2067 (freeze (shen.lzy== (tl V2065) (tl V2066) V2067 V2068)))) (true false)))

(defun shen.pvar (V2070) (cn "Var" (shen.app (<-address V2070 1) "" shen.a)))

(defun bind (V2075 V2076 V2077 V2078) (do (shen.bindv V2075 V2076 V2077) (let Result (thaw V2078) (do (shen.unbindv V2075 V2077) Result))))

(defun fwhen (V2096 V2097 V2098) (cond ((= true V2096) (thaw V2098)) ((= false V2096) false) (true (simple-error (cn "fwhen expects a boolean: not " (shen.app V2096 "%" shen.s))))))

(defun call (V2114 V2115 V2116) (cond ((cons? V2114) (shen.call-help (function (shen.lazyderef (hd V2114) V2115)) (tl V2114) V2115 V2116)) (true false)))

(defun shen.call-help (V2121 V2122 V2123 V2124) (cond ((= () V2122) (V2121 V2123 V2124)) ((cons? V2122) (shen.call-help (V2121 (hd V2122)) (tl V2122) V2123 V2124)) (true (shen.f_error shen.call-help))))

(defun shen.intprolog (V2126) (cond ((and (cons? V2126) (cons? (hd V2126))) (let ProcessN (shen.start-new-prolog-process) (shen.intprolog-help (hd (hd V2126)) (shen.insert-prolog-variables (cons (tl (hd V2126)) (cons (tl V2126) ())) ProcessN) ProcessN))) (true (shen.f_error shen.intprolog))))

(defun shen.intprolog-help (V2130 V2131 V2132) (cond ((and (cons? V2131) (and (cons? (tl V2131)) (= () (tl (tl V2131))))) (shen.intprolog-help-help V2130 (hd V2131) (hd (tl V2131)) V2132)) (true (shen.f_error shen.intprolog-help))))

(defun shen.intprolog-help-help (V2137 V2138 V2139 V2140) (cond ((= () V2138) (V2137 V2140 (freeze (shen.call-rest V2139 V2140)))) ((cons? V2138) (shen.intprolog-help-help (V2137 (hd V2138)) (tl V2138) V2139 V2140)) (true (shen.f_error shen.intprolog-help-help))))

(defun shen.call-rest (V2145 V2146) (cond ((= () V2145) true) ((and (cons? V2145) (and (cons? (hd V2145)) (cons? (tl (hd V2145))))) (shen.call-rest (cons (cons ((hd (hd V2145)) (hd (tl (hd V2145)))) (tl (tl (hd V2145)))) (tl V2145)) V2146)) ((and (cons? V2145) (and (cons? (hd V2145)) (= () (tl (hd V2145))))) ((hd (hd V2145)) V2146 (freeze (shen.call-rest (tl V2145) V2146)))) (true (shen.f_error shen.call-rest))))

(defun shen.start-new-prolog-process () (let IncrementProcessCounter (set shen.*process-counter* (+ 1 (value shen.*process-counter*))) (shen.initialise-prolog IncrementProcessCounter)))

(defun shen.insert-prolog-variables (V2149 V2150) (shen.insert-prolog-variables-help V2149 (shen.flatten V2149) V2150))

(defun shen.insert-prolog-variables-help (V2158 V2159 V2160) (cond ((= () V2159) V2158) ((and (cons? V2159) (variable? (hd V2159))) (let V (shen.newpv V2160) (let XV/Y (subst V (hd V2159) V2158) (let Z-Y (remove (hd V2159) (tl V2159)) (shen.insert-prolog-variables-help XV/Y Z-Y V2160))))) ((cons? V2159) (shen.insert-prolog-variables-help V2158 (tl V2159) V2160)) (true (shen.f_error shen.insert-prolog-variables-help))))

(defun shen.initialise-prolog (V2162) (let Vector (address-> (value shen.*prologvectors*) V2162 (shen.fillvector (vector 10) 1 10 shen.-null-)) (let Counter (address-> (value shen.*varcounter*) V2162 1) V2162)))



