"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun thaw (V2617) (V2617))

(defun eval (V2619) (let Macroexpand (shen.walk (lambda Y (macroexpand Y)) V2619) (if (shen.packaged? Macroexpand) (map (lambda Z (shen.eval-without-macros Z)) (shen.package-contents Macroexpand)) (shen.eval-without-macros Macroexpand))))

(defun shen.eval-without-macros (V2621) (eval-kl (shen.elim-def (shen.proc-input+ V2621))))

(defun shen.proc-input+ (V2623) (cond ((and (cons? V2623) (and (= input+ (hd V2623)) (and (cons? (tl V2623)) (and (cons? (tl (tl V2623))) (= () (tl (tl (tl V2623)))))))) (cons input+ (cons (shen.rcons_form (hd (tl V2623))) (tl (tl V2623))))) ((and (cons? V2623) (and (= shen.read+ (hd V2623)) (and (cons? (tl V2623)) (and (cons? (tl (tl V2623))) (= () (tl (tl (tl V2623)))))))) (cons shen.read+ (cons (shen.rcons_form (hd (tl V2623))) (tl (tl V2623))))) ((cons? V2623) (map (lambda Z (shen.proc-input+ Z)) V2623)) (true V2623)))

(defun shen.elim-def (V2625) (cond ((and (cons? V2625) (and (= define (hd V2625)) (cons? (tl V2625)))) (shen.shen->kl (hd (tl V2625)) (tl (tl V2625)))) ((and (cons? V2625) (and (= defmacro (hd V2625)) (cons? (tl V2625)))) (let Default (cons X (cons -> (cons X ()))) (let Def (shen.elim-def (cons define (cons (hd (tl V2625)) (append (tl (tl V2625)) Default)))) (let MacroAdd (shen.add-macro (hd (tl V2625))) Def)))) ((and (cons? V2625) (and (= defcc (hd V2625)) (cons? (tl V2625)))) (shen.elim-def (shen.yacc V2625))) ((cons? V2625) (map (lambda Z (shen.elim-def Z)) V2625)) (true V2625)))

(defun shen.add-macro (V2627) (let MacroReg (value shen.*macroreg*) (let NewMacroReg (set shen.*macroreg* (adjoin V2627 (value shen.*macroreg*))) (if (= MacroReg NewMacroReg) shen.skip (set *macros* (cons (function V2627) (value *macros*)))))))

(defun shen.packaged? (V2635) (cond ((and (cons? V2635) (and (= package (hd V2635)) (and (cons? (tl V2635)) (cons? (tl (tl V2635)))))) true) (true false)))

(defun external (V2637) (trap-error (get V2637 shen.external-symbols (value *property-vector*)) (lambda E (simple-error (cn "package " (shen.app V2637 " has not been used.
" shen.a))))))

(defun internal (V2639) (trap-error (get V2639 shen.internal-symbols (value *property-vector*)) (lambda E (simple-error (cn "package " (shen.app V2639 " has not been used.
" shen.a))))))

(defun shen.package-contents (V2643) (cond ((and (cons? V2643) (and (= package (hd V2643)) (and (cons? (tl V2643)) (and (= null (hd (tl V2643))) (cons? (tl (tl V2643))))))) (tl (tl (tl V2643)))) ((and (cons? V2643) (and (= package (hd V2643)) (and (cons? (tl V2643)) (cons? (tl (tl V2643)))))) (shen.packageh (hd (tl V2643)) (hd (tl (tl V2643))) (tl (tl (tl V2643))))) (true (shen.f_error shen.package-contents))))

(defun shen.walk (V2646 V2647) (cond ((cons? V2647) (V2646 (map (lambda Z (shen.walk V2646 Z)) V2647))) (true (V2646 V2647))))

(defun compile (V2651 V2652 V2653) (let O (V2651 (cons V2652 (cons () ()))) (if (or (= (fail) O) (not (empty? (hd O)))) (V2653 O) (shen.hdtl O))))

(defun fail-if (V2656 V2657) (if (V2656 V2657) (fail) V2657))

(defun @s (V2660 V2661) (cn V2660 V2661))

(defun tc? () (value shen.*tc*))

(defun ps (V2663) (trap-error (get V2663 shen.source (value *property-vector*)) (lambda E (simple-error (shen.app V2663 " not found.
" shen.a)))))

(defun stinput () (value *stinput*))

(defun shen.+vector? (V2665) (and (absvector? V2665) (> (<-address V2665 0) 0)))

(defun vector (V2667) (let Vector (absvector (+ V2667 1)) (let ZeroStamp (address-> Vector 0 V2667) (let Standard (if (= V2667 0) ZeroStamp (shen.fillvector ZeroStamp 1 V2667 (fail))) Standard))))

(defun shen.fillvector (V2673 V2674 V2675 V2676) (cond ((= V2675 V2674) (address-> V2673 V2675 V2676)) (true (shen.fillvector (address-> V2673 V2674 V2676) (+ 1 V2674) V2675 V2676))))

(defun vector? (V2678) (and (absvector? V2678) (trap-error (>= (<-address V2678 0) 0) (lambda E false))))

(defun vector-> (V2682 V2683 V2684) (if (= V2683 0) (simple-error "cannot access 0th element of a vector
") (address-> V2682 V2683 V2684)))

(defun <-vector (V2687 V2688) (if (= V2688 0) (simple-error "cannot access 0th element of a vector
") (let VectorElement (<-address V2687 V2688) (if (= VectorElement (fail)) (simple-error "vector element not found
") VectorElement))))

(defun shen.posint? (V2690) (and (integer? V2690) (>= V2690 0)))

(defun limit (V2692) (<-address V2692 0))

(defun symbol? (V2694) (cond ((or (boolean? V2694) (or (number? V2694) (string? V2694))) false) (true (trap-error (let String (str V2694) (shen.analyse-symbol? String)) (lambda E false)))))

(defun shen.analyse-symbol? (V2696) (cond ((shen.+string? V2696) (and (shen.alpha? (pos V2696 0)) (shen.alphanums? (tlstr V2696)))) (true (shen.f_error shen.analyse-symbol?))))

(defun shen.alpha? (V2698) (element? V2698 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" (cons "a" (cons "b" (cons "c" (cons "d" (cons "e" (cons "f" (cons "g" (cons "h" (cons "i" (cons "j" (cons "k" (cons "l" (cons "m" (cons "n" (cons "o" (cons "p" (cons "q" (cons "r" (cons "s" (cons "t" (cons "u" (cons "v" (cons "w" (cons "x" (cons "y" (cons "z" (cons "=" (cons "*" (cons "/" (cons "+" (cons "-" (cons "_" (cons "?" (cons "$" (cons "!" (cons "@" (cons "~" (cons ">" (cons "<" (cons "&" (cons "%" (cons "{" (cons "}" (cons ":" (cons ";" (cons "`" (cons "#" (cons "'" (cons "." ())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

(defun shen.alphanums? (V2700) (cond ((= "" V2700) true) ((shen.+string? V2700) (and (shen.alphanum? (pos V2700 0)) (shen.alphanums? (tlstr V2700)))) (true (shen.f_error shen.alphanums?))))

(defun shen.alphanum? (V2702) (or (shen.alpha? V2702) (shen.digit? V2702)))

(defun shen.digit? (V2704) (element? V2704 (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" ()))))))))))))

(defun variable? (V2706) (cond ((or (boolean? V2706) (or (number? V2706) (string? V2706))) false) (true (trap-error (let String (str V2706) (shen.analyse-variable? String)) (lambda E false)))))

(defun shen.analyse-variable? (V2708) (cond ((shen.+string? V2708) (and (shen.uppercase? (pos V2708 0)) (shen.alphanums? (tlstr V2708)))) (true (shen.f_error shen.analyse-variable?))))

(defun shen.uppercase? (V2710) (element? V2710 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" ()))))))))))))))))))))))))))))

(defun gensym (V2712) (concat V2712 (set shen.*gensym* (+ 1 (value shen.*gensym*)))))

(defun concat (V2715 V2716) (intern (cn (str V2715) (str V2716))))

(defun @p (V2719 V2720) (let Vector (absvector 3) (let Tag (address-> Vector 0 shen.tuple) (let Fst (address-> Vector 1 V2719) (let Snd (address-> Vector 2 V2720) Vector)))))

(defun fst (V2722) (<-address V2722 1))

(defun snd (V2724) (<-address V2724 2))

(defun tuple? (V2726) (trap-error (and (absvector? V2726) (= shen.tuple (<-address V2726 0))) (lambda E false)))

(defun append (V2729 V2730) (cond ((= () V2729) V2730) ((cons? V2729) (cons (hd V2729) (append (tl V2729) V2730))) (true (shen.f_error append))))

(defun @v (V2733 V2734) (let Limit (limit V2734) (let NewVector (vector (+ Limit 1)) (let X+NewVector (vector-> NewVector 1 V2733) (if (= Limit 0) X+NewVector (shen.@v-help V2734 1 Limit X+NewVector))))))

(defun shen.@v-help (V2740 V2741 V2742 V2743) (cond ((= V2742 V2741) (shen.copyfromvector V2740 V2743 V2742 (+ V2742 1))) (true (shen.@v-help V2740 (+ V2741 1) V2742 (shen.copyfromvector V2740 V2743 V2741 (+ V2741 1))))))

(defun shen.copyfromvector (V2748 V2749 V2750 V2751) (trap-error (vector-> V2749 V2751 (<-vector V2748 V2750)) (lambda E V2749)))

(defun hdv (V2753) (trap-error (<-vector V2753 1) (lambda E (simple-error (cn "hdv needs a non-empty vector as an argument; not " (shen.app V2753 "
" shen.s))))))

(defun tlv (V2755) (let Limit (limit V2755) (if (= Limit 0) (simple-error "cannot take the tail of the empty vector
") (if (= Limit 1) (vector 0) (let NewVector (vector (- Limit 1)) (shen.tlv-help V2755 2 Limit (vector (- Limit 1))))))))

(defun shen.tlv-help (V2761 V2762 V2763 V2764) (cond ((= V2763 V2762) (shen.copyfromvector V2761 V2764 V2763 (- V2763 1))) (true (shen.tlv-help V2761 (+ V2762 1) V2763 (shen.copyfromvector V2761 V2764 V2762 (- V2762 1))))))

(defun assoc (V2776 V2777) (cond ((= () V2777) ()) ((and (cons? V2777) (and (cons? (hd V2777)) (= (hd (hd V2777)) V2776))) (hd V2777)) ((cons? V2777) (assoc V2776 (tl V2777))) (true (shen.f_error assoc))))

(defun boolean? (V2783) (cond ((= true V2783) true) ((= false V2783) true) (true false)))

(defun nl (V2785) (cond ((= 0 V2785) 0) (true (do (shen.prhush "
" (stoutput)) (nl (- V2785 1))))))

(defun difference (V2790 V2791) (cond ((= () V2790) ()) ((cons? V2790) (if (element? (hd V2790) V2791) (difference (tl V2790) V2791) (cons (hd V2790) (difference (tl V2790) V2791)))) (true (shen.f_error difference))))

(defun do (V2794 V2795) V2795)

(defun element? (V2807 V2808) (cond ((= () V2808) false) ((and (cons? V2808) (= (hd V2808) V2807)) true) ((cons? V2808) (element? V2807 (tl V2808))) (true (shen.f_error element?))))

(defun empty? (V2814) (cond ((= () V2814) true) (true false)))

(defun fix (V2817 V2818) (shen.fix-help V2817 V2818 (V2817 V2818)))

(defun shen.fix-help (V2829 V2830 V2831) (cond ((= V2831 V2830) V2831) (true (shen.fix-help V2829 V2831 (V2829 V2831)))))

(defun put (V2836 V2837 V2838 V2839) (let N (hash V2836 (limit V2839)) (let Entry (trap-error (<-vector V2839 N) (lambda E ())) (let Change (vector-> V2839 N (shen.change-pointer-value V2836 V2837 V2838 Entry)) V2838))))

(defun unput (V2843 V2844 V2845) (let N (hash V2843 (limit V2845)) (let Entry (trap-error (<-vector V2845 N) (lambda E ())) (let Change (vector-> V2845 N (shen.remove-pointer V2843 V2844 Entry)) V2843))))

(defun shen.remove-pointer (V2853 V2854 V2855) (cond ((= () V2855) ()) ((and (cons? V2855) (and (cons? (hd V2855)) (and (cons? (hd (hd V2855))) (and (cons? (tl (hd (hd V2855)))) (and (= () (tl (tl (hd (hd V2855))))) (and (= (hd (tl (hd (hd V2855)))) V2854) (= (hd (hd (hd V2855))) V2853))))))) (tl V2855)) ((cons? V2855) (cons (hd V2855) (shen.remove-pointer V2853 V2854 (tl V2855)))) (true (shen.f_error shen.remove-pointer))))

(defun shen.change-pointer-value (V2864 V2865 V2866 V2867) (cond ((= () V2867) (cons (cons (cons V2864 (cons V2865 ())) V2866) ())) ((and (cons? V2867) (and (cons? (hd V2867)) (and (cons? (hd (hd V2867))) (and (cons? (tl (hd (hd V2867)))) (and (= () (tl (tl (hd (hd V2867))))) (and (= (hd (tl (hd (hd V2867)))) V2865) (= (hd (hd (hd V2867))) V2864))))))) (cons (cons (hd (hd V2867)) V2866) (tl V2867))) ((cons? V2867) (cons (hd V2867) (shen.change-pointer-value V2864 V2865 V2866 (tl V2867)))) (true (shen.f_error shen.change-pointer-value))))

(defun get (V2871 V2872 V2873) (let N (hash V2871 (limit V2873)) (let Entry (trap-error (<-vector V2873 N) (lambda E (simple-error "pointer not found
"))) (let Result (assoc (cons V2871 (cons V2872 ())) Entry) (if (empty? Result) (simple-error "value not found
") (tl Result))))))

(defun hash (V2876 V2877) (let Hash (shen.mod (sum (map (lambda X (string->n X)) (explode V2876))) V2877) (if (= 0 Hash) 1 Hash)))

(defun shen.mod (V2880 V2881) (shen.modh V2880 (shen.multiples V2880 (cons V2881 ()))))

(defun shen.multiples (V2884 V2885) (cond ((and (cons? V2885) (> (hd V2885) V2884)) (tl V2885)) ((cons? V2885) (shen.multiples V2884 (cons (* 2 (hd V2885)) V2885))) (true (shen.f_error shen.multiples))))

(defun shen.modh (V2890 V2891) (cond ((= 0 V2890) 0) ((= () V2891) V2890) ((and (cons? V2891) (> (hd V2891) V2890)) (if (empty? (tl V2891)) V2890 (shen.modh V2890 (tl V2891)))) ((cons? V2891) (shen.modh (- V2890 (hd V2891)) V2891)) (true (shen.f_error shen.modh))))

(defun sum (V2893) (cond ((= () V2893) 0) ((cons? V2893) (+ (hd V2893) (sum (tl V2893)))) (true (shen.f_error sum))))

(defun head (V2901) (cond ((cons? V2901) (hd V2901)) (true (simple-error "head expects a non-empty list"))))

(defun tail (V2909) (cond ((cons? V2909) (tl V2909)) (true (simple-error "tail expects a non-empty list"))))

(defun hdstr (V2911) (pos V2911 0))

(defun intersection (V2916 V2917) (cond ((= () V2916) ()) ((cons? V2916) (if (element? (hd V2916) V2917) (cons (hd V2916) (intersection (tl V2916) V2917)) (intersection (tl V2916) V2917))) (true (shen.f_error intersection))))

(defun reverse (V2919) (shen.reverse_help V2919 ()))

(defun shen.reverse_help (V2922 V2923) (cond ((= () V2922) V2923) ((cons? V2922) (shen.reverse_help (tl V2922) (cons (hd V2922) V2923))) (true (shen.f_error shen.reverse_help))))

(defun union (V2926 V2927) (cond ((= () V2926) V2927) ((cons? V2926) (if (element? (hd V2926) V2927) (union (tl V2926) V2927) (cons (hd V2926) (union (tl V2926) V2927)))) (true (shen.f_error union))))

(defun y-or-n? (V2929) (let Message (shen.prhush (shen.proc-nl V2929) (stoutput)) (let Y-or-N (shen.prhush " (y/n) " (stoutput)) (let Input (shen.app (read (stinput)) "" shen.s) (if (= "y" Input) true (if (= "n" Input) false (do (shen.prhush "please answer y or n
" (stoutput)) (y-or-n? V2929))))))))

(defun not (V2931) (if V2931 false true))

(defun subst (V2944 V2945 V2946) (cond ((= V2946 V2945) V2944) ((cons? V2946) (map (lambda W (subst V2944 V2945 W)) V2946)) (true V2946)))

(defun explode (V2948) (shen.explode-h (shen.app V2948 "" shen.a)))

(defun shen.explode-h (V2950) (cond ((= "" V2950) ()) ((shen.+string? V2950) (cons (pos V2950 0) (shen.explode-h (tlstr V2950)))) (true (shen.f_error shen.explode-h))))

(defun cd (V2952) (set *home-directory* (if (= V2952 "") "" (shen.app V2952 "/" shen.a))))

(defun map (V2955 V2956) (shen.map-h V2955 V2956 ()))

(defun shen.map-h (V2962 V2963 V2964) (cond ((= () V2963) (reverse V2964)) ((cons? V2963) (shen.map-h V2962 (tl V2963) (cons (V2962 (hd V2963)) V2964))) (true (shen.f_error shen.map-h))))

(defun length (V2966) (shen.length-h V2966 0))

(defun shen.length-h (V2969 V2970) (cond ((= () V2969) V2970) (true (shen.length-h (tl V2969) (+ V2970 1)))))

(defun occurrences (V2982 V2983) (cond ((= V2983 V2982) 1) ((cons? V2983) (+ (occurrences V2982 (hd V2983)) (occurrences V2982 (tl V2983)))) (true 0)))

(defun nth (V2992 V2993) (cond ((and (= 1 V2992) (cons? V2993)) (hd V2993)) ((cons? V2993) (nth (- V2992 1) (tl V2993))) (true (shen.f_error nth))))

(defun integer? (V2995) (and (number? V2995) (let Abs (shen.abs V2995) (shen.integer-test? Abs (shen.magless Abs 1)))))

(defun shen.abs (V2997) (if (> V2997 0) V2997 (- 0 V2997)))

(defun shen.magless (V3000 V3001) (let Nx2 (* V3001 2) (if (> Nx2 V3000) V3001 (shen.magless V3000 Nx2))))

(defun shen.integer-test? (V3007 V3008) (cond ((= 0 V3007) true) ((> 1 V3007) false) (true (let Abs-N (- V3007 V3008) (if (> 0 Abs-N) (integer? V3007) (shen.integer-test? Abs-N V3008))))))

(defun mapcan (V3013 V3014) (cond ((= () V3014) ()) ((cons? V3014) (append (V3013 (hd V3014)) (mapcan V3013 (tl V3014)))) (true (shen.f_error mapcan))))

(defun == (V3026 V3027) (cond ((= V3027 V3026) true) (true false)))

(defun abort () (simple-error ""))

(defun bound? (V3029) (and (symbol? V3029) (let Val (trap-error (value V3029) (lambda E shen.this-symbol-is-unbound)) (if (= Val shen.this-symbol-is-unbound) false true))))

(defun shen.string->bytes (V3031) (cond ((= "" V3031) ()) (true (cons (string->n (pos V3031 0)) (shen.string->bytes (tlstr V3031))))))

(defun maxinferences (V3033) (set shen.*maxinferences* V3033))

(defun inferences () (value shen.*infs*))

(defun protect (V3035) V3035)

(defun stoutput () (value *stoutput*))

(defun string->symbol (V3037) (let Symbol (intern V3037) (if (symbol? Symbol) Symbol (simple-error (cn "cannot intern " (shen.app V3037 " to a symbol" shen.s))))))

(defun optimise (V3043) (cond ((= + V3043) (set shen.*optimise* true)) ((= - V3043) (set shen.*optimise* false)) (true (simple-error "optimise expects a + or a -.
"))))

(defun os () (value *os*))

(defun language () (value *language*))

(defun version () (value *version*))

(defun port () (value *port*))

(defun porters () (value *porters*))

(defun implementation () (value *implementation*))

(defun release () (value *release*))

(defun package? (V3045) (trap-error (do (external V3045) true) (lambda E false)))

(defun function (V3047) (shen.lookup-func V3047 (value shen.*symbol-table*)))

(defun shen.lookup-func (V3057 V3058) (cond ((= () V3058) (simple-error (shen.app V3057 " has no lambda expansion
" shen.a))) ((and (cons? V3058) (and (cons? (hd V3058)) (= (hd (hd V3058)) V3057))) (tl (hd V3058))) ((cons? V3058) (shen.lookup-func V3057 (tl V3058))) (true (shen.f_error shen.lookup-func))))



