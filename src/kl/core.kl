"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.shen->kl (V1187 V1188) (compile (lambda X (shen.<define> X)) (cons V1187 V1188) (lambda X (shen.shen-syntax-error V1187 X))))

(defun shen.shen-syntax-error (V1195 V1196) (cond ((cons? V1196) (simple-error (cn "syntax error in " (shen.app V1195 (cn " here:

 " (shen.app (shen.next-50 50 (hd V1196)) "
" shen.a)) shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V1195 "
" shen.a))))))

(defun shen.<define> (V1198) (let YaccParse (let Parse_shen.<name> (shen.<name> V1198) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<signature> (shen.<signature> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<name> (shen.<name> V1198) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) YaccParse)))

(defun shen.<name> (V1200) (if (cons? (hd V1200)) (let Parse_X (hd (hd V1200)) (shen.pair (hd (shen.pair (tl (hd V1200)) (shen.hdtl V1200))) (if (and (symbol? Parse_X) (not (shen.sysfunc? Parse_X))) Parse_X (simple-error (shen.app Parse_X " is not a legitimate function name.
" shen.a))))) (fail)))

(defun shen.sysfunc? (V1202) (element? V1202 (get (intern "shen") shen.external-symbols (value *property-vector*))))

(defun shen.<signature> (V1204) (if (and (cons? (hd V1204)) (= { (hd (hd V1204)))) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V1204)) (shen.hdtl V1204))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (and (cons? (hd Parse_shen.<signature-help>)) (= } (hd (hd Parse_shen.<signature-help>)))) (shen.pair (hd (shen.pair (tl (hd Parse_shen.<signature-help>)) (shen.hdtl Parse_shen.<signature-help>))) (shen.demodulate (shen.curry-type (shen.hdtl Parse_shen.<signature-help>)))) (fail)) (fail))) (fail)))

(defun shen.curry-type (V1206) (cond ((and (cons? V1206) (and (cons? (tl V1206)) (and (= --> (hd (tl V1206))) (and (cons? (tl (tl V1206))) (and (cons? (tl (tl (tl V1206)))) (= --> (hd (tl (tl (tl V1206)))))))))) (shen.curry-type (cons (hd V1206) (cons --> (cons (tl (tl V1206)) ()))))) ((and (cons? V1206) (and (cons? (tl V1206)) (and (= * (hd (tl V1206))) (and (cons? (tl (tl V1206))) (and (cons? (tl (tl (tl V1206)))) (= * (hd (tl (tl (tl V1206)))))))))) (shen.curry-type (cons (hd V1206) (cons * (cons (tl (tl V1206)) ()))))) ((cons? V1206) (map (lambda Z (shen.curry-type Z)) V1206)) (true V1206)))

(defun shen.<signature-help> (V1208) (let YaccParse (if (cons? (hd V1208)) (let Parse_X (hd (hd V1208)) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V1208)) (shen.hdtl V1208))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (not (element? Parse_X (cons { (cons } ())))) (shen.pair (hd Parse_shen.<signature-help>) (cons Parse_X (shen.hdtl Parse_shen.<signature-help>))) (fail)) (fail)))) (fail)) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1208) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<rules> (V1210) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V1210) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V1210) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) ())) (fail))) YaccParse)))

(defun shen.<rule> (V1212) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1212) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<action>) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1212) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<action>) ()))) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1212) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<patterns> (shen.<patterns> V1212) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) (fail))) (fail)) (fail))) YaccParse)) YaccParse)) YaccParse)))

(defun shen.fail_if (V1215 V1216) (if (V1215 V1216) (fail) V1216))

(defun shen.succeeds? (V1222) (cond ((= V1222 (fail)) false) (true true)))

(defun shen.<patterns> (V1224) (let YaccParse (let Parse_shen.<pattern> (shen.<pattern> V1224) (if (not (= (fail) Parse_shen.<pattern>)) (let Parse_shen.<patterns> (shen.<patterns> Parse_shen.<pattern>) (if (not (= (fail) Parse_shen.<patterns>)) (shen.pair (hd Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<pattern>) (shen.hdtl Parse_shen.<patterns>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1224) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<pattern> (V1231) (let YaccParse (if (and (cons? (hd V1231)) (cons? (hd (hd V1231)))) (if (and (cons? (hd (shen.pair (hd (hd V1231)) (hd (tl V1231))))) (= @p (hd (hd (shen.pair (hd (hd V1231)) (hd (tl V1231))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1231)) (hd (tl V1231))))) (shen.hdtl (shen.pair (hd (hd V1231)) (hd (tl V1231)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1231)) (hd (tl V1231)))) (cons @p (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1231)) (cons? (hd (hd V1231)))) (if (and (cons? (hd (shen.pair (hd (hd V1231)) (hd (tl V1231))))) (= cons (hd (hd (shen.pair (hd (hd V1231)) (hd (tl V1231))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1231)) (hd (tl V1231))))) (shen.hdtl (shen.pair (hd (hd V1231)) (hd (tl V1231)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1231)) (hd (tl V1231)))) (cons cons (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1231)) (cons? (hd (hd V1231)))) (if (and (cons? (hd (shen.pair (hd (hd V1231)) (hd (tl V1231))))) (= @v (hd (hd (shen.pair (hd (hd V1231)) (hd (tl V1231))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1231)) (hd (tl V1231))))) (shen.hdtl (shen.pair (hd (hd V1231)) (hd (tl V1231)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1231)) (hd (tl V1231)))) (cons @v (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1231)) (cons? (hd (hd V1231)))) (if (and (cons? (hd (shen.pair (hd (hd V1231)) (hd (tl V1231))))) (= @s (hd (hd (shen.pair (hd (hd V1231)) (hd (tl V1231))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1231)) (hd (tl V1231))))) (shen.hdtl (shen.pair (hd (hd V1231)) (hd (tl V1231)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1231)) (hd (tl V1231)))) (cons @s (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1231)) (cons? (hd (hd V1231)))) (if (and (cons? (hd (shen.pair (hd (hd V1231)) (hd (tl V1231))))) (= vector (hd (hd (shen.pair (hd (hd V1231)) (hd (tl V1231))))))) (if (and (cons? (hd (shen.pair (tl (hd (shen.pair (hd (hd V1231)) (hd (tl V1231))))) (shen.hdtl (shen.pair (hd (hd V1231)) (hd (tl V1231))))))) (= 0 (hd (hd (shen.pair (tl (hd (shen.pair (hd (hd V1231)) (hd (tl V1231))))) (shen.hdtl (shen.pair (hd (hd V1231)) (hd (tl V1231))))))))) (shen.pair (hd (shen.pair (tl (hd V1231)) (hd (tl V1231)))) (cons vector (cons 0 ()))) (fail)) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (cons? (hd V1231)) (let Parse_X (hd (hd V1231)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V1231)) (shen.hdtl V1231))) (shen.constructor-error Parse_X)) (fail))) (fail)) (if (= YaccParse (fail)) (let Parse_shen.<simple_pattern> (shen.<simple_pattern> V1231) (if (not (= (fail) Parse_shen.<simple_pattern>)) (shen.pair (hd Parse_shen.<simple_pattern>) (shen.hdtl Parse_shen.<simple_pattern>)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.constructor-error (V1233) (simple-error (shen.app V1233 " is not a legitimate constructor
" shen.a)))

(defun shen.<simple_pattern> (V1235) (let YaccParse (if (cons? (hd V1235)) (let Parse_X (hd (hd V1235)) (if (= Parse_X _) (shen.pair (hd (shen.pair (tl (hd V1235)) (shen.hdtl V1235))) (gensym Parse_Y)) (fail))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V1235)) (let Parse_X (hd (hd V1235)) (if (not (element? Parse_X (cons -> (cons <- ())))) (shen.pair (hd (shen.pair (tl (hd V1235)) (shen.hdtl V1235))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<pattern1> (V1237) (let Parse_shen.<pattern> (shen.<pattern> V1237) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<pattern2> (V1239) (let Parse_shen.<pattern> (shen.<pattern> V1239) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<action> (V1241) (if (cons? (hd V1241)) (let Parse_X (hd (hd V1241)) (shen.pair (hd (shen.pair (tl (hd V1241)) (shen.hdtl V1241))) Parse_X)) (fail)))

(defun shen.<guard> (V1243) (if (cons? (hd V1243)) (let Parse_X (hd (hd V1243)) (shen.pair (hd (shen.pair (tl (hd V1243)) (shen.hdtl V1243))) Parse_X)) (fail)))

(defun shen.compile_to_machine_code (V1246 V1247) (let Lambda+ (shen.compile_to_lambda+ V1246 V1247) (let KL (shen.compile_to_kl V1246 Lambda+) (let Record (shen.record-source V1246 KL) KL))))

(defun shen.record-source (V1252 V1253) (cond ((value shen.*installing-kl*) shen.skip) (true (put V1252 shen.source V1253 (value *property-vector*)))))

(defun shen.compile_to_lambda+ (V1256 V1257) (let Arity (shen.aritycheck V1256 V1257) (let UpDateSymbolTable (shen.update-symbol-table V1256 Arity) (let Free (for-each (lambda Rule (shen.free_variable_check V1256 Rule)) V1257) (let Variables (shen.parameters Arity) (let Strip (map (lambda X (shen.strip-protect X)) V1257) (let Abstractions (map (lambda X (shen.abstract_rule X)) Strip) (let Applications (map (lambda X (shen.application_build Variables X)) Abstractions) (cons Variables (cons Applications ()))))))))))

(defun shen.update-symbol-table (V1260 V1261) (cond ((= 0 V1261) shen.skip) (true (put V1260 shen.lambda-form (eval-kl (shen.lambda-form V1260 V1261)) (value *property-vector*)))))

(defun shen.free_variable_check (V1264 V1265) (cond ((and (cons? V1265) (and (cons? (tl V1265)) (= () (tl (tl V1265))))) (let Bound (shen.extract_vars (hd V1265)) (let Free (shen.extract_free_vars Bound (hd (tl V1265))) (shen.free_variable_warnings V1264 Free)))) (true (shen.f_error shen.free_variable_check))))

(defun shen.extract_vars (V1267) (cond ((variable? V1267) (cons V1267 ())) ((cons? V1267) (union (shen.extract_vars (hd V1267)) (shen.extract_vars (tl V1267)))) (true ())))

(defun shen.extract_free_vars (V1279 V1280) (cond ((and (cons? V1280) (and (cons? (tl V1280)) (and (= () (tl (tl V1280))) (= (hd V1280) protect)))) ()) ((and (variable? V1280) (not (element? V1280 V1279))) (cons V1280 ())) ((and (cons? V1280) (and (= lambda (hd V1280)) (and (cons? (tl V1280)) (and (cons? (tl (tl V1280))) (= () (tl (tl (tl V1280)))))))) (shen.extract_free_vars (cons (hd (tl V1280)) V1279) (hd (tl (tl V1280))))) ((and (cons? V1280) (and (= let (hd V1280)) (and (cons? (tl V1280)) (and (cons? (tl (tl V1280))) (and (cons? (tl (tl (tl V1280)))) (= () (tl (tl (tl (tl V1280)))))))))) (union (shen.extract_free_vars V1279 (hd (tl (tl V1280)))) (shen.extract_free_vars (cons (hd (tl V1280)) V1279) (hd (tl (tl (tl V1280))))))) ((cons? V1280) (union (shen.extract_free_vars V1279 (hd V1280)) (shen.extract_free_vars V1279 (tl V1280)))) (true ())))

(defun shen.free_variable_warnings (V1285 V1286) (cond ((= () V1286) _) (true (simple-error (cn "error: the following variables are free in " (shen.app V1285 (cn ": " (shen.app (shen.list_variables V1286) "" shen.a)) shen.a))))))

(defun shen.list_variables (V1288) (cond ((and (cons? V1288) (= () (tl V1288))) (cn (str (hd V1288)) ".")) ((cons? V1288) (cn (str (hd V1288)) (cn ", " (shen.list_variables (tl V1288))))) (true (shen.f_error shen.list_variables))))

(defun shen.strip-protect (V1290) (cond ((and (cons? V1290) (and (cons? (tl V1290)) (and (= () (tl (tl V1290))) (= (hd V1290) protect)))) (shen.strip-protect (hd (tl V1290)))) ((cons? V1290) (map (lambda Z (shen.strip-protect Z)) V1290)) (true V1290)))

(defun shen.linearise (V1292) (cond ((and (cons? V1292) (and (cons? (tl V1292)) (= () (tl (tl V1292))))) (shen.linearise_help (shen.flatten (hd V1292)) (hd V1292) (hd (tl V1292)))) (true (shen.f_error shen.linearise))))

(defun shen.flatten (V1294) (cond ((= () V1294) ()) ((cons? V1294) (append (shen.flatten (hd V1294)) (shen.flatten (tl V1294)))) (true (cons V1294 ()))))

(defun shen.linearise_help (V1298 V1299 V1300) (cond ((= () V1298) (cons V1299 (cons V1300 ()))) ((cons? V1298) (if (and (variable? (hd V1298)) (element? (hd V1298) (tl V1298))) (let Var (gensym (hd V1298)) (let NewAction (cons where (cons (cons = (cons (hd V1298) (cons Var ()))) (cons V1300 ()))) (let NewPatts (shen.linearise_X (hd V1298) Var V1299) (shen.linearise_help (tl V1298) NewPatts NewAction)))) (shen.linearise_help (tl V1298) V1299 V1300))) (true (shen.f_error shen.linearise_help))))

(defun shen.linearise_X (V1313 V1314 V1315) (cond ((= V1315 V1313) V1314) ((cons? V1315) (let L (shen.linearise_X V1313 V1314 (hd V1315)) (if (= L (hd V1315)) (cons (hd V1315) (shen.linearise_X V1313 V1314 (tl V1315))) (cons L (tl V1315))))) (true V1315)))

(defun shen.aritycheck (V1318 V1319) (cond ((and (cons? V1319) (and (cons? (hd V1319)) (and (cons? (tl (hd V1319))) (and (= () (tl (tl (hd V1319)))) (= () (tl V1319)))))) (do (shen.aritycheck-action (hd (tl (hd V1319)))) (shen.aritycheck-name V1318 (arity V1318) (length (hd (hd V1319)))))) ((and (cons? V1319) (and (cons? (hd V1319)) (and (cons? (tl (hd V1319))) (and (= () (tl (tl (hd V1319)))) (and (cons? (tl V1319)) (and (cons? (hd (tl V1319))) (and (cons? (tl (hd (tl V1319)))) (= () (tl (tl (hd (tl V1319)))))))))))) (if (= (length (hd (hd V1319))) (length (hd (hd (tl V1319))))) (do (shen.aritycheck-action (hd (tl (hd V1319)))) (shen.aritycheck V1318 (tl V1319))) (simple-error (cn "arity error in " (shen.app V1318 "
" shen.a))))) (true (shen.f_error shen.aritycheck))))

(defun shen.aritycheck-name (V1332 V1333 V1334) (cond ((= -1 V1333) V1334) ((= V1334 V1333) V1334) (true (do (shen.prhush (cn "
warning: changing the arity of " (shen.app V1332 " can cause errors.
" shen.a)) (stoutput)) V1334))))

(defun shen.aritycheck-action (V1340) (cond ((cons? V1340) (do (shen.aah (hd V1340) (tl V1340)) (for-each (lambda Y (shen.aritycheck-action Y)) V1340))) (true shen.skip)))

(defun shen.aah (V1343 V1344) (let Arity (arity V1343) (let Len (length V1344) (if (and (> Arity -1) (> Len Arity)) (shen.prhush (cn "warning: " (shen.app V1343 (cn " might not like " (shen.app Len (cn " argument" (shen.app (if (> Len 1) "s" "") ".
" shen.a)) shen.a)) shen.a)) (stoutput)) shen.skip))))

(defun shen.abstract_rule (V1346) (cond ((and (cons? V1346) (and (cons? (tl V1346)) (= () (tl (tl V1346))))) (shen.abstraction_build (hd V1346) (hd (tl V1346)))) (true (shen.f_error shen.abstract_rule))))

(defun shen.abstraction_build (V1349 V1350) (cond ((= () V1349) V1350) ((cons? V1349) (cons /. (cons (hd V1349) (cons (shen.abstraction_build (tl V1349) V1350) ())))) (true (shen.f_error shen.abstraction_build))))

(defun shen.parameters (V1352) (cond ((= 0 V1352) ()) (true (cons (gensym V) (shen.parameters (- V1352 1))))))

(defun shen.application_build (V1355 V1356) (cond ((= () V1355) V1356) ((cons? V1355) (shen.application_build (tl V1355) (cons V1356 (cons (hd V1355) ())))) (true (shen.f_error shen.application_build))))

(defun shen.compile_to_kl (V1359 V1360) (cond ((and (cons? V1360) (and (cons? (tl V1360)) (= () (tl (tl V1360))))) (let Arity (shen.store-arity V1359 (length (hd V1360))) (let Reduce (map (lambda X (shen.reduce X)) (hd (tl V1360))) (let CondExpression (shen.cond-expression V1359 (hd V1360) Reduce) (let TypeTable (if (value shen.*optimise*) (shen.typextable (shen.get-type V1359) (hd V1360)) shen.skip) (let TypedCondExpression (if (value shen.*optimise*) (shen.assign-types (hd V1360) TypeTable CondExpression) CondExpression) (cons defun (cons V1359 (cons (hd V1360) (cons TypedCondExpression ())))))))))) (true (shen.f_error shen.compile_to_kl))))

(defun shen.get-type (V1366) (cond ((cons? V1366) shen.skip) (true (let FType (assoc V1366 (value shen.*signedfuncs*)) (if (empty? FType) shen.skip (tl FType))))))

(defun shen.typextable (V1377 V1378) (cond ((and (cons? V1377) (and (cons? (tl V1377)) (and (= --> (hd (tl V1377))) (and (cons? (tl (tl V1377))) (and (= () (tl (tl (tl V1377)))) (cons? V1378)))))) (if (variable? (hd V1377)) (shen.typextable (hd (tl (tl V1377))) (tl V1378)) (cons (cons (hd V1378) (hd V1377)) (shen.typextable (hd (tl (tl V1377))) (tl V1378))))) (true ())))

(defun shen.assign-types (V1382 V1383 V1384) (cond ((and (cons? V1384) (and (= let (hd V1384)) (and (cons? (tl V1384)) (and (cons? (tl (tl V1384))) (and (cons? (tl (tl (tl V1384)))) (= () (tl (tl (tl (tl V1384)))))))))) (cons let (cons (hd (tl V1384)) (cons (shen.assign-types V1382 V1383 (hd (tl (tl V1384)))) (cons (shen.assign-types (cons (hd (tl V1384)) V1382) V1383 (hd (tl (tl (tl V1384))))) ()))))) ((and (cons? V1384) (and (= lambda (hd V1384)) (and (cons? (tl V1384)) (and (cons? (tl (tl V1384))) (= () (tl (tl (tl V1384)))))))) (cons lambda (cons (hd (tl V1384)) (cons (shen.assign-types (cons (hd (tl V1384)) V1382) V1383 (hd (tl (tl V1384)))) ())))) ((and (cons? V1384) (= cond (hd V1384))) (cons cond (map (lambda Y (cons (shen.assign-types V1382 V1383 (hd Y)) (cons (shen.assign-types V1382 V1383 (hd (tl Y))) ()))) (tl V1384)))) ((cons? V1384) (let NewTable (shen.typextable (shen.get-type (hd V1384)) (tl V1384)) (cons (hd V1384) (map (lambda Y (shen.assign-types V1382 (append V1383 NewTable) Y)) (tl V1384))))) (true (let AtomType (assoc V1384 V1383) (if (cons? AtomType) (cons type (cons V1384 (cons (tl AtomType) ()))) (if (element? V1384 V1382) V1384 (shen.atom-type V1384)))))))

(defun shen.atom-type (V1386) (if (string? V1386) (cons type (cons V1386 (cons string ()))) (if (number? V1386) (cons type (cons V1386 (cons number ()))) (if (boolean? V1386) (cons type (cons V1386 (cons boolean ()))) (if (symbol? V1386) (cons type (cons V1386 (cons symbol ()))) V1386)))))

(defun shen.store-arity (V1391 V1392) (cond ((value shen.*installing-kl*) shen.skip) (true (put V1391 arity V1392 (value *property-vector*)))))

(defun shen.reduce (V1394) (do (set shen.*teststack* ()) (let Result (shen.reduce_help V1394) (cons (cons : (cons shen.tests (reverse (value shen.*teststack*)))) (cons Result ())))))

(defun shen.reduce_help (V1396) (cond ((and (cons? V1396) (and (cons? (hd V1396)) (and (= /. (hd (hd V1396))) (and (cons? (tl (hd V1396))) (and (cons? (hd (tl (hd V1396)))) (and (= cons (hd (hd (tl (hd V1396))))) (and (cons? (tl (hd (tl (hd V1396))))) (and (cons? (tl (tl (hd (tl (hd V1396)))))) (and (= () (tl (tl (tl (hd (tl (hd V1396))))))) (and (cons? (tl (tl (hd V1396)))) (and (= () (tl (tl (tl (hd V1396))))) (and (cons? (tl V1396)) (= () (tl (tl V1396))))))))))))))) (do (shen.add_test (cons cons? (tl V1396))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1396))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1396)))))) (cons (shen.ebr (hd (tl V1396)) (hd (tl (hd V1396))) (hd (tl (tl (hd V1396))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hd (tl V1396)) ())) (cons (cons tl (tl V1396)) ())) (shen.reduce_help Application))))) ((and (cons? V1396) (and (cons? (hd V1396)) (and (= /. (hd (hd V1396))) (and (cons? (tl (hd V1396))) (and (cons? (hd (tl (hd V1396)))) (and (= @p (hd (hd (tl (hd V1396))))) (and (cons? (tl (hd (tl (hd V1396))))) (and (cons? (tl (tl (hd (tl (hd V1396)))))) (and (= () (tl (tl (tl (hd (tl (hd V1396))))))) (and (cons? (tl (tl (hd V1396)))) (and (= () (tl (tl (tl (hd V1396))))) (and (cons? (tl V1396)) (= () (tl (tl V1396))))))))))))))) (do (shen.add_test (cons tuple? (tl V1396))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1396))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1396)))))) (cons (shen.ebr (hd (tl V1396)) (hd (tl (hd V1396))) (hd (tl (tl (hd V1396))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons fst (tl V1396)) ())) (cons (cons snd (tl V1396)) ())) (shen.reduce_help Application))))) ((and (cons? V1396) (and (cons? (hd V1396)) (and (= /. (hd (hd V1396))) (and (cons? (tl (hd V1396))) (and (cons? (hd (tl (hd V1396)))) (and (= @v (hd (hd (tl (hd V1396))))) (and (cons? (tl (hd (tl (hd V1396))))) (and (cons? (tl (tl (hd (tl (hd V1396)))))) (and (= () (tl (tl (tl (hd (tl (hd V1396))))))) (and (cons? (tl (tl (hd V1396)))) (and (= () (tl (tl (tl (hd V1396))))) (and (cons? (tl V1396)) (= () (tl (tl V1396))))))))))))))) (do (shen.add_test (cons shen.+vector? (tl V1396))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1396))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1396)))))) (cons (shen.ebr (hd (tl V1396)) (hd (tl (hd V1396))) (hd (tl (tl (hd V1396))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hdv (tl V1396)) ())) (cons (cons tlv (tl V1396)) ())) (shen.reduce_help Application))))) ((and (cons? V1396) (and (cons? (hd V1396)) (and (= /. (hd (hd V1396))) (and (cons? (tl (hd V1396))) (and (cons? (hd (tl (hd V1396)))) (and (= @s (hd (hd (tl (hd V1396))))) (and (cons? (tl (hd (tl (hd V1396))))) (and (cons? (tl (tl (hd (tl (hd V1396)))))) (and (= () (tl (tl (tl (hd (tl (hd V1396))))))) (and (cons? (tl (tl (hd V1396)))) (and (= () (tl (tl (tl (hd V1396))))) (and (cons? (tl V1396)) (= () (tl (tl V1396))))))))))))))) (do (shen.add_test (cons shen.+string? (tl V1396))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1396))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1396)))))) (cons (shen.ebr (hd (tl V1396)) (hd (tl (hd V1396))) (hd (tl (tl (hd V1396))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons pos (cons (hd (tl V1396)) (cons 0 ()))) ())) (cons (cons tlstr (tl V1396)) ())) (shen.reduce_help Application))))) ((and (cons? V1396) (and (cons? (hd V1396)) (and (= /. (hd (hd V1396))) (and (cons? (tl (hd V1396))) (and (cons? (tl (tl (hd V1396)))) (and (= () (tl (tl (tl (hd V1396))))) (and (cons? (tl V1396)) (and (= () (tl (tl V1396))) (not (variable? (hd (tl (hd V1396))))))))))))) (do (shen.add_test (cons = (cons (hd (tl (hd V1396))) (tl V1396)))) (shen.reduce_help (hd (tl (tl (hd V1396))))))) ((and (cons? V1396) (and (cons? (hd V1396)) (and (= /. (hd (hd V1396))) (and (cons? (tl (hd V1396))) (and (cons? (tl (tl (hd V1396)))) (and (= () (tl (tl (tl (hd V1396))))) (and (cons? (tl V1396)) (= () (tl (tl V1396)))))))))) (shen.reduce_help (shen.ebr (hd (tl V1396)) (hd (tl (hd V1396))) (hd (tl (tl (hd V1396))))))) ((and (cons? V1396) (and (= where (hd V1396)) (and (cons? (tl V1396)) (and (cons? (tl (tl V1396))) (= () (tl (tl (tl V1396)))))))) (do (shen.add_test (hd (tl V1396))) (shen.reduce_help (hd (tl (tl V1396)))))) ((and (cons? V1396) (and (cons? (tl V1396)) (= () (tl (tl V1396))))) (let Z (shen.reduce_help (hd V1396)) (if (= (hd V1396) Z) V1396 (shen.reduce_help (cons Z (tl V1396)))))) (true V1396)))

(defun shen.+string? (V1398) (cond ((= "" V1398) false) (true (string? V1398))))

(defun shen.+vector? (V1400) (and (absvector? V1400) (> (<-address V1400 0) 0)))

(defun shen.ebr (V1414 V1415 V1416) (cond ((= V1416 V1415) V1414) ((and (cons? V1416) (and (= /. (hd V1416)) (and (cons? (tl V1416)) (and (cons? (tl (tl V1416))) (and (= () (tl (tl (tl V1416)))) (> (occurrences V1415 (hd (tl V1416))) 0)))))) V1416) ((and (cons? V1416) (and (= lambda (hd V1416)) (and (cons? (tl V1416)) (and (cons? (tl (tl V1416))) (and (= () (tl (tl (tl V1416)))) (> (occurrences V1415 (hd (tl V1416))) 0)))))) V1416) ((and (cons? V1416) (and (= let (hd V1416)) (and (cons? (tl V1416)) (and (cons? (tl (tl V1416))) (and (cons? (tl (tl (tl V1416)))) (and (= () (tl (tl (tl (tl V1416))))) (= (hd (tl V1416)) V1415))))))) (cons let (cons (hd (tl V1416)) (cons (shen.ebr V1414 (hd (tl V1416)) (hd (tl (tl V1416)))) (tl (tl (tl V1416))))))) ((cons? V1416) (cons (shen.ebr V1414 V1415 (hd V1416)) (shen.ebr V1414 V1415 (tl V1416)))) (true V1416)))

(defun shen.add_test (V1418) (set shen.*teststack* (cons V1418 (value shen.*teststack*))))

(defun shen.cond-expression (V1422 V1423 V1424) (let Err (shen.err-condition V1422) (let Cases (shen.case-form V1424 Err) (let EncodeChoices (shen.encode-choices Cases V1422) (shen.cond-form EncodeChoices)))))

(defun shen.cond-form (V1428) (cond ((and (cons? V1428) (and (cons? (hd V1428)) (and (= true (hd (hd V1428))) (and (cons? (tl (hd V1428))) (= () (tl (tl (hd V1428)))))))) (hd (tl (hd V1428)))) (true (cons cond V1428))))

(defun shen.encode-choices (V1433 V1434) (cond ((= () V1433) ()) ((and (cons? V1433) (and (cons? (hd V1433)) (and (= true (hd (hd V1433))) (and (cons? (tl (hd V1433))) (and (cons? (hd (tl (hd V1433)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1433))))) (and (cons? (tl (hd (tl (hd V1433))))) (and (= () (tl (tl (hd (tl (hd V1433)))))) (and (= () (tl (tl (hd V1433)))) (= () (tl V1433))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1433))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (if (value shen.*installing-kl*) (cons shen.sys-error (cons V1434 ())) (cons shen.f_error (cons V1434 ()))) (cons Result ())))) ())))) ())) ())) ((and (cons? V1433) (and (cons? (hd V1433)) (and (= true (hd (hd V1433))) (and (cons? (tl (hd V1433))) (and (cons? (hd (tl (hd V1433)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1433))))) (and (cons? (tl (hd (tl (hd V1433))))) (and (= () (tl (tl (hd (tl (hd V1433)))))) (= () (tl (tl (hd V1433)))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1433))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (shen.cond-form (shen.encode-choices (tl V1433) V1434)) (cons Result ())))) ())))) ())) ())) ((and (cons? V1433) (and (cons? (hd V1433)) (and (cons? (tl (hd V1433))) (and (cons? (hd (tl (hd V1433)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1433))))) (and (cons? (tl (hd (tl (hd V1433))))) (and (= () (tl (tl (hd (tl (hd V1433)))))) (= () (tl (tl (hd V1433))))))))))) (cons (cons true (cons (cons let (cons Freeze (cons (cons freeze (cons (shen.cond-form (shen.encode-choices (tl V1433) V1434)) ())) (cons (cons if (cons (hd (hd V1433)) (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1433))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (cons thaw (cons Freeze ())) (cons Result ())))) ())))) (cons (cons thaw (cons Freeze ())) ())))) ())))) ())) ())) ((and (cons? V1433) (and (cons? (hd V1433)) (and (cons? (tl (hd V1433))) (= () (tl (tl (hd V1433))))))) (cons (hd V1433) (shen.encode-choices (tl V1433) V1434))) (true (shen.f_error shen.encode-choices))))

(defun shen.case-form (V1441 V1442) (cond ((= () V1441) (cons V1442 ())) ((and (cons? V1441) (and (cons? (hd V1441)) (and (cons? (hd (hd V1441))) (and (= : (hd (hd (hd V1441)))) (and (cons? (tl (hd (hd V1441)))) (and (= shen.tests (hd (tl (hd (hd V1441))))) (and (= () (tl (tl (hd (hd V1441))))) (and (cons? (tl (hd V1441))) (and (cons? (hd (tl (hd V1441)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1441))))) (and (cons? (tl (hd (tl (hd V1441))))) (and (= () (tl (tl (hd (tl (hd V1441)))))) (= () (tl (tl (hd V1441)))))))))))))))) (cons (cons true (tl (hd V1441))) (shen.case-form (tl V1441) V1442))) ((and (cons? V1441) (and (cons? (hd V1441)) (and (cons? (hd (hd V1441))) (and (= : (hd (hd (hd V1441)))) (and (cons? (tl (hd (hd V1441)))) (and (= shen.tests (hd (tl (hd (hd V1441))))) (and (= () (tl (tl (hd (hd V1441))))) (and (cons? (tl (hd V1441))) (= () (tl (tl (hd V1441)))))))))))) (cons (cons true (tl (hd V1441))) ())) ((and (cons? V1441) (and (cons? (hd V1441)) (and (cons? (hd (hd V1441))) (and (= : (hd (hd (hd V1441)))) (and (cons? (tl (hd (hd V1441)))) (and (= shen.tests (hd (tl (hd (hd V1441))))) (and (cons? (tl (hd V1441))) (= () (tl (tl (hd V1441))))))))))) (cons (cons (shen.embed-and (tl (tl (hd (hd V1441))))) (tl (hd V1441))) (shen.case-form (tl V1441) V1442))) (true (shen.f_error shen.case-form))))

(defun shen.embed-and (V1444) (cond ((and (cons? V1444) (= () (tl V1444))) (hd V1444)) ((cons? V1444) (cons and (cons (hd V1444) (cons (shen.embed-and (tl V1444)) ())))) (true (shen.f_error shen.embed-and))))

(defun shen.err-condition (V1446) (cons true (cons (cons shen.f_error (cons V1446 ())) ())))

(defun shen.sys-error (V1448) (simple-error (cn "system function " (shen.app V1448 ": unexpected argument
" shen.a))))



