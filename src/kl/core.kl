"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.shen->kl (V1185 V1186) (compile (lambda X (shen.<define> X)) (cons V1185 V1186) (lambda X (shen.shen-syntax-error V1185 X))))

(defun shen.shen-syntax-error (V1193 V1194) (cond ((cons? V1194) (simple-error (cn "syntax error in " (shen.app V1193 (cn " here:

 " (shen.app (shen.next-50 50 (hd V1194)) "
" shen.a)) shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V1193 "
" shen.a))))))

(defun shen.<define> (V1196) (let YaccParse (let Parse_shen.<name> (shen.<name> V1196) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<signature> (shen.<signature> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<name> (shen.<name> V1196) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) YaccParse)))

(defun shen.<name> (V1198) (if (cons? (hd V1198)) (let Parse_X (hd (hd V1198)) (shen.pair (hd (shen.pair (tl (hd V1198)) (shen.hdtl V1198))) (if (and (symbol? Parse_X) (not (shen.sysfunc? Parse_X))) Parse_X (simple-error (shen.app Parse_X " is not a legitimate function name.
" shen.a))))) (fail)))

(defun shen.sysfunc? (V1200) (element? V1200 (get (intern "shen") shen.external-symbols (value *property-vector*))))

(defun shen.<signature> (V1202) (if (and (cons? (hd V1202)) (= { (hd (hd V1202)))) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V1202)) (shen.hdtl V1202))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (and (cons? (hd Parse_shen.<signature-help>)) (= } (hd (hd Parse_shen.<signature-help>)))) (shen.pair (hd (shen.pair (tl (hd Parse_shen.<signature-help>)) (shen.hdtl Parse_shen.<signature-help>))) (shen.demodulate (shen.curry-type (shen.hdtl Parse_shen.<signature-help>)))) (fail)) (fail))) (fail)))

(defun shen.curry-type (V1204) (cond ((and (cons? V1204) (and (cons? (tl V1204)) (and (= --> (hd (tl V1204))) (and (cons? (tl (tl V1204))) (and (cons? (tl (tl (tl V1204)))) (= --> (hd (tl (tl (tl V1204)))))))))) (shen.curry-type (cons (hd V1204) (cons --> (cons (tl (tl V1204)) ()))))) ((and (cons? V1204) (and (cons? (tl V1204)) (and (= * (hd (tl V1204))) (and (cons? (tl (tl V1204))) (and (cons? (tl (tl (tl V1204)))) (= * (hd (tl (tl (tl V1204)))))))))) (shen.curry-type (cons (hd V1204) (cons * (cons (tl (tl V1204)) ()))))) ((cons? V1204) (map (lambda Z (shen.curry-type Z)) V1204)) (true V1204)))

(defun shen.<signature-help> (V1206) (let YaccParse (if (cons? (hd V1206)) (let Parse_X (hd (hd V1206)) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V1206)) (shen.hdtl V1206))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (not (element? Parse_X (cons { (cons } ())))) (shen.pair (hd Parse_shen.<signature-help>) (cons Parse_X (shen.hdtl Parse_shen.<signature-help>))) (fail)) (fail)))) (fail)) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1206) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<rules> (V1208) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V1208) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V1208) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) ())) (fail))) YaccParse)))

(defun shen.<rule> (V1210) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1210) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<action>) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1210) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<action>) ()))) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1210) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<patterns> (shen.<patterns> V1210) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) (fail))) (fail)) (fail))) YaccParse)) YaccParse)) YaccParse)))

(defun shen.fail_if (V1213 V1214) (if (V1213 V1214) (fail) V1214))

(defun shen.succeeds? (V1220) (cond ((= V1220 (fail)) false) (true true)))

(defun shen.<patterns> (V1222) (let YaccParse (let Parse_shen.<pattern> (shen.<pattern> V1222) (if (not (= (fail) Parse_shen.<pattern>)) (let Parse_shen.<patterns> (shen.<patterns> Parse_shen.<pattern>) (if (not (= (fail) Parse_shen.<patterns>)) (shen.pair (hd Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<pattern>) (shen.hdtl Parse_shen.<patterns>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1222) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<pattern> (V1229) (let YaccParse (if (and (cons? (hd V1229)) (cons? (hd (hd V1229)))) (if (and (cons? (hd (shen.pair (hd (hd V1229)) (hd (tl V1229))))) (= @p (hd (hd (shen.pair (hd (hd V1229)) (hd (tl V1229))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1229)) (hd (tl V1229))))) (shen.hdtl (shen.pair (hd (hd V1229)) (hd (tl V1229)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1229)) (hd (tl V1229)))) (cons @p (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1229)) (cons? (hd (hd V1229)))) (if (and (cons? (hd (shen.pair (hd (hd V1229)) (hd (tl V1229))))) (= cons (hd (hd (shen.pair (hd (hd V1229)) (hd (tl V1229))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1229)) (hd (tl V1229))))) (shen.hdtl (shen.pair (hd (hd V1229)) (hd (tl V1229)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1229)) (hd (tl V1229)))) (cons cons (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1229)) (cons? (hd (hd V1229)))) (if (and (cons? (hd (shen.pair (hd (hd V1229)) (hd (tl V1229))))) (= @v (hd (hd (shen.pair (hd (hd V1229)) (hd (tl V1229))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1229)) (hd (tl V1229))))) (shen.hdtl (shen.pair (hd (hd V1229)) (hd (tl V1229)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1229)) (hd (tl V1229)))) (cons @v (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1229)) (cons? (hd (hd V1229)))) (if (and (cons? (hd (shen.pair (hd (hd V1229)) (hd (tl V1229))))) (= @s (hd (hd (shen.pair (hd (hd V1229)) (hd (tl V1229))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1229)) (hd (tl V1229))))) (shen.hdtl (shen.pair (hd (hd V1229)) (hd (tl V1229)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1229)) (hd (tl V1229)))) (cons @s (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1229)) (cons? (hd (hd V1229)))) (if (and (cons? (hd (shen.pair (hd (hd V1229)) (hd (tl V1229))))) (= vector (hd (hd (shen.pair (hd (hd V1229)) (hd (tl V1229))))))) (if (and (cons? (hd (shen.pair (tl (hd (shen.pair (hd (hd V1229)) (hd (tl V1229))))) (shen.hdtl (shen.pair (hd (hd V1229)) (hd (tl V1229))))))) (= 0 (hd (hd (shen.pair (tl (hd (shen.pair (hd (hd V1229)) (hd (tl V1229))))) (shen.hdtl (shen.pair (hd (hd V1229)) (hd (tl V1229))))))))) (shen.pair (hd (shen.pair (tl (hd V1229)) (hd (tl V1229)))) (cons vector (cons 0 ()))) (fail)) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (cons? (hd V1229)) (let Parse_X (hd (hd V1229)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V1229)) (shen.hdtl V1229))) (shen.constructor-error Parse_X)) (fail))) (fail)) (if (= YaccParse (fail)) (let Parse_shen.<simple_pattern> (shen.<simple_pattern> V1229) (if (not (= (fail) Parse_shen.<simple_pattern>)) (shen.pair (hd Parse_shen.<simple_pattern>) (shen.hdtl Parse_shen.<simple_pattern>)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.constructor-error (V1231) (simple-error (shen.app V1231 " is not a legitimate constructor
" shen.a)))

(defun shen.<simple_pattern> (V1233) (let YaccParse (if (cons? (hd V1233)) (let Parse_X (hd (hd V1233)) (if (= Parse_X _) (shen.pair (hd (shen.pair (tl (hd V1233)) (shen.hdtl V1233))) (gensym Parse_Y)) (fail))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V1233)) (let Parse_X (hd (hd V1233)) (if (not (element? Parse_X (cons -> (cons <- ())))) (shen.pair (hd (shen.pair (tl (hd V1233)) (shen.hdtl V1233))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<pattern1> (V1235) (let Parse_shen.<pattern> (shen.<pattern> V1235) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<pattern2> (V1237) (let Parse_shen.<pattern> (shen.<pattern> V1237) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<action> (V1239) (if (cons? (hd V1239)) (let Parse_X (hd (hd V1239)) (shen.pair (hd (shen.pair (tl (hd V1239)) (shen.hdtl V1239))) Parse_X)) (fail)))

(defun shen.<guard> (V1241) (if (cons? (hd V1241)) (let Parse_X (hd (hd V1241)) (shen.pair (hd (shen.pair (tl (hd V1241)) (shen.hdtl V1241))) Parse_X)) (fail)))

(defun shen.compile_to_machine_code (V1244 V1245) (let Lambda+ (shen.compile_to_lambda+ V1244 V1245) (let KL (shen.compile_to_kl V1244 Lambda+) (let Record (shen.record-source V1244 KL) KL))))

(defun shen.record-source (V1250 V1251) (cond ((value shen.*installing-kl*) shen.skip) (true (put V1250 shen.source V1251 (value *property-vector*)))))

(defun shen.compile_to_lambda+ (V1254 V1255) (let Arity (shen.aritycheck V1254 V1255) (let UpDateSymbolTable (shen.update-symbol-table V1254 Arity) (let Free (map (lambda Rule (shen.free_variable_check V1254 Rule)) V1255) (let Variables (shen.parameters Arity) (let Strip (map (lambda X (shen.strip-protect X)) V1255) (let Abstractions (map (lambda X (shen.abstract_rule X)) Strip) (let Applications (map (lambda X (shen.application_build Variables X)) Abstractions) (cons Variables (cons Applications ()))))))))))

(defun shen.update-symbol-table (V1258 V1259) (set shen.*symbol-table* (shen.update-symbol-table-h V1258 V1259 (value shen.*symbol-table*) ())))

(defun shen.update-symbol-table-h (V1267 V1268 V1269 V1270) (cond ((= () V1269) (let NewEntry (cons V1267 (eval-kl (shen.lambda-form V1267 V1268))) (cons NewEntry V1270))) ((and (cons? V1269) (and (cons? (hd V1269)) (= (hd (hd V1269)) V1267))) (let ChangedEntry (cons (hd (hd V1269)) (eval-kl (shen.lambda-form (hd (hd V1269)) V1268))) (append (tl V1269) (cons ChangedEntry V1270)))) ((cons? V1269) (shen.update-symbol-table-h V1267 V1268 (tl V1269) (cons (hd V1269) V1270))) (true (shen.f_error shen.update-symbol-table-h))))

(defun shen.free_variable_check (V1273 V1274) (cond ((and (cons? V1274) (and (cons? (tl V1274)) (= () (tl (tl V1274))))) (let Bound (shen.extract_vars (hd V1274)) (let Free (shen.extract_free_vars Bound (hd (tl V1274))) (shen.free_variable_warnings V1273 Free)))) (true (shen.f_error shen.free_variable_check))))

(defun shen.extract_vars (V1276) (cond ((variable? V1276) (cons V1276 ())) ((cons? V1276) (union (shen.extract_vars (hd V1276)) (shen.extract_vars (tl V1276)))) (true ())))

(defun shen.extract_free_vars (V1288 V1289) (cond ((and (cons? V1289) (and (cons? (tl V1289)) (and (= () (tl (tl V1289))) (= (hd V1289) protect)))) ()) ((and (variable? V1289) (not (element? V1289 V1288))) (cons V1289 ())) ((and (cons? V1289) (and (= lambda (hd V1289)) (and (cons? (tl V1289)) (and (cons? (tl (tl V1289))) (= () (tl (tl (tl V1289)))))))) (shen.extract_free_vars (cons (hd (tl V1289)) V1288) (hd (tl (tl V1289))))) ((and (cons? V1289) (and (= let (hd V1289)) (and (cons? (tl V1289)) (and (cons? (tl (tl V1289))) (and (cons? (tl (tl (tl V1289)))) (= () (tl (tl (tl (tl V1289)))))))))) (union (shen.extract_free_vars V1288 (hd (tl (tl V1289)))) (shen.extract_free_vars (cons (hd (tl V1289)) V1288) (hd (tl (tl (tl V1289))))))) ((cons? V1289) (union (shen.extract_free_vars V1288 (hd V1289)) (shen.extract_free_vars V1288 (tl V1289)))) (true ())))

(defun shen.free_variable_warnings (V1294 V1295) (cond ((= () V1295) _) (true (simple-error (cn "error: the following variables are free in " (shen.app V1294 (cn ": " (shen.app (shen.list_variables V1295) "" shen.a)) shen.a))))))

(defun shen.list_variables (V1297) (cond ((and (cons? V1297) (= () (tl V1297))) (cn (str (hd V1297)) ".")) ((cons? V1297) (cn (str (hd V1297)) (cn ", " (shen.list_variables (tl V1297))))) (true (shen.f_error shen.list_variables))))

(defun shen.strip-protect (V1299) (cond ((and (cons? V1299) (and (cons? (tl V1299)) (and (= () (tl (tl V1299))) (= (hd V1299) protect)))) (shen.strip-protect (hd (tl V1299)))) ((cons? V1299) (map (lambda Z (shen.strip-protect Z)) V1299)) (true V1299)))

(defun shen.linearise (V1301) (cond ((and (cons? V1301) (and (cons? (tl V1301)) (= () (tl (tl V1301))))) (shen.linearise_help (shen.flatten (hd V1301)) (hd V1301) (hd (tl V1301)))) (true (shen.f_error shen.linearise))))

(defun shen.flatten (V1303) (cond ((= () V1303) ()) ((cons? V1303) (append (shen.flatten (hd V1303)) (shen.flatten (tl V1303)))) (true (cons V1303 ()))))

(defun shen.linearise_help (V1307 V1308 V1309) (cond ((= () V1307) (cons V1308 (cons V1309 ()))) ((cons? V1307) (if (and (variable? (hd V1307)) (element? (hd V1307) (tl V1307))) (let Var (gensym (hd V1307)) (let NewAction (cons where (cons (cons = (cons (hd V1307) (cons Var ()))) (cons V1309 ()))) (let NewPatts (shen.linearise_X (hd V1307) Var V1308) (shen.linearise_help (tl V1307) NewPatts NewAction)))) (shen.linearise_help (tl V1307) V1308 V1309))) (true (shen.f_error shen.linearise_help))))

(defun shen.linearise_X (V1322 V1323 V1324) (cond ((= V1324 V1322) V1323) ((cons? V1324) (let L (shen.linearise_X V1322 V1323 (hd V1324)) (if (= L (hd V1324)) (cons (hd V1324) (shen.linearise_X V1322 V1323 (tl V1324))) (cons L (tl V1324))))) (true V1324)))

(defun shen.aritycheck (V1327 V1328) (cond ((and (cons? V1328) (and (cons? (hd V1328)) (and (cons? (tl (hd V1328))) (and (= () (tl (tl (hd V1328)))) (= () (tl V1328)))))) (do (shen.aritycheck-action (hd (tl (hd V1328)))) (shen.aritycheck-name V1327 (arity V1327) (length (hd (hd V1328)))))) ((and (cons? V1328) (and (cons? (hd V1328)) (and (cons? (tl (hd V1328))) (and (= () (tl (tl (hd V1328)))) (and (cons? (tl V1328)) (and (cons? (hd (tl V1328))) (and (cons? (tl (hd (tl V1328)))) (= () (tl (tl (hd (tl V1328)))))))))))) (if (= (length (hd (hd V1328))) (length (hd (hd (tl V1328))))) (do (shen.aritycheck-action (hd (tl (hd V1328)))) (shen.aritycheck V1327 (tl V1328))) (simple-error (cn "arity error in " (shen.app V1327 "
" shen.a))))) (true (shen.f_error shen.aritycheck))))

(defun shen.aritycheck-name (V1341 V1342 V1343) (cond ((= -1 V1342) V1343) ((= V1343 V1342) V1343) (true (do (shen.prhush (cn "
warning: changing the arity of " (shen.app V1341 " can cause errors.
" shen.a)) (stoutput)) V1343))))

(defun shen.aritycheck-action (V1349) (cond ((cons? V1349) (do (shen.aah (hd V1349) (tl V1349)) (map (lambda Y (shen.aritycheck-action Y)) V1349))) (true shen.skip)))

(defun shen.aah (V1352 V1353) (let Arity (arity V1352) (let Len (length V1353) (if (and (> Arity -1) (> Len Arity)) (shen.prhush (cn "warning: " (shen.app V1352 (cn " might not like " (shen.app Len (cn " argument" (shen.app (if (> Len 1) "s" "") ".
" shen.a)) shen.a)) shen.a)) (stoutput)) shen.skip))))

(defun shen.abstract_rule (V1355) (cond ((and (cons? V1355) (and (cons? (tl V1355)) (= () (tl (tl V1355))))) (shen.abstraction_build (hd V1355) (hd (tl V1355)))) (true (shen.f_error shen.abstract_rule))))

(defun shen.abstraction_build (V1358 V1359) (cond ((= () V1358) V1359) ((cons? V1358) (cons /. (cons (hd V1358) (cons (shen.abstraction_build (tl V1358) V1359) ())))) (true (shen.f_error shen.abstraction_build))))

(defun shen.parameters (V1361) (cond ((= 0 V1361) ()) (true (cons (gensym V) (shen.parameters (- V1361 1))))))

(defun shen.application_build (V1364 V1365) (cond ((= () V1364) V1365) ((cons? V1364) (shen.application_build (tl V1364) (cons V1365 (cons (hd V1364) ())))) (true (shen.f_error shen.application_build))))

(defun shen.compile_to_kl (V1368 V1369) (cond ((and (cons? V1369) (and (cons? (tl V1369)) (= () (tl (tl V1369))))) (let Arity (shen.store-arity V1368 (length (hd V1369))) (let Reduce (map (lambda X (shen.reduce X)) (hd (tl V1369))) (let CondExpression (shen.cond-expression V1368 (hd V1369) Reduce) (let TypeTable (if (value shen.*optimise*) (shen.typextable (shen.get-type V1368) (hd V1369)) shen.skip) (let TypedCondExpression (if (value shen.*optimise*) (shen.assign-types (hd V1369) TypeTable CondExpression) CondExpression) (cons defun (cons V1368 (cons (hd V1369) (cons TypedCondExpression ())))))))))) (true (shen.f_error shen.compile_to_kl))))

(defun shen.get-type (V1375) (cond ((cons? V1375) shen.skip) (true (let FType (assoc V1375 (value shen.*signedfuncs*)) (if (empty? FType) shen.skip (tl FType))))))

(defun shen.typextable (V1386 V1387) (cond ((and (cons? V1386) (and (cons? (tl V1386)) (and (= --> (hd (tl V1386))) (and (cons? (tl (tl V1386))) (and (= () (tl (tl (tl V1386)))) (cons? V1387)))))) (if (variable? (hd V1386)) (shen.typextable (hd (tl (tl V1386))) (tl V1387)) (cons (cons (hd V1387) (hd V1386)) (shen.typextable (hd (tl (tl V1386))) (tl V1387))))) (true ())))

(defun shen.assign-types (V1391 V1392 V1393) (cond ((and (cons? V1393) (and (= let (hd V1393)) (and (cons? (tl V1393)) (and (cons? (tl (tl V1393))) (and (cons? (tl (tl (tl V1393)))) (= () (tl (tl (tl (tl V1393)))))))))) (cons let (cons (hd (tl V1393)) (cons (shen.assign-types V1391 V1392 (hd (tl (tl V1393)))) (cons (shen.assign-types (cons (hd (tl V1393)) V1391) V1392 (hd (tl (tl (tl V1393))))) ()))))) ((and (cons? V1393) (and (= lambda (hd V1393)) (and (cons? (tl V1393)) (and (cons? (tl (tl V1393))) (= () (tl (tl (tl V1393)))))))) (cons lambda (cons (hd (tl V1393)) (cons (shen.assign-types (cons (hd (tl V1393)) V1391) V1392 (hd (tl (tl V1393)))) ())))) ((and (cons? V1393) (= cond (hd V1393))) (cons cond (map (lambda Y (cons (shen.assign-types V1391 V1392 (hd Y)) (cons (shen.assign-types V1391 V1392 (hd (tl Y))) ()))) (tl V1393)))) ((cons? V1393) (let NewTable (shen.typextable (shen.get-type (hd V1393)) (tl V1393)) (cons (hd V1393) (map (lambda Y (shen.assign-types V1391 (append V1392 NewTable) Y)) (tl V1393))))) (true (let AtomType (assoc V1393 V1392) (if (cons? AtomType) (cons type (cons V1393 (cons (tl AtomType) ()))) (if (element? V1393 V1391) V1393 (shen.atom-type V1393)))))))

(defun shen.atom-type (V1395) (if (string? V1395) (cons type (cons V1395 (cons string ()))) (if (number? V1395) (cons type (cons V1395 (cons number ()))) (if (boolean? V1395) (cons type (cons V1395 (cons boolean ()))) (if (symbol? V1395) (cons type (cons V1395 (cons symbol ()))) V1395)))))

(defun shen.store-arity (V1400 V1401) (cond ((value shen.*installing-kl*) shen.skip) (true (put V1400 arity V1401 (value *property-vector*)))))

(defun shen.reduce (V1403) (do (set shen.*teststack* ()) (let Result (shen.reduce_help V1403) (cons (cons : (cons shen.tests (reverse (value shen.*teststack*)))) (cons Result ())))))

(defun shen.reduce_help (V1405) (cond ((and (cons? V1405) (and (cons? (hd V1405)) (and (= /. (hd (hd V1405))) (and (cons? (tl (hd V1405))) (and (cons? (hd (tl (hd V1405)))) (and (= cons (hd (hd (tl (hd V1405))))) (and (cons? (tl (hd (tl (hd V1405))))) (and (cons? (tl (tl (hd (tl (hd V1405)))))) (and (= () (tl (tl (tl (hd (tl (hd V1405))))))) (and (cons? (tl (tl (hd V1405)))) (and (= () (tl (tl (tl (hd V1405))))) (and (cons? (tl V1405)) (= () (tl (tl V1405))))))))))))))) (do (shen.add_test (cons cons? (tl V1405))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1405))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1405)))))) (cons (shen.ebr (hd (tl V1405)) (hd (tl (hd V1405))) (hd (tl (tl (hd V1405))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hd (tl V1405)) ())) (cons (cons tl (tl V1405)) ())) (shen.reduce_help Application))))) ((and (cons? V1405) (and (cons? (hd V1405)) (and (= /. (hd (hd V1405))) (and (cons? (tl (hd V1405))) (and (cons? (hd (tl (hd V1405)))) (and (= @p (hd (hd (tl (hd V1405))))) (and (cons? (tl (hd (tl (hd V1405))))) (and (cons? (tl (tl (hd (tl (hd V1405)))))) (and (= () (tl (tl (tl (hd (tl (hd V1405))))))) (and (cons? (tl (tl (hd V1405)))) (and (= () (tl (tl (tl (hd V1405))))) (and (cons? (tl V1405)) (= () (tl (tl V1405))))))))))))))) (do (shen.add_test (cons tuple? (tl V1405))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1405))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1405)))))) (cons (shen.ebr (hd (tl V1405)) (hd (tl (hd V1405))) (hd (tl (tl (hd V1405))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons fst (tl V1405)) ())) (cons (cons snd (tl V1405)) ())) (shen.reduce_help Application))))) ((and (cons? V1405) (and (cons? (hd V1405)) (and (= /. (hd (hd V1405))) (and (cons? (tl (hd V1405))) (and (cons? (hd (tl (hd V1405)))) (and (= @v (hd (hd (tl (hd V1405))))) (and (cons? (tl (hd (tl (hd V1405))))) (and (cons? (tl (tl (hd (tl (hd V1405)))))) (and (= () (tl (tl (tl (hd (tl (hd V1405))))))) (and (cons? (tl (tl (hd V1405)))) (and (= () (tl (tl (tl (hd V1405))))) (and (cons? (tl V1405)) (= () (tl (tl V1405))))))))))))))) (do (shen.add_test (cons shen.+vector? (tl V1405))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1405))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1405)))))) (cons (shen.ebr (hd (tl V1405)) (hd (tl (hd V1405))) (hd (tl (tl (hd V1405))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hdv (tl V1405)) ())) (cons (cons tlv (tl V1405)) ())) (shen.reduce_help Application))))) ((and (cons? V1405) (and (cons? (hd V1405)) (and (= /. (hd (hd V1405))) (and (cons? (tl (hd V1405))) (and (cons? (hd (tl (hd V1405)))) (and (= @s (hd (hd (tl (hd V1405))))) (and (cons? (tl (hd (tl (hd V1405))))) (and (cons? (tl (tl (hd (tl (hd V1405)))))) (and (= () (tl (tl (tl (hd (tl (hd V1405))))))) (and (cons? (tl (tl (hd V1405)))) (and (= () (tl (tl (tl (hd V1405))))) (and (cons? (tl V1405)) (= () (tl (tl V1405))))))))))))))) (do (shen.add_test (cons shen.+string? (tl V1405))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1405))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1405)))))) (cons (shen.ebr (hd (tl V1405)) (hd (tl (hd V1405))) (hd (tl (tl (hd V1405))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons pos (cons (hd (tl V1405)) (cons 0 ()))) ())) (cons (cons tlstr (tl V1405)) ())) (shen.reduce_help Application))))) ((and (cons? V1405) (and (cons? (hd V1405)) (and (= /. (hd (hd V1405))) (and (cons? (tl (hd V1405))) (and (cons? (tl (tl (hd V1405)))) (and (= () (tl (tl (tl (hd V1405))))) (and (cons? (tl V1405)) (and (= () (tl (tl V1405))) (not (variable? (hd (tl (hd V1405))))))))))))) (do (shen.add_test (cons = (cons (hd (tl (hd V1405))) (tl V1405)))) (shen.reduce_help (hd (tl (tl (hd V1405))))))) ((and (cons? V1405) (and (cons? (hd V1405)) (and (= /. (hd (hd V1405))) (and (cons? (tl (hd V1405))) (and (cons? (tl (tl (hd V1405)))) (and (= () (tl (tl (tl (hd V1405))))) (and (cons? (tl V1405)) (= () (tl (tl V1405)))))))))) (shen.reduce_help (shen.ebr (hd (tl V1405)) (hd (tl (hd V1405))) (hd (tl (tl (hd V1405))))))) ((and (cons? V1405) (and (= where (hd V1405)) (and (cons? (tl V1405)) (and (cons? (tl (tl V1405))) (= () (tl (tl (tl V1405)))))))) (do (shen.add_test (hd (tl V1405))) (shen.reduce_help (hd (tl (tl V1405)))))) ((and (cons? V1405) (and (cons? (tl V1405)) (= () (tl (tl V1405))))) (let Z (shen.reduce_help (hd V1405)) (if (= (hd V1405) Z) V1405 (shen.reduce_help (cons Z (tl V1405)))))) (true V1405)))

(defun shen.+string? (V1407) (cond ((= "" V1407) false) (true (string? V1407))))

(defun shen.+vector (V1409) (cond ((= V1409 (vector 0)) false) (true (vector? V1409))))

(defun shen.ebr (V1423 V1424 V1425) (cond ((= V1425 V1424) V1423) ((and (cons? V1425) (and (= /. (hd V1425)) (and (cons? (tl V1425)) (and (cons? (tl (tl V1425))) (and (= () (tl (tl (tl V1425)))) (> (occurrences V1424 (hd (tl V1425))) 0)))))) V1425) ((and (cons? V1425) (and (= lambda (hd V1425)) (and (cons? (tl V1425)) (and (cons? (tl (tl V1425))) (and (= () (tl (tl (tl V1425)))) (> (occurrences V1424 (hd (tl V1425))) 0)))))) V1425) ((and (cons? V1425) (and (= let (hd V1425)) (and (cons? (tl V1425)) (and (cons? (tl (tl V1425))) (and (cons? (tl (tl (tl V1425)))) (and (= () (tl (tl (tl (tl V1425))))) (= (hd (tl V1425)) V1424))))))) (cons let (cons (hd (tl V1425)) (cons (shen.ebr V1423 (hd (tl V1425)) (hd (tl (tl V1425)))) (tl (tl (tl V1425))))))) ((cons? V1425) (cons (shen.ebr V1423 V1424 (hd V1425)) (shen.ebr V1423 V1424 (tl V1425)))) (true V1425)))

(defun shen.add_test (V1427) (set shen.*teststack* (cons V1427 (value shen.*teststack*))))

(defun shen.cond-expression (V1431 V1432 V1433) (let Err (shen.err-condition V1431) (let Cases (shen.case-form V1433 Err) (let EncodeChoices (shen.encode-choices Cases V1431) (shen.cond-form EncodeChoices)))))

(defun shen.cond-form (V1437) (cond ((and (cons? V1437) (and (cons? (hd V1437)) (and (= true (hd (hd V1437))) (and (cons? (tl (hd V1437))) (= () (tl (tl (hd V1437)))))))) (hd (tl (hd V1437)))) (true (cons cond V1437))))

(defun shen.encode-choices (V1442 V1443) (cond ((= () V1442) ()) ((and (cons? V1442) (and (cons? (hd V1442)) (and (= true (hd (hd V1442))) (and (cons? (tl (hd V1442))) (and (cons? (hd (tl (hd V1442)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1442))))) (and (cons? (tl (hd (tl (hd V1442))))) (and (= () (tl (tl (hd (tl (hd V1442)))))) (and (= () (tl (tl (hd V1442)))) (= () (tl V1442))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1442))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (if (value shen.*installing-kl*) (cons shen.sys-error (cons V1443 ())) (cons shen.f_error (cons V1443 ()))) (cons Result ())))) ())))) ())) ())) ((and (cons? V1442) (and (cons? (hd V1442)) (and (= true (hd (hd V1442))) (and (cons? (tl (hd V1442))) (and (cons? (hd (tl (hd V1442)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1442))))) (and (cons? (tl (hd (tl (hd V1442))))) (and (= () (tl (tl (hd (tl (hd V1442)))))) (= () (tl (tl (hd V1442)))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1442))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (shen.cond-form (shen.encode-choices (tl V1442) V1443)) (cons Result ())))) ())))) ())) ())) ((and (cons? V1442) (and (cons? (hd V1442)) (and (cons? (tl (hd V1442))) (and (cons? (hd (tl (hd V1442)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1442))))) (and (cons? (tl (hd (tl (hd V1442))))) (and (= () (tl (tl (hd (tl (hd V1442)))))) (= () (tl (tl (hd V1442))))))))))) (cons (cons true (cons (cons let (cons Freeze (cons (cons freeze (cons (shen.cond-form (shen.encode-choices (tl V1442) V1443)) ())) (cons (cons if (cons (hd (hd V1442)) (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1442))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (cons thaw (cons Freeze ())) (cons Result ())))) ())))) (cons (cons thaw (cons Freeze ())) ())))) ())))) ())) ())) ((and (cons? V1442) (and (cons? (hd V1442)) (and (cons? (tl (hd V1442))) (= () (tl (tl (hd V1442))))))) (cons (hd V1442) (shen.encode-choices (tl V1442) V1443))) (true (shen.f_error shen.encode-choices))))

(defun shen.case-form (V1450 V1451) (cond ((= () V1450) (cons V1451 ())) ((and (cons? V1450) (and (cons? (hd V1450)) (and (cons? (hd (hd V1450))) (and (= : (hd (hd (hd V1450)))) (and (cons? (tl (hd (hd V1450)))) (and (= shen.tests (hd (tl (hd (hd V1450))))) (and (= () (tl (tl (hd (hd V1450))))) (and (cons? (tl (hd V1450))) (and (cons? (hd (tl (hd V1450)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1450))))) (and (cons? (tl (hd (tl (hd V1450))))) (and (= () (tl (tl (hd (tl (hd V1450)))))) (= () (tl (tl (hd V1450)))))))))))))))) (cons (cons true (tl (hd V1450))) (shen.case-form (tl V1450) V1451))) ((and (cons? V1450) (and (cons? (hd V1450)) (and (cons? (hd (hd V1450))) (and (= : (hd (hd (hd V1450)))) (and (cons? (tl (hd (hd V1450)))) (and (= shen.tests (hd (tl (hd (hd V1450))))) (and (= () (tl (tl (hd (hd V1450))))) (and (cons? (tl (hd V1450))) (= () (tl (tl (hd V1450)))))))))))) (cons (cons true (tl (hd V1450))) ())) ((and (cons? V1450) (and (cons? (hd V1450)) (and (cons? (hd (hd V1450))) (and (= : (hd (hd (hd V1450)))) (and (cons? (tl (hd (hd V1450)))) (and (= shen.tests (hd (tl (hd (hd V1450))))) (and (cons? (tl (hd V1450))) (= () (tl (tl (hd V1450))))))))))) (cons (cons (shen.embed-and (tl (tl (hd (hd V1450))))) (tl (hd V1450))) (shen.case-form (tl V1450) V1451))) (true (shen.f_error shen.case-form))))

(defun shen.embed-and (V1453) (cond ((and (cons? V1453) (= () (tl V1453))) (hd V1453)) ((cons? V1453) (cons and (cons (hd V1453) (cons (shen.embed-and (tl V1453)) ())))) (true (shen.f_error shen.embed-and))))

(defun shen.err-condition (V1455) (cons true (cons (cons shen.f_error (cons V1455 ())) ())))

(defun shen.sys-error (V1457) (simple-error (cn "system function " (shen.app V1457 ": unexpected argument
" shen.a))))



