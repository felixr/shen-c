"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.shen->kl (V1362 V1363) (compile (lambda X (shen.<define> X)) (cons V1362 V1363) (lambda X (shen.shen-syntax-error V1362 X))))

(defun shen.shen-syntax-error (V1370 V1371) (cond ((cons? V1371) (simple-error (cn "syntax error in " (shen.app V1370 (cn " here:

 " (shen.app (shen.next-50 50 (hd V1371)) "
" shen.a)) shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V1370 "
" shen.a))))))

(defun shen.<define> (V1373) (let YaccParse (let Parse_shen.<name> (shen.<name> V1373) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<signature> (shen.<signature> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<name> (shen.<name> V1373) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) YaccParse)))

(defun shen.<name> (V1375) (if (cons? (hd V1375)) (let Parse_X (hd (hd V1375)) (shen.pair (hd (shen.pair (tl (hd V1375)) (shen.hdtl V1375))) (if (and (symbol? Parse_X) (not (shen.sysfunc? Parse_X))) Parse_X (simple-error (shen.app Parse_X " is not a legitimate function name.
" shen.a))))) (fail)))

(defun shen.sysfunc? (V1377) (element? V1377 (get (intern "shen") shen.external-symbols (value *property-vector*))))

(defun shen.<signature> (V1379) (if (and (cons? (hd V1379)) (= { (hd (hd V1379)))) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V1379)) (shen.hdtl V1379))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (and (cons? (hd Parse_shen.<signature-help>)) (= } (hd (hd Parse_shen.<signature-help>)))) (shen.pair (hd (shen.pair (tl (hd Parse_shen.<signature-help>)) (shen.hdtl Parse_shen.<signature-help>))) (shen.demodulate (shen.curry-type (shen.hdtl Parse_shen.<signature-help>)))) (fail)) (fail))) (fail)))

(defun shen.curry-type (V1381) (cond ((and (cons? V1381) (and (cons? (tl V1381)) (and (= --> (hd (tl V1381))) (and (cons? (tl (tl V1381))) (and (cons? (tl (tl (tl V1381)))) (= --> (hd (tl (tl (tl V1381)))))))))) (shen.curry-type (cons (hd V1381) (cons --> (cons (tl (tl V1381)) ()))))) ((and (cons? V1381) (and (cons? (tl V1381)) (and (= * (hd (tl V1381))) (and (cons? (tl (tl V1381))) (and (cons? (tl (tl (tl V1381)))) (= * (hd (tl (tl (tl V1381)))))))))) (shen.curry-type (cons (hd V1381) (cons * (cons (tl (tl V1381)) ()))))) ((cons? V1381) (map (lambda Z (shen.curry-type Z)) V1381)) (true V1381)))

(defun shen.<signature-help> (V1383) (let YaccParse (if (cons? (hd V1383)) (let Parse_X (hd (hd V1383)) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V1383)) (shen.hdtl V1383))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (not (element? Parse_X (cons { (cons } ())))) (shen.pair (hd Parse_shen.<signature-help>) (cons Parse_X (shen.hdtl Parse_shen.<signature-help>))) (fail)) (fail)))) (fail)) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1383) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<rules> (V1385) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V1385) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V1385) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) ())) (fail))) YaccParse)))

(defun shen.<rule> (V1387) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1387) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<action>) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1387) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<action>) ()))) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1387) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<patterns> (shen.<patterns> V1387) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) (fail))) (fail)) (fail))) YaccParse)) YaccParse)) YaccParse)))

(defun shen.fail_if (V1390 V1391) (if (V1390 V1391) (fail) V1391))

(defun shen.succeeds? (V1397) (cond ((= V1397 (fail)) false) (true true)))

(defun shen.<patterns> (V1399) (let YaccParse (let Parse_shen.<pattern> (shen.<pattern> V1399) (if (not (= (fail) Parse_shen.<pattern>)) (let Parse_shen.<patterns> (shen.<patterns> Parse_shen.<pattern>) (if (not (= (fail) Parse_shen.<patterns>)) (shen.pair (hd Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<pattern>) (shen.hdtl Parse_shen.<patterns>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1399) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<pattern> (V1406) (let YaccParse (if (and (cons? (hd V1406)) (cons? (hd (hd V1406)))) (if (and (cons? (hd (shen.pair (hd (hd V1406)) (hd (tl V1406))))) (= @p (hd (hd (shen.pair (hd (hd V1406)) (hd (tl V1406))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1406)) (hd (tl V1406))))) (shen.hdtl (shen.pair (hd (hd V1406)) (hd (tl V1406)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1406)) (hd (tl V1406)))) (cons @p (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1406)) (cons? (hd (hd V1406)))) (if (and (cons? (hd (shen.pair (hd (hd V1406)) (hd (tl V1406))))) (= cons (hd (hd (shen.pair (hd (hd V1406)) (hd (tl V1406))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1406)) (hd (tl V1406))))) (shen.hdtl (shen.pair (hd (hd V1406)) (hd (tl V1406)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1406)) (hd (tl V1406)))) (cons cons (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1406)) (cons? (hd (hd V1406)))) (if (and (cons? (hd (shen.pair (hd (hd V1406)) (hd (tl V1406))))) (= @v (hd (hd (shen.pair (hd (hd V1406)) (hd (tl V1406))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1406)) (hd (tl V1406))))) (shen.hdtl (shen.pair (hd (hd V1406)) (hd (tl V1406)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1406)) (hd (tl V1406)))) (cons @v (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1406)) (cons? (hd (hd V1406)))) (if (and (cons? (hd (shen.pair (hd (hd V1406)) (hd (tl V1406))))) (= @s (hd (hd (shen.pair (hd (hd V1406)) (hd (tl V1406))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1406)) (hd (tl V1406))))) (shen.hdtl (shen.pair (hd (hd V1406)) (hd (tl V1406)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1406)) (hd (tl V1406)))) (cons @s (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1406)) (cons? (hd (hd V1406)))) (if (and (cons? (hd (shen.pair (hd (hd V1406)) (hd (tl V1406))))) (= vector (hd (hd (shen.pair (hd (hd V1406)) (hd (tl V1406))))))) (if (and (cons? (hd (shen.pair (tl (hd (shen.pair (hd (hd V1406)) (hd (tl V1406))))) (shen.hdtl (shen.pair (hd (hd V1406)) (hd (tl V1406))))))) (= 0 (hd (hd (shen.pair (tl (hd (shen.pair (hd (hd V1406)) (hd (tl V1406))))) (shen.hdtl (shen.pair (hd (hd V1406)) (hd (tl V1406))))))))) (shen.pair (hd (shen.pair (tl (hd V1406)) (hd (tl V1406)))) (cons vector (cons 0 ()))) (fail)) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (cons? (hd V1406)) (let Parse_X (hd (hd V1406)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V1406)) (shen.hdtl V1406))) (shen.constructor-error Parse_X)) (fail))) (fail)) (if (= YaccParse (fail)) (let Parse_shen.<simple_pattern> (shen.<simple_pattern> V1406) (if (not (= (fail) Parse_shen.<simple_pattern>)) (shen.pair (hd Parse_shen.<simple_pattern>) (shen.hdtl Parse_shen.<simple_pattern>)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.constructor-error (V1408) (simple-error (shen.app V1408 " is not a legitimate constructor
" shen.a)))

(defun shen.<simple_pattern> (V1410) (let YaccParse (if (cons? (hd V1410)) (let Parse_X (hd (hd V1410)) (if (= Parse_X _) (shen.pair (hd (shen.pair (tl (hd V1410)) (shen.hdtl V1410))) (gensym Parse_Y)) (fail))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V1410)) (let Parse_X (hd (hd V1410)) (if (not (element? Parse_X (cons -> (cons <- ())))) (shen.pair (hd (shen.pair (tl (hd V1410)) (shen.hdtl V1410))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<pattern1> (V1412) (let Parse_shen.<pattern> (shen.<pattern> V1412) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<pattern2> (V1414) (let Parse_shen.<pattern> (shen.<pattern> V1414) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<action> (V1416) (if (cons? (hd V1416)) (let Parse_X (hd (hd V1416)) (shen.pair (hd (shen.pair (tl (hd V1416)) (shen.hdtl V1416))) Parse_X)) (fail)))

(defun shen.<guard> (V1418) (if (cons? (hd V1418)) (let Parse_X (hd (hd V1418)) (shen.pair (hd (shen.pair (tl (hd V1418)) (shen.hdtl V1418))) Parse_X)) (fail)))

(defun shen.compile_to_machine_code (V1421 V1422) (let Lambda+ (shen.compile_to_lambda+ V1421 V1422) (let KL (shen.compile_to_kl V1421 Lambda+) (let Record (shen.record-source V1421 KL) KL))))

(defun shen.record-source (V1427 V1428) (cond ((value shen.*installing-kl*) shen.skip) (true (put V1427 shen.source V1428 (value *property-vector*)))))

(defun shen.compile_to_lambda+ (V1431 V1432) (let Arity (shen.aritycheck V1431 V1432) (let UpDateSymbolTable (shen.update-symbol-table V1431 Arity) (let Free (for-each (lambda Rule (shen.free_variable_check V1431 Rule)) V1432) (let Variables (shen.parameters Arity) (let Strip (map (lambda X (shen.strip-protect X)) V1432) (let Abstractions (map (lambda X (shen.abstract_rule X)) Strip) (let Applications (map (lambda X (shen.application_build Variables X)) Abstractions) (cons Variables (cons Applications ()))))))))))

(defun shen.update-symbol-table (V1435 V1436) (cond ((= 0 V1436) shen.skip) (true (put V1435 shen.lambda-form (eval-kl (shen.lambda-form V1435 V1436)) (value *property-vector*)))))

(defun shen.free_variable_check (V1439 V1440) (cond ((and (cons? V1440) (and (cons? (tl V1440)) (= () (tl (tl V1440))))) (let Bound (shen.extract_vars (hd V1440)) (let Free (shen.extract_free_vars Bound (hd (tl V1440))) (shen.free_variable_warnings V1439 Free)))) (true (shen.f_error shen.free_variable_check))))

(defun shen.extract_vars (V1442) (cond ((variable? V1442) (cons V1442 ())) ((cons? V1442) (union (shen.extract_vars (hd V1442)) (shen.extract_vars (tl V1442)))) (true ())))

(defun shen.extract_free_vars (V1454 V1455) (cond ((and (cons? V1455) (and (cons? (tl V1455)) (and (= () (tl (tl V1455))) (= (hd V1455) protect)))) ()) ((and (variable? V1455) (not (element? V1455 V1454))) (cons V1455 ())) ((and (cons? V1455) (and (= lambda (hd V1455)) (and (cons? (tl V1455)) (and (cons? (tl (tl V1455))) (= () (tl (tl (tl V1455)))))))) (shen.extract_free_vars (cons (hd (tl V1455)) V1454) (hd (tl (tl V1455))))) ((and (cons? V1455) (and (= let (hd V1455)) (and (cons? (tl V1455)) (and (cons? (tl (tl V1455))) (and (cons? (tl (tl (tl V1455)))) (= () (tl (tl (tl (tl V1455)))))))))) (union (shen.extract_free_vars V1454 (hd (tl (tl V1455)))) (shen.extract_free_vars (cons (hd (tl V1455)) V1454) (hd (tl (tl (tl V1455))))))) ((cons? V1455) (union (shen.extract_free_vars V1454 (hd V1455)) (shen.extract_free_vars V1454 (tl V1455)))) (true ())))

(defun shen.free_variable_warnings (V1460 V1461) (cond ((= () V1461) _) (true (simple-error (cn "error: the following variables are free in " (shen.app V1460 (cn ": " (shen.app (shen.list_variables V1461) "" shen.a)) shen.a))))))

(defun shen.list_variables (V1463) (cond ((and (cons? V1463) (= () (tl V1463))) (cn (str (hd V1463)) ".")) ((cons? V1463) (cn (str (hd V1463)) (cn ", " (shen.list_variables (tl V1463))))) (true (shen.f_error shen.list_variables))))

(defun shen.strip-protect (V1465) (cond ((and (cons? V1465) (and (cons? (tl V1465)) (and (= () (tl (tl V1465))) (= (hd V1465) protect)))) (shen.strip-protect (hd (tl V1465)))) ((cons? V1465) (map (lambda Z (shen.strip-protect Z)) V1465)) (true V1465)))

(defun shen.linearise (V1467) (cond ((and (cons? V1467) (and (cons? (tl V1467)) (= () (tl (tl V1467))))) (shen.linearise_help (shen.flatten (hd V1467)) (hd V1467) (hd (tl V1467)))) (true (shen.f_error shen.linearise))))

(defun shen.flatten (V1469) (cond ((= () V1469) ()) ((cons? V1469) (append (shen.flatten (hd V1469)) (shen.flatten (tl V1469)))) (true (cons V1469 ()))))

(defun shen.linearise_help (V1473 V1474 V1475) (cond ((= () V1473) (cons V1474 (cons V1475 ()))) ((cons? V1473) (if (and (variable? (hd V1473)) (element? (hd V1473) (tl V1473))) (let Var (gensym (hd V1473)) (let NewAction (cons where (cons (cons = (cons (hd V1473) (cons Var ()))) (cons V1475 ()))) (let NewPatts (shen.linearise_X (hd V1473) Var V1474) (shen.linearise_help (tl V1473) NewPatts NewAction)))) (shen.linearise_help (tl V1473) V1474 V1475))) (true (shen.f_error shen.linearise_help))))

(defun shen.linearise_X (V1488 V1489 V1490) (cond ((= V1490 V1488) V1489) ((cons? V1490) (let L (shen.linearise_X V1488 V1489 (hd V1490)) (if (= L (hd V1490)) (cons (hd V1490) (shen.linearise_X V1488 V1489 (tl V1490))) (cons L (tl V1490))))) (true V1490)))

(defun shen.aritycheck (V1493 V1494) (cond ((and (cons? V1494) (and (cons? (hd V1494)) (and (cons? (tl (hd V1494))) (and (= () (tl (tl (hd V1494)))) (= () (tl V1494)))))) (do (shen.aritycheck-action (hd (tl (hd V1494)))) (shen.aritycheck-name V1493 (arity V1493) (length (hd (hd V1494)))))) ((and (cons? V1494) (and (cons? (hd V1494)) (and (cons? (tl (hd V1494))) (and (= () (tl (tl (hd V1494)))) (and (cons? (tl V1494)) (and (cons? (hd (tl V1494))) (and (cons? (tl (hd (tl V1494)))) (= () (tl (tl (hd (tl V1494)))))))))))) (if (= (length (hd (hd V1494))) (length (hd (hd (tl V1494))))) (do (shen.aritycheck-action (hd (tl (hd V1494)))) (shen.aritycheck V1493 (tl V1494))) (simple-error (cn "arity error in " (shen.app V1493 "
" shen.a))))) (true (shen.f_error shen.aritycheck))))

(defun shen.aritycheck-name (V1507 V1508 V1509) (cond ((= -1 V1508) V1509) ((= V1509 V1508) V1509) (true (do (shen.prhush (cn "
warning: changing the arity of " (shen.app V1507 " can cause errors.
" shen.a)) (stoutput)) V1509))))

(defun shen.aritycheck-action (V1515) (cond ((cons? V1515) (do (shen.aah (hd V1515) (tl V1515)) (for-each (lambda Y (shen.aritycheck-action Y)) V1515))) (true shen.skip)))

(defun shen.aah (V1518 V1519) (let Arity (arity V1518) (let Len (length V1519) (if (and (> Arity -1) (> Len Arity)) (shen.prhush (cn "warning: " (shen.app V1518 (cn " might not like " (shen.app Len (cn " argument" (shen.app (if (> Len 1) "s" "") ".
" shen.a)) shen.a)) shen.a)) (stoutput)) shen.skip))))

(defun shen.abstract_rule (V1521) (cond ((and (cons? V1521) (and (cons? (tl V1521)) (= () (tl (tl V1521))))) (shen.abstraction_build (hd V1521) (hd (tl V1521)))) (true (shen.f_error shen.abstract_rule))))

(defun shen.abstraction_build (V1524 V1525) (cond ((= () V1524) V1525) ((cons? V1524) (cons /. (cons (hd V1524) (cons (shen.abstraction_build (tl V1524) V1525) ())))) (true (shen.f_error shen.abstraction_build))))

(defun shen.parameters (V1527) (cond ((= 0 V1527) ()) (true (cons (gensym V) (shen.parameters (- V1527 1))))))

(defun shen.application_build (V1530 V1531) (cond ((= () V1530) V1531) ((cons? V1530) (shen.application_build (tl V1530) (cons V1531 (cons (hd V1530) ())))) (true (shen.f_error shen.application_build))))

(defun shen.compile_to_kl (V1534 V1535) (cond ((and (cons? V1535) (and (cons? (tl V1535)) (= () (tl (tl V1535))))) (let Arity (shen.store-arity V1534 (length (hd V1535))) (let Reduce (map (lambda X (shen.reduce X)) (hd (tl V1535))) (let CondExpression (shen.cond-expression V1534 (hd V1535) Reduce) (let TypeTable (if (value shen.*optimise*) (shen.typextable (shen.get-type V1534) (hd V1535)) shen.skip) (let TypedCondExpression (if (value shen.*optimise*) (shen.assign-types (hd V1535) TypeTable CondExpression) CondExpression) (cons defun (cons V1534 (cons (hd V1535) (cons TypedCondExpression ())))))))))) (true (shen.f_error shen.compile_to_kl))))

(defun shen.get-type (V1541) (cond ((cons? V1541) shen.skip) (true (let FType (assoc V1541 (value shen.*signedfuncs*)) (if (empty? FType) shen.skip (tl FType))))))

(defun shen.typextable (V1552 V1553) (cond ((and (cons? V1552) (and (cons? (tl V1552)) (and (= --> (hd (tl V1552))) (and (cons? (tl (tl V1552))) (and (= () (tl (tl (tl V1552)))) (cons? V1553)))))) (if (variable? (hd V1552)) (shen.typextable (hd (tl (tl V1552))) (tl V1553)) (cons (cons (hd V1553) (hd V1552)) (shen.typextable (hd (tl (tl V1552))) (tl V1553))))) (true ())))

(defun shen.assign-types (V1557 V1558 V1559) (cond ((and (cons? V1559) (and (= let (hd V1559)) (and (cons? (tl V1559)) (and (cons? (tl (tl V1559))) (and (cons? (tl (tl (tl V1559)))) (= () (tl (tl (tl (tl V1559)))))))))) (cons let (cons (hd (tl V1559)) (cons (shen.assign-types V1557 V1558 (hd (tl (tl V1559)))) (cons (shen.assign-types (cons (hd (tl V1559)) V1557) V1558 (hd (tl (tl (tl V1559))))) ()))))) ((and (cons? V1559) (and (= lambda (hd V1559)) (and (cons? (tl V1559)) (and (cons? (tl (tl V1559))) (= () (tl (tl (tl V1559)))))))) (cons lambda (cons (hd (tl V1559)) (cons (shen.assign-types (cons (hd (tl V1559)) V1557) V1558 (hd (tl (tl V1559)))) ())))) ((and (cons? V1559) (= cond (hd V1559))) (cons cond (map (lambda Y (cons (shen.assign-types V1557 V1558 (hd Y)) (cons (shen.assign-types V1557 V1558 (hd (tl Y))) ()))) (tl V1559)))) ((cons? V1559) (let NewTable (shen.typextable (shen.get-type (hd V1559)) (tl V1559)) (cons (hd V1559) (map (lambda Y (shen.assign-types V1557 (append V1558 NewTable) Y)) (tl V1559))))) (true (let AtomType (assoc V1559 V1558) (if (cons? AtomType) (cons type (cons V1559 (cons (tl AtomType) ()))) (if (element? V1559 V1557) V1559 (shen.atom-type V1559)))))))

(defun shen.atom-type (V1561) (if (string? V1561) (cons type (cons V1561 (cons string ()))) (if (number? V1561) (cons type (cons V1561 (cons number ()))) (if (boolean? V1561) (cons type (cons V1561 (cons boolean ()))) (if (symbol? V1561) (cons type (cons V1561 (cons symbol ()))) V1561)))))

(defun shen.store-arity (V1566 V1567) (cond ((value shen.*installing-kl*) shen.skip) (true (put V1566 arity V1567 (value *property-vector*)))))

(defun shen.reduce (V1569) (do (set shen.*teststack* ()) (let Result (shen.reduce_help V1569) (cons (cons : (cons shen.tests (reverse (value shen.*teststack*)))) (cons Result ())))))

(defun shen.reduce_help (V1571) (cond ((and (cons? V1571) (and (cons? (hd V1571)) (and (= /. (hd (hd V1571))) (and (cons? (tl (hd V1571))) (and (cons? (hd (tl (hd V1571)))) (and (= cons (hd (hd (tl (hd V1571))))) (and (cons? (tl (hd (tl (hd V1571))))) (and (cons? (tl (tl (hd (tl (hd V1571)))))) (and (= () (tl (tl (tl (hd (tl (hd V1571))))))) (and (cons? (tl (tl (hd V1571)))) (and (= () (tl (tl (tl (hd V1571))))) (and (cons? (tl V1571)) (= () (tl (tl V1571))))))))))))))) (do (shen.add_test (cons cons? (tl V1571))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1571))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1571)))))) (cons (shen.ebr (hd (tl V1571)) (hd (tl (hd V1571))) (hd (tl (tl (hd V1571))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hd (tl V1571)) ())) (cons (cons tl (tl V1571)) ())) (shen.reduce_help Application))))) ((and (cons? V1571) (and (cons? (hd V1571)) (and (= /. (hd (hd V1571))) (and (cons? (tl (hd V1571))) (and (cons? (hd (tl (hd V1571)))) (and (= @p (hd (hd (tl (hd V1571))))) (and (cons? (tl (hd (tl (hd V1571))))) (and (cons? (tl (tl (hd (tl (hd V1571)))))) (and (= () (tl (tl (tl (hd (tl (hd V1571))))))) (and (cons? (tl (tl (hd V1571)))) (and (= () (tl (tl (tl (hd V1571))))) (and (cons? (tl V1571)) (= () (tl (tl V1571))))))))))))))) (do (shen.add_test (cons tuple? (tl V1571))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1571))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1571)))))) (cons (shen.ebr (hd (tl V1571)) (hd (tl (hd V1571))) (hd (tl (tl (hd V1571))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons fst (tl V1571)) ())) (cons (cons snd (tl V1571)) ())) (shen.reduce_help Application))))) ((and (cons? V1571) (and (cons? (hd V1571)) (and (= /. (hd (hd V1571))) (and (cons? (tl (hd V1571))) (and (cons? (hd (tl (hd V1571)))) (and (= @v (hd (hd (tl (hd V1571))))) (and (cons? (tl (hd (tl (hd V1571))))) (and (cons? (tl (tl (hd (tl (hd V1571)))))) (and (= () (tl (tl (tl (hd (tl (hd V1571))))))) (and (cons? (tl (tl (hd V1571)))) (and (= () (tl (tl (tl (hd V1571))))) (and (cons? (tl V1571)) (= () (tl (tl V1571))))))))))))))) (do (shen.add_test (cons shen.+vector? (tl V1571))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1571))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1571)))))) (cons (shen.ebr (hd (tl V1571)) (hd (tl (hd V1571))) (hd (tl (tl (hd V1571))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hdv (tl V1571)) ())) (cons (cons tlv (tl V1571)) ())) (shen.reduce_help Application))))) ((and (cons? V1571) (and (cons? (hd V1571)) (and (= /. (hd (hd V1571))) (and (cons? (tl (hd V1571))) (and (cons? (hd (tl (hd V1571)))) (and (= @s (hd (hd (tl (hd V1571))))) (and (cons? (tl (hd (tl (hd V1571))))) (and (cons? (tl (tl (hd (tl (hd V1571)))))) (and (= () (tl (tl (tl (hd (tl (hd V1571))))))) (and (cons? (tl (tl (hd V1571)))) (and (= () (tl (tl (tl (hd V1571))))) (and (cons? (tl V1571)) (= () (tl (tl V1571))))))))))))))) (do (shen.add_test (cons shen.+string? (tl V1571))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1571))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1571)))))) (cons (shen.ebr (hd (tl V1571)) (hd (tl (hd V1571))) (hd (tl (tl (hd V1571))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons pos (cons (hd (tl V1571)) (cons 0 ()))) ())) (cons (cons tlstr (tl V1571)) ())) (shen.reduce_help Application))))) ((and (cons? V1571) (and (cons? (hd V1571)) (and (= /. (hd (hd V1571))) (and (cons? (tl (hd V1571))) (and (cons? (tl (tl (hd V1571)))) (and (= () (tl (tl (tl (hd V1571))))) (and (cons? (tl V1571)) (and (= () (tl (tl V1571))) (not (variable? (hd (tl (hd V1571))))))))))))) (do (shen.add_test (cons = (cons (hd (tl (hd V1571))) (tl V1571)))) (shen.reduce_help (hd (tl (tl (hd V1571))))))) ((and (cons? V1571) (and (cons? (hd V1571)) (and (= /. (hd (hd V1571))) (and (cons? (tl (hd V1571))) (and (cons? (tl (tl (hd V1571)))) (and (= () (tl (tl (tl (hd V1571))))) (and (cons? (tl V1571)) (= () (tl (tl V1571)))))))))) (shen.reduce_help (shen.ebr (hd (tl V1571)) (hd (tl (hd V1571))) (hd (tl (tl (hd V1571))))))) ((and (cons? V1571) (and (= where (hd V1571)) (and (cons? (tl V1571)) (and (cons? (tl (tl V1571))) (= () (tl (tl (tl V1571)))))))) (do (shen.add_test (hd (tl V1571))) (shen.reduce_help (hd (tl (tl V1571)))))) ((and (cons? V1571) (and (cons? (tl V1571)) (= () (tl (tl V1571))))) (let Z (shen.reduce_help (hd V1571)) (if (= (hd V1571) Z) V1571 (shen.reduce_help (cons Z (tl V1571)))))) (true V1571)))

(defun shen.+string? (V1573) (cond ((= "" V1573) false) (true (string? V1573))))

(defun shen.+vector? (V1575) (and (absvector? V1575) (> (<-address V1575 0) 0)))

(defun shen.ebr (V1589 V1590 V1591) (cond ((= V1591 V1590) V1589) ((and (cons? V1591) (and (= /. (hd V1591)) (and (cons? (tl V1591)) (and (cons? (tl (tl V1591))) (and (= () (tl (tl (tl V1591)))) (> (occurrences V1590 (hd (tl V1591))) 0)))))) V1591) ((and (cons? V1591) (and (= lambda (hd V1591)) (and (cons? (tl V1591)) (and (cons? (tl (tl V1591))) (and (= () (tl (tl (tl V1591)))) (> (occurrences V1590 (hd (tl V1591))) 0)))))) V1591) ((and (cons? V1591) (and (= let (hd V1591)) (and (cons? (tl V1591)) (and (cons? (tl (tl V1591))) (and (cons? (tl (tl (tl V1591)))) (and (= () (tl (tl (tl (tl V1591))))) (= (hd (tl V1591)) V1590))))))) (cons let (cons (hd (tl V1591)) (cons (shen.ebr V1589 (hd (tl V1591)) (hd (tl (tl V1591)))) (tl (tl (tl V1591))))))) ((cons? V1591) (cons (shen.ebr V1589 V1590 (hd V1591)) (shen.ebr V1589 V1590 (tl V1591)))) (true V1591)))

(defun shen.add_test (V1593) (set shen.*teststack* (cons V1593 (value shen.*teststack*))))

(defun shen.cond-expression (V1597 V1598 V1599) (let Err (shen.err-condition V1597) (let Cases (shen.case-form V1599 Err) (let EncodeChoices (shen.encode-choices Cases V1597) (shen.cond-form EncodeChoices)))))

(defun shen.cond-form (V1603) (cond ((and (cons? V1603) (and (cons? (hd V1603)) (and (= true (hd (hd V1603))) (and (cons? (tl (hd V1603))) (= () (tl (tl (hd V1603)))))))) (hd (tl (hd V1603)))) (true (cons cond V1603))))

(defun shen.encode-choices (V1608 V1609) (cond ((= () V1608) ()) ((and (cons? V1608) (and (cons? (hd V1608)) (and (= true (hd (hd V1608))) (and (cons? (tl (hd V1608))) (and (cons? (hd (tl (hd V1608)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1608))))) (and (cons? (tl (hd (tl (hd V1608))))) (and (= () (tl (tl (hd (tl (hd V1608)))))) (and (= () (tl (tl (hd V1608)))) (= () (tl V1608))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1608))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (if (value shen.*installing-kl*) (cons shen.sys-error (cons V1609 ())) (cons shen.f_error (cons V1609 ()))) (cons Result ())))) ())))) ())) ())) ((and (cons? V1608) (and (cons? (hd V1608)) (and (= true (hd (hd V1608))) (and (cons? (tl (hd V1608))) (and (cons? (hd (tl (hd V1608)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1608))))) (and (cons? (tl (hd (tl (hd V1608))))) (and (= () (tl (tl (hd (tl (hd V1608)))))) (= () (tl (tl (hd V1608)))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1608))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (shen.cond-form (shen.encode-choices (tl V1608) V1609)) (cons Result ())))) ())))) ())) ())) ((and (cons? V1608) (and (cons? (hd V1608)) (and (cons? (tl (hd V1608))) (and (cons? (hd (tl (hd V1608)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1608))))) (and (cons? (tl (hd (tl (hd V1608))))) (and (= () (tl (tl (hd (tl (hd V1608)))))) (= () (tl (tl (hd V1608))))))))))) (cons (cons true (cons (cons let (cons Freeze (cons (cons freeze (cons (shen.cond-form (shen.encode-choices (tl V1608) V1609)) ())) (cons (cons if (cons (hd (hd V1608)) (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1608))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (cons thaw (cons Freeze ())) (cons Result ())))) ())))) (cons (cons thaw (cons Freeze ())) ())))) ())))) ())) ())) ((and (cons? V1608) (and (cons? (hd V1608)) (and (cons? (tl (hd V1608))) (= () (tl (tl (hd V1608))))))) (cons (hd V1608) (shen.encode-choices (tl V1608) V1609))) (true (shen.f_error shen.encode-choices))))

(defun shen.case-form (V1616 V1617) (cond ((= () V1616) (cons V1617 ())) ((and (cons? V1616) (and (cons? (hd V1616)) (and (cons? (hd (hd V1616))) (and (= : (hd (hd (hd V1616)))) (and (cons? (tl (hd (hd V1616)))) (and (= shen.tests (hd (tl (hd (hd V1616))))) (and (= () (tl (tl (hd (hd V1616))))) (and (cons? (tl (hd V1616))) (and (cons? (hd (tl (hd V1616)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1616))))) (and (cons? (tl (hd (tl (hd V1616))))) (and (= () (tl (tl (hd (tl (hd V1616)))))) (= () (tl (tl (hd V1616)))))))))))))))) (cons (cons true (tl (hd V1616))) (shen.case-form (tl V1616) V1617))) ((and (cons? V1616) (and (cons? (hd V1616)) (and (cons? (hd (hd V1616))) (and (= : (hd (hd (hd V1616)))) (and (cons? (tl (hd (hd V1616)))) (and (= shen.tests (hd (tl (hd (hd V1616))))) (and (= () (tl (tl (hd (hd V1616))))) (and (cons? (tl (hd V1616))) (= () (tl (tl (hd V1616)))))))))))) (cons (cons true (tl (hd V1616))) ())) ((and (cons? V1616) (and (cons? (hd V1616)) (and (cons? (hd (hd V1616))) (and (= : (hd (hd (hd V1616)))) (and (cons? (tl (hd (hd V1616)))) (and (= shen.tests (hd (tl (hd (hd V1616))))) (and (cons? (tl (hd V1616))) (= () (tl (tl (hd V1616))))))))))) (cons (cons (shen.embed-and (tl (tl (hd (hd V1616))))) (tl (hd V1616))) (shen.case-form (tl V1616) V1617))) (true (shen.f_error shen.case-form))))

(defun shen.embed-and (V1619) (cond ((and (cons? V1619) (= () (tl V1619))) (hd V1619)) ((cons? V1619) (cons and (cons (hd V1619) (cons (shen.embed-and (tl V1619)) ())))) (true (shen.f_error shen.embed-and))))

(defun shen.err-condition (V1621) (cons true (cons (cons shen.f_error (cons V1621 ())) ())))

(defun shen.sys-error (V1623) (simple-error (cn "system function " (shen.app V1623 ": unexpected argument
" shen.a))))



