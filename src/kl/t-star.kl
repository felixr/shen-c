"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.typecheck (V3503 V3504) (let Curry (shen.curry V3503) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V3504)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V3506) (cond ((and (cons? V3506) (shen.special? (hd V3506))) (cons (hd V3506) (map (lambda Y (shen.curry Y)) (tl V3506)))) ((and (cons? V3506) (and (cons? (tl V3506)) (shen.extraspecial? (hd V3506)))) V3506) ((and (cons? V3506) (and (= type (hd V3506)) (and (cons? (tl V3506)) (and (cons? (tl (tl V3506))) (= () (tl (tl (tl V3506)))))))) (cons type (cons (shen.curry (hd (tl V3506))) (tl (tl V3506))))) ((and (cons? V3506) (and (cons? (tl V3506)) (cons? (tl (tl V3506))))) (shen.curry (cons (cons (hd V3506) (cons (hd (tl V3506)) ())) (tl (tl V3506))))) ((and (cons? V3506) (and (cons? (tl V3506)) (= () (tl (tl V3506))))) (cons (shen.curry (hd V3506)) (cons (shen.curry (hd (tl V3506))) ()))) (true V3506)))

(defun shen.special? (V3508) (element? V3508 (value shen.*special*)))

(defun shen.extraspecial? (V3510) (element? V3510 (value shen.*extraspecial*)))

(defun shen.t* (V3515 V3516 V3517 V3518) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V3517) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V3517 (freeze (bind Error (shen.errormaxinfs) V3517 V3518))))) (if (= Case false) (let Case (let V3495 (shen.lazyderef V3515 V3517) (if (= fail V3495) (do (shen.incinfs) (cut Throwcontrol V3517 (freeze (shen.prolog-failure V3517 V3518)))) false)) (if (= Case false) (let Case (let V3496 (shen.lazyderef V3515 V3517) (if (cons? V3496) (let X (hd V3496) (let V3497 (shen.lazyderef (tl V3496) V3517) (if (cons? V3497) (let V3498 (shen.lazyderef (hd V3497) V3517) (if (= : V3498) (let V3499 (shen.lazyderef (tl V3497) V3517) (if (cons? V3499) (let A (hd V3499) (let V3500 (shen.lazyderef (tl V3499) V3517) (if (= () V3500) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V3517 (freeze (cut Throwcontrol V3517 (freeze (shen.th* X A V3516 V3517 V3518)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V3517) (do (shen.incinfs) (shen.show V3515 V3516 V3517 (freeze (bind Datatypes (value shen.*datatypes*) V3517 (freeze (shen.udefs* V3515 V3516 Datatypes V3517 V3518))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V3524) (cond ((= + V3524) (set shen.*shen-type-theory-enabled?* true)) ((= - V3524) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V3535 V3536) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V3542 V3543 V3544 V3545 V3546) (let Case (let V3491 (shen.lazyderef V3544 V3545) (if (cons? V3491) (let D (hd V3491) (do (shen.incinfs) (call (cons D (cons V3542 (cons V3543 ()))) V3545 V3546))) false)) (if (= Case false) (let V3492 (shen.lazyderef V3544 V3545) (if (cons? V3492) (let Ds (tl V3492) (do (shen.incinfs) (shen.udefs* V3542 V3543 Ds V3545 V3546))) false)) Case)))

(defun shen.th* (V3552 V3553 V3554 V3555 V3556) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V3552 (cons : (cons V3553 ()))) V3554 V3555 (freeze (fwhen false V3555 V3556)))) (if (= Case false) (let Case (let F (shen.newpv V3555) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V3552 V3555)) V3555 (freeze (bind F (shen.sigf (shen.lazyderef V3552 V3555)) V3555 (freeze (call (cons F (cons V3553 ())) V3555 V3556))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V3552 V3553 V3555 V3556)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V3552 V3553 V3554 V3555 V3556)) (if (= Case false) (let Case (let V3387 (shen.lazyderef V3552 V3555) (if (cons? V3387) (let F (hd V3387) (let V3388 (shen.lazyderef (tl V3387) V3555) (if (= () V3388) (do (shen.incinfs) (shen.th* F (cons --> (cons V3553 ())) V3554 V3555 V3556)) false))) false)) (if (= Case false) (let Case (let V3389 (shen.lazyderef V3552 V3555) (if (cons? V3389) (let F (hd V3389) (let V3390 (shen.lazyderef (tl V3389) V3555) (if (cons? V3390) (let X (hd V3390) (let V3391 (shen.lazyderef (tl V3390) V3555) (if (= () V3391) (let B (shen.newpv V3555) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V3553 ()))) V3554 V3555 (freeze (shen.th* X B V3554 V3555 V3556))))) false))) false))) false)) (if (= Case false) (let Case (let V3392 (shen.lazyderef V3552 V3555) (if (cons? V3392) (let V3393 (shen.lazyderef (hd V3392) V3555) (if (= cons V3393) (let V3394 (shen.lazyderef (tl V3392) V3555) (if (cons? V3394) (let X (hd V3394) (let V3395 (shen.lazyderef (tl V3394) V3555) (if (cons? V3395) (let Y (hd V3395) (let V3396 (shen.lazyderef (tl V3395) V3555) (if (= () V3396) (let V3397 (shen.lazyderef V3553 V3555) (if (cons? V3397) (let V3398 (shen.lazyderef (hd V3397) V3555) (if (= list V3398) (let V3399 (shen.lazyderef (tl V3397) V3555) (if (cons? V3399) (let A (hd V3399) (let V3400 (shen.lazyderef (tl V3399) V3555) (if (= () V3400) (do (shen.incinfs) (shen.th* X A V3554 V3555 (freeze (shen.th* Y (cons list (cons A ())) V3554 V3555 V3556)))) (if (shen.pvar? V3400) (do (shen.bindv V3400 () V3555) (let Result (do (shen.incinfs) (shen.th* X A V3554 V3555 (freeze (shen.th* Y (cons list (cons A ())) V3554 V3555 V3556)))) (do (shen.unbindv V3400 V3555) Result))) false)))) (if (shen.pvar? V3399) (let A (shen.newpv V3555) (do (shen.bindv V3399 (cons A ()) V3555) (let Result (do (shen.incinfs) (shen.th* X A V3554 V3555 (freeze (shen.th* Y (cons list (cons A ())) V3554 V3555 V3556)))) (do (shen.unbindv V3399 V3555) Result)))) false))) (if (shen.pvar? V3398) (do (shen.bindv V3398 list V3555) (let Result (let V3401 (shen.lazyderef (tl V3397) V3555) (if (cons? V3401) (let A (hd V3401) (let V3402 (shen.lazyderef (tl V3401) V3555) (if (= () V3402) (do (shen.incinfs) (shen.th* X A V3554 V3555 (freeze (shen.th* Y (cons list (cons A ())) V3554 V3555 V3556)))) (if (shen.pvar? V3402) (do (shen.bindv V3402 () V3555) (let Result (do (shen.incinfs) (shen.th* X A V3554 V3555 (freeze (shen.th* Y (cons list (cons A ())) V3554 V3555 V3556)))) (do (shen.unbindv V3402 V3555) Result))) false)))) (if (shen.pvar? V3401) (let A (shen.newpv V3555) (do (shen.bindv V3401 (cons A ()) V3555) (let Result (do (shen.incinfs) (shen.th* X A V3554 V3555 (freeze (shen.th* Y (cons list (cons A ())) V3554 V3555 V3556)))) (do (shen.unbindv V3401 V3555) Result)))) false))) (do (shen.unbindv V3398 V3555) Result))) false))) (if (shen.pvar? V3397) (let A (shen.newpv V3555) (do (shen.bindv V3397 (cons list (cons A ())) V3555) (let Result (do (shen.incinfs) (shen.th* X A V3554 V3555 (freeze (shen.th* Y (cons list (cons A ())) V3554 V3555 V3556)))) (do (shen.unbindv V3397 V3555) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3403 (shen.lazyderef V3552 V3555) (if (cons? V3403) (let V3404 (shen.lazyderef (hd V3403) V3555) (if (= @p V3404) (let V3405 (shen.lazyderef (tl V3403) V3555) (if (cons? V3405) (let X (hd V3405) (let V3406 (shen.lazyderef (tl V3405) V3555) (if (cons? V3406) (let Y (hd V3406) (let V3407 (shen.lazyderef (tl V3406) V3555) (if (= () V3407) (let V3408 (shen.lazyderef V3553 V3555) (if (cons? V3408) (let A (hd V3408) (let V3409 (shen.lazyderef (tl V3408) V3555) (if (cons? V3409) (let V3410 (shen.lazyderef (hd V3409) V3555) (if (= * V3410) (let V3411 (shen.lazyderef (tl V3409) V3555) (if (cons? V3411) (let B (hd V3411) (let V3412 (shen.lazyderef (tl V3411) V3555) (if (= () V3412) (do (shen.incinfs) (shen.th* X A V3554 V3555 (freeze (shen.th* Y B V3554 V3555 V3556)))) (if (shen.pvar? V3412) (do (shen.bindv V3412 () V3555) (let Result (do (shen.incinfs) (shen.th* X A V3554 V3555 (freeze (shen.th* Y B V3554 V3555 V3556)))) (do (shen.unbindv V3412 V3555) Result))) false)))) (if (shen.pvar? V3411) (let B (shen.newpv V3555) (do (shen.bindv V3411 (cons B ()) V3555) (let Result (do (shen.incinfs) (shen.th* X A V3554 V3555 (freeze (shen.th* Y B V3554 V3555 V3556)))) (do (shen.unbindv V3411 V3555) Result)))) false))) (if (shen.pvar? V3410) (do (shen.bindv V3410 * V3555) (let Result (let V3413 (shen.lazyderef (tl V3409) V3555) (if (cons? V3413) (let B (hd V3413) (let V3414 (shen.lazyderef (tl V3413) V3555) (if (= () V3414) (do (shen.incinfs) (shen.th* X A V3554 V3555 (freeze (shen.th* Y B V3554 V3555 V3556)))) (if (shen.pvar? V3414) (do (shen.bindv V3414 () V3555) (let Result (do (shen.incinfs) (shen.th* X A V3554 V3555 (freeze (shen.th* Y B V3554 V3555 V3556)))) (do (shen.unbindv V3414 V3555) Result))) false)))) (if (shen.pvar? V3413) (let B (shen.newpv V3555) (do (shen.bindv V3413 (cons B ()) V3555) (let Result (do (shen.incinfs) (shen.th* X A V3554 V3555 (freeze (shen.th* Y B V3554 V3555 V3556)))) (do (shen.unbindv V3413 V3555) Result)))) false))) (do (shen.unbindv V3410 V3555) Result))) false))) (if (shen.pvar? V3409) (let B (shen.newpv V3555) (do (shen.bindv V3409 (cons * (cons B ())) V3555) (let Result (do (shen.incinfs) (shen.th* X A V3554 V3555 (freeze (shen.th* Y B V3554 V3555 V3556)))) (do (shen.unbindv V3409 V3555) Result)))) false)))) (if (shen.pvar? V3408) (let A (shen.newpv V3555) (let B (shen.newpv V3555) (do (shen.bindv V3408 (cons A (cons * (cons B ()))) V3555) (let Result (do (shen.incinfs) (shen.th* X A V3554 V3555 (freeze (shen.th* Y B V3554 V3555 V3556)))) (do (shen.unbindv V3408 V3555) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3415 (shen.lazyderef V3552 V3555) (if (cons? V3415) (let V3416 (shen.lazyderef (hd V3415) V3555) (if (= @v V3416) (let V3417 (shen.lazyderef (tl V3415) V3555) (if (cons? V3417) (let X (hd V3417) (let V3418 (shen.lazyderef (tl V3417) V3555) (if (cons? V3418) (let Y (hd V3418) (let V3419 (shen.lazyderef (tl V3418) V3555) (if (= () V3419) (let V3420 (shen.lazyderef V3553 V3555) (if (cons? V3420) (let V3421 (shen.lazyderef (hd V3420) V3555) (if (= vector V3421) (let V3422 (shen.lazyderef (tl V3420) V3555) (if (cons? V3422) (let A (hd V3422) (let V3423 (shen.lazyderef (tl V3422) V3555) (if (= () V3423) (do (shen.incinfs) (shen.th* X A V3554 V3555 (freeze (shen.th* Y (cons vector (cons A ())) V3554 V3555 V3556)))) (if (shen.pvar? V3423) (do (shen.bindv V3423 () V3555) (let Result (do (shen.incinfs) (shen.th* X A V3554 V3555 (freeze (shen.th* Y (cons vector (cons A ())) V3554 V3555 V3556)))) (do (shen.unbindv V3423 V3555) Result))) false)))) (if (shen.pvar? V3422) (let A (shen.newpv V3555) (do (shen.bindv V3422 (cons A ()) V3555) (let Result (do (shen.incinfs) (shen.th* X A V3554 V3555 (freeze (shen.th* Y (cons vector (cons A ())) V3554 V3555 V3556)))) (do (shen.unbindv V3422 V3555) Result)))) false))) (if (shen.pvar? V3421) (do (shen.bindv V3421 vector V3555) (let Result (let V3424 (shen.lazyderef (tl V3420) V3555) (if (cons? V3424) (let A (hd V3424) (let V3425 (shen.lazyderef (tl V3424) V3555) (if (= () V3425) (do (shen.incinfs) (shen.th* X A V3554 V3555 (freeze (shen.th* Y (cons vector (cons A ())) V3554 V3555 V3556)))) (if (shen.pvar? V3425) (do (shen.bindv V3425 () V3555) (let Result (do (shen.incinfs) (shen.th* X A V3554 V3555 (freeze (shen.th* Y (cons vector (cons A ())) V3554 V3555 V3556)))) (do (shen.unbindv V3425 V3555) Result))) false)))) (if (shen.pvar? V3424) (let A (shen.newpv V3555) (do (shen.bindv V3424 (cons A ()) V3555) (let Result (do (shen.incinfs) (shen.th* X A V3554 V3555 (freeze (shen.th* Y (cons vector (cons A ())) V3554 V3555 V3556)))) (do (shen.unbindv V3424 V3555) Result)))) false))) (do (shen.unbindv V3421 V3555) Result))) false))) (if (shen.pvar? V3420) (let A (shen.newpv V3555) (do (shen.bindv V3420 (cons vector (cons A ())) V3555) (let Result (do (shen.incinfs) (shen.th* X A V3554 V3555 (freeze (shen.th* Y (cons vector (cons A ())) V3554 V3555 V3556)))) (do (shen.unbindv V3420 V3555) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3426 (shen.lazyderef V3552 V3555) (if (cons? V3426) (let V3427 (shen.lazyderef (hd V3426) V3555) (if (= @s V3427) (let V3428 (shen.lazyderef (tl V3426) V3555) (if (cons? V3428) (let X (hd V3428) (let V3429 (shen.lazyderef (tl V3428) V3555) (if (cons? V3429) (let Y (hd V3429) (let V3430 (shen.lazyderef (tl V3429) V3555) (if (= () V3430) (let V3431 (shen.lazyderef V3553 V3555) (if (= string V3431) (do (shen.incinfs) (shen.th* X string V3554 V3555 (freeze (shen.th* Y string V3554 V3555 V3556)))) (if (shen.pvar? V3431) (do (shen.bindv V3431 string V3555) (let Result (do (shen.incinfs) (shen.th* X string V3554 V3555 (freeze (shen.th* Y string V3554 V3555 V3556)))) (do (shen.unbindv V3431 V3555) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3432 (shen.lazyderef V3552 V3555) (if (cons? V3432) (let V3433 (shen.lazyderef (hd V3432) V3555) (if (= lambda V3433) (let V3434 (shen.lazyderef (tl V3432) V3555) (if (cons? V3434) (let X (hd V3434) (let V3435 (shen.lazyderef (tl V3434) V3555) (if (cons? V3435) (let Y (hd V3435) (let V3436 (shen.lazyderef (tl V3435) V3555) (if (= () V3436) (let V3437 (shen.lazyderef V3553 V3555) (if (cons? V3437) (let A (hd V3437) (let V3438 (shen.lazyderef (tl V3437) V3555) (if (cons? V3438) (let V3439 (shen.lazyderef (hd V3438) V3555) (if (= --> V3439) (let V3440 (shen.lazyderef (tl V3438) V3555) (if (cons? V3440) (let B (hd V3440) (let V3441 (shen.lazyderef (tl V3440) V3555) (if (= () V3441) (let Z (shen.newpv V3555) (let X&& (shen.newpv V3555) (do (shen.incinfs) (cut Throwcontrol V3555 (freeze (bind X&& (shen.placeholder) V3555 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3555) (shen.lazyderef X V3555) (shen.lazyderef Y V3555)) V3555 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3554) V3555 V3556)))))))))) (if (shen.pvar? V3441) (do (shen.bindv V3441 () V3555) (let Result (let Z (shen.newpv V3555) (let X&& (shen.newpv V3555) (do (shen.incinfs) (cut Throwcontrol V3555 (freeze (bind X&& (shen.placeholder) V3555 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3555) (shen.lazyderef X V3555) (shen.lazyderef Y V3555)) V3555 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3554) V3555 V3556)))))))))) (do (shen.unbindv V3441 V3555) Result))) false)))) (if (shen.pvar? V3440) (let B (shen.newpv V3555) (do (shen.bindv V3440 (cons B ()) V3555) (let Result (let Z (shen.newpv V3555) (let X&& (shen.newpv V3555) (do (shen.incinfs) (cut Throwcontrol V3555 (freeze (bind X&& (shen.placeholder) V3555 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3555) (shen.lazyderef X V3555) (shen.lazyderef Y V3555)) V3555 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3554) V3555 V3556)))))))))) (do (shen.unbindv V3440 V3555) Result)))) false))) (if (shen.pvar? V3439) (do (shen.bindv V3439 --> V3555) (let Result (let V3442 (shen.lazyderef (tl V3438) V3555) (if (cons? V3442) (let B (hd V3442) (let V3443 (shen.lazyderef (tl V3442) V3555) (if (= () V3443) (let Z (shen.newpv V3555) (let X&& (shen.newpv V3555) (do (shen.incinfs) (cut Throwcontrol V3555 (freeze (bind X&& (shen.placeholder) V3555 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3555) (shen.lazyderef X V3555) (shen.lazyderef Y V3555)) V3555 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3554) V3555 V3556)))))))))) (if (shen.pvar? V3443) (do (shen.bindv V3443 () V3555) (let Result (let Z (shen.newpv V3555) (let X&& (shen.newpv V3555) (do (shen.incinfs) (cut Throwcontrol V3555 (freeze (bind X&& (shen.placeholder) V3555 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3555) (shen.lazyderef X V3555) (shen.lazyderef Y V3555)) V3555 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3554) V3555 V3556)))))))))) (do (shen.unbindv V3443 V3555) Result))) false)))) (if (shen.pvar? V3442) (let B (shen.newpv V3555) (do (shen.bindv V3442 (cons B ()) V3555) (let Result (let Z (shen.newpv V3555) (let X&& (shen.newpv V3555) (do (shen.incinfs) (cut Throwcontrol V3555 (freeze (bind X&& (shen.placeholder) V3555 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3555) (shen.lazyderef X V3555) (shen.lazyderef Y V3555)) V3555 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3554) V3555 V3556)))))))))) (do (shen.unbindv V3442 V3555) Result)))) false))) (do (shen.unbindv V3439 V3555) Result))) false))) (if (shen.pvar? V3438) (let B (shen.newpv V3555) (do (shen.bindv V3438 (cons --> (cons B ())) V3555) (let Result (let Z (shen.newpv V3555) (let X&& (shen.newpv V3555) (do (shen.incinfs) (cut Throwcontrol V3555 (freeze (bind X&& (shen.placeholder) V3555 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3555) (shen.lazyderef X V3555) (shen.lazyderef Y V3555)) V3555 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3554) V3555 V3556)))))))))) (do (shen.unbindv V3438 V3555) Result)))) false)))) (if (shen.pvar? V3437) (let A (shen.newpv V3555) (let B (shen.newpv V3555) (do (shen.bindv V3437 (cons A (cons --> (cons B ()))) V3555) (let Result (let Z (shen.newpv V3555) (let X&& (shen.newpv V3555) (do (shen.incinfs) (cut Throwcontrol V3555 (freeze (bind X&& (shen.placeholder) V3555 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3555) (shen.lazyderef X V3555) (shen.lazyderef Y V3555)) V3555 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3554) V3555 V3556)))))))))) (do (shen.unbindv V3437 V3555) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3444 (shen.lazyderef V3552 V3555) (if (cons? V3444) (let V3445 (shen.lazyderef (hd V3444) V3555) (if (= let V3445) (let V3446 (shen.lazyderef (tl V3444) V3555) (if (cons? V3446) (let X (hd V3446) (let V3447 (shen.lazyderef (tl V3446) V3555) (if (cons? V3447) (let Y (hd V3447) (let V3448 (shen.lazyderef (tl V3447) V3555) (if (cons? V3448) (let Z (hd V3448) (let V3449 (shen.lazyderef (tl V3448) V3555) (if (= () V3449) (let W (shen.newpv V3555) (let X&& (shen.newpv V3555) (let B (shen.newpv V3555) (do (shen.incinfs) (shen.th* Y B V3554 V3555 (freeze (bind X&& (shen.placeholder) V3555 (freeze (bind W (shen.ebr (shen.lazyderef X&& V3555) (shen.lazyderef X V3555) (shen.lazyderef Z V3555)) V3555 (freeze (shen.th* W V3553 (cons (cons X&& (cons : (cons B ()))) V3554) V3555 V3556))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3450 (shen.lazyderef V3552 V3555) (if (cons? V3450) (let V3451 (shen.lazyderef (hd V3450) V3555) (if (= open V3451) (let V3452 (shen.lazyderef (tl V3450) V3555) (if (cons? V3452) (let FileName (hd V3452) (let V3453 (shen.lazyderef (tl V3452) V3555) (if (cons? V3453) (let Direction3383 (hd V3453) (let V3454 (shen.lazyderef (tl V3453) V3555) (if (= () V3454) (let V3455 (shen.lazyderef V3553 V3555) (if (cons? V3455) (let V3456 (shen.lazyderef (hd V3455) V3555) (if (= stream V3456) (let V3457 (shen.lazyderef (tl V3455) V3555) (if (cons? V3457) (let Direction (hd V3457) (let V3458 (shen.lazyderef (tl V3457) V3555) (if (= () V3458) (do (shen.incinfs) (unify! Direction Direction3383 V3555 (freeze (cut Throwcontrol V3555 (freeze (fwhen (element? (shen.lazyderef Direction V3555) (cons in (cons out ()))) V3555 (freeze (shen.th* FileName string V3554 V3555 V3556)))))))) (if (shen.pvar? V3458) (do (shen.bindv V3458 () V3555) (let Result (do (shen.incinfs) (unify! Direction Direction3383 V3555 (freeze (cut Throwcontrol V3555 (freeze (fwhen (element? (shen.lazyderef Direction V3555) (cons in (cons out ()))) V3555 (freeze (shen.th* FileName string V3554 V3555 V3556)))))))) (do (shen.unbindv V3458 V3555) Result))) false)))) (if (shen.pvar? V3457) (let Direction (shen.newpv V3555) (do (shen.bindv V3457 (cons Direction ()) V3555) (let Result (do (shen.incinfs) (unify! Direction Direction3383 V3555 (freeze (cut Throwcontrol V3555 (freeze (fwhen (element? (shen.lazyderef Direction V3555) (cons in (cons out ()))) V3555 (freeze (shen.th* FileName string V3554 V3555 V3556)))))))) (do (shen.unbindv V3457 V3555) Result)))) false))) (if (shen.pvar? V3456) (do (shen.bindv V3456 stream V3555) (let Result (let V3459 (shen.lazyderef (tl V3455) V3555) (if (cons? V3459) (let Direction (hd V3459) (let V3460 (shen.lazyderef (tl V3459) V3555) (if (= () V3460) (do (shen.incinfs) (unify! Direction Direction3383 V3555 (freeze (cut Throwcontrol V3555 (freeze (fwhen (element? (shen.lazyderef Direction V3555) (cons in (cons out ()))) V3555 (freeze (shen.th* FileName string V3554 V3555 V3556)))))))) (if (shen.pvar? V3460) (do (shen.bindv V3460 () V3555) (let Result (do (shen.incinfs) (unify! Direction Direction3383 V3555 (freeze (cut Throwcontrol V3555 (freeze (fwhen (element? (shen.lazyderef Direction V3555) (cons in (cons out ()))) V3555 (freeze (shen.th* FileName string V3554 V3555 V3556)))))))) (do (shen.unbindv V3460 V3555) Result))) false)))) (if (shen.pvar? V3459) (let Direction (shen.newpv V3555) (do (shen.bindv V3459 (cons Direction ()) V3555) (let Result (do (shen.incinfs) (unify! Direction Direction3383 V3555 (freeze (cut Throwcontrol V3555 (freeze (fwhen (element? (shen.lazyderef Direction V3555) (cons in (cons out ()))) V3555 (freeze (shen.th* FileName string V3554 V3555 V3556)))))))) (do (shen.unbindv V3459 V3555) Result)))) false))) (do (shen.unbindv V3456 V3555) Result))) false))) (if (shen.pvar? V3455) (let Direction (shen.newpv V3555) (do (shen.bindv V3455 (cons stream (cons Direction ())) V3555) (let Result (do (shen.incinfs) (unify! Direction Direction3383 V3555 (freeze (cut Throwcontrol V3555 (freeze (fwhen (element? (shen.lazyderef Direction V3555) (cons in (cons out ()))) V3555 (freeze (shen.th* FileName string V3554 V3555 V3556)))))))) (do (shen.unbindv V3455 V3555) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3461 (shen.lazyderef V3552 V3555) (if (cons? V3461) (let V3462 (shen.lazyderef (hd V3461) V3555) (if (= type V3462) (let V3463 (shen.lazyderef (tl V3461) V3555) (if (cons? V3463) (let X (hd V3463) (let V3464 (shen.lazyderef (tl V3463) V3555) (if (cons? V3464) (let A (hd V3464) (let V3465 (shen.lazyderef (tl V3464) V3555) (if (= () V3465) (do (shen.incinfs) (cut Throwcontrol V3555 (freeze (unify A V3553 V3555 (freeze (shen.th* X A V3554 V3555 V3556)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3466 (shen.lazyderef V3552 V3555) (if (cons? V3466) (let V3467 (shen.lazyderef (hd V3466) V3555) (if (= input+ V3467) (let V3468 (shen.lazyderef (tl V3466) V3555) (if (cons? V3468) (let A (hd V3468) (let V3469 (shen.lazyderef (tl V3468) V3555) (if (cons? V3469) (let Stream (hd V3469) (let V3470 (shen.lazyderef (tl V3469) V3555) (if (= () V3470) (let C (shen.newpv V3555) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V3555)) V3555 (freeze (unify V3553 C V3555 (freeze (shen.th* Stream (cons stream (cons in ())) V3554 V3555 V3556))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3471 (shen.lazyderef V3552 V3555) (if (cons? V3471) (let V3472 (shen.lazyderef (hd V3471) V3555) (if (= set V3472) (let V3473 (shen.lazyderef (tl V3471) V3555) (if (cons? V3473) (let Var (hd V3473) (let V3474 (shen.lazyderef (tl V3473) V3555) (if (cons? V3474) (let Val (hd V3474) (let V3475 (shen.lazyderef (tl V3474) V3555) (if (= () V3475) (do (shen.incinfs) (cut Throwcontrol V3555 (freeze (shen.th* Var symbol V3554 V3555 (freeze (cut Throwcontrol V3555 (freeze (shen.th* (cons value (cons Var ())) V3553 V3554 V3555 (freeze (shen.th* Val V3553 V3554 V3555 V3556)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V3555) (do (shen.incinfs) (shen.t*-hyps V3554 NewHyp V3555 (freeze (shen.th* V3552 V3553 NewHyp V3555 V3556))))) (if (= Case false) (let Case (let V3476 (shen.lazyderef V3552 V3555) (if (cons? V3476) (let V3477 (shen.lazyderef (hd V3476) V3555) (if (= define V3477) (let V3478 (shen.lazyderef (tl V3476) V3555) (if (cons? V3478) (let F (hd V3478) (let X (tl V3478) (do (shen.incinfs) (cut Throwcontrol V3555 (freeze (shen.t*-def (cons define (cons F X)) V3553 V3554 V3555 V3556)))))) false)) false)) false)) (if (= Case false) (let Case (let V3479 (shen.lazyderef V3552 V3555) (if (cons? V3479) (let V3480 (shen.lazyderef (hd V3479) V3555) (if (= defmacro V3480) (let V3481 (shen.lazyderef V3553 V3555) (if (= unit V3481) (do (shen.incinfs) (cut Throwcontrol V3555 V3556)) (if (shen.pvar? V3481) (do (shen.bindv V3481 unit V3555) (let Result (do (shen.incinfs) (cut Throwcontrol V3555 V3556)) (do (shen.unbindv V3481 V3555) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3482 (shen.lazyderef V3552 V3555) (if (cons? V3482) (let V3483 (shen.lazyderef (hd V3482) V3555) (if (= shen.process-datatype V3483) (let V3484 (shen.lazyderef V3553 V3555) (if (= symbol V3484) (do (shen.incinfs) (thaw V3556)) (if (shen.pvar? V3484) (do (shen.bindv V3484 symbol V3555) (let Result (do (shen.incinfs) (thaw V3556)) (do (shen.unbindv V3484 V3555) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3485 (shen.lazyderef V3552 V3555) (if (cons? V3485) (let V3486 (shen.lazyderef (hd V3485) V3555) (if (= shen.synonyms-help V3486) (let V3487 (shen.lazyderef V3553 V3555) (if (= symbol V3487) (do (shen.incinfs) (thaw V3556)) (if (shen.pvar? V3487) (do (shen.bindv V3487 symbol V3555) (let Result (do (shen.incinfs) (thaw V3556)) (do (shen.unbindv V3487 V3555) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V3555) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V3555 (freeze (shen.udefs* (cons V3552 (cons : (cons V3553 ()))) V3554 Datatypes V3555 V3556))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V3561 V3562 V3563 V3564) (let Case (let V3298 (shen.lazyderef V3561 V3563) (if (cons? V3298) (let V3299 (shen.lazyderef (hd V3298) V3563) (if (cons? V3299) (let V3300 (shen.lazyderef (hd V3299) V3563) (if (cons? V3300) (let V3301 (shen.lazyderef (hd V3300) V3563) (if (= cons V3301) (let V3302 (shen.lazyderef (tl V3300) V3563) (if (cons? V3302) (let X (hd V3302) (let V3303 (shen.lazyderef (tl V3302) V3563) (if (cons? V3303) (let Y (hd V3303) (let V3304 (shen.lazyderef (tl V3303) V3563) (if (= () V3304) (let V3305 (shen.lazyderef (tl V3299) V3563) (if (cons? V3305) (let V3306 (shen.lazyderef (hd V3305) V3563) (if (= : V3306) (let V3307 (shen.lazyderef (tl V3305) V3563) (if (cons? V3307) (let V3308 (shen.lazyderef (hd V3307) V3563) (if (cons? V3308) (let V3309 (shen.lazyderef (hd V3308) V3563) (if (= list V3309) (let V3310 (shen.lazyderef (tl V3308) V3563) (if (cons? V3310) (let A (hd V3310) (let V3311 (shen.lazyderef (tl V3310) V3563) (if (= () V3311) (let V3312 (shen.lazyderef (tl V3307) V3563) (if (= () V3312) (let Hyp (tl V3298) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons list (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (if (shen.pvar? V3312) (do (shen.bindv V3312 () V3563) (let Result (let Hyp (tl V3298) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons list (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (do (shen.unbindv V3312 V3563) Result))) false))) (if (shen.pvar? V3311) (do (shen.bindv V3311 () V3563) (let Result (let V3313 (shen.lazyderef (tl V3307) V3563) (if (= () V3313) (let Hyp (tl V3298) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons list (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (if (shen.pvar? V3313) (do (shen.bindv V3313 () V3563) (let Result (let Hyp (tl V3298) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons list (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (do (shen.unbindv V3313 V3563) Result))) false))) (do (shen.unbindv V3311 V3563) Result))) false)))) (if (shen.pvar? V3310) (let A (shen.newpv V3563) (do (shen.bindv V3310 (cons A ()) V3563) (let Result (let V3314 (shen.lazyderef (tl V3307) V3563) (if (= () V3314) (let Hyp (tl V3298) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons list (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (if (shen.pvar? V3314) (do (shen.bindv V3314 () V3563) (let Result (let Hyp (tl V3298) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons list (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (do (shen.unbindv V3314 V3563) Result))) false))) (do (shen.unbindv V3310 V3563) Result)))) false))) (if (shen.pvar? V3309) (do (shen.bindv V3309 list V3563) (let Result (let V3315 (shen.lazyderef (tl V3308) V3563) (if (cons? V3315) (let A (hd V3315) (let V3316 (shen.lazyderef (tl V3315) V3563) (if (= () V3316) (let V3317 (shen.lazyderef (tl V3307) V3563) (if (= () V3317) (let Hyp (tl V3298) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons list (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (if (shen.pvar? V3317) (do (shen.bindv V3317 () V3563) (let Result (let Hyp (tl V3298) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons list (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (do (shen.unbindv V3317 V3563) Result))) false))) (if (shen.pvar? V3316) (do (shen.bindv V3316 () V3563) (let Result (let V3318 (shen.lazyderef (tl V3307) V3563) (if (= () V3318) (let Hyp (tl V3298) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons list (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (if (shen.pvar? V3318) (do (shen.bindv V3318 () V3563) (let Result (let Hyp (tl V3298) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons list (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (do (shen.unbindv V3318 V3563) Result))) false))) (do (shen.unbindv V3316 V3563) Result))) false)))) (if (shen.pvar? V3315) (let A (shen.newpv V3563) (do (shen.bindv V3315 (cons A ()) V3563) (let Result (let V3319 (shen.lazyderef (tl V3307) V3563) (if (= () V3319) (let Hyp (tl V3298) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons list (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (if (shen.pvar? V3319) (do (shen.bindv V3319 () V3563) (let Result (let Hyp (tl V3298) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons list (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (do (shen.unbindv V3319 V3563) Result))) false))) (do (shen.unbindv V3315 V3563) Result)))) false))) (do (shen.unbindv V3309 V3563) Result))) false))) (if (shen.pvar? V3308) (let A (shen.newpv V3563) (do (shen.bindv V3308 (cons list (cons A ())) V3563) (let Result (let V3320 (shen.lazyderef (tl V3307) V3563) (if (= () V3320) (let Hyp (tl V3298) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons list (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (if (shen.pvar? V3320) (do (shen.bindv V3320 () V3563) (let Result (let Hyp (tl V3298) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons list (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (do (shen.unbindv V3320 V3563) Result))) false))) (do (shen.unbindv V3308 V3563) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3321 (shen.lazyderef V3561 V3563) (if (cons? V3321) (let V3322 (shen.lazyderef (hd V3321) V3563) (if (cons? V3322) (let V3323 (shen.lazyderef (hd V3322) V3563) (if (cons? V3323) (let V3324 (shen.lazyderef (hd V3323) V3563) (if (= @p V3324) (let V3325 (shen.lazyderef (tl V3323) V3563) (if (cons? V3325) (let X (hd V3325) (let V3326 (shen.lazyderef (tl V3325) V3563) (if (cons? V3326) (let Y (hd V3326) (let V3327 (shen.lazyderef (tl V3326) V3563) (if (= () V3327) (let V3328 (shen.lazyderef (tl V3322) V3563) (if (cons? V3328) (let V3329 (shen.lazyderef (hd V3328) V3563) (if (= : V3329) (let V3330 (shen.lazyderef (tl V3328) V3563) (if (cons? V3330) (let V3331 (shen.lazyderef (hd V3330) V3563) (if (cons? V3331) (let A (hd V3331) (let V3332 (shen.lazyderef (tl V3331) V3563) (if (cons? V3332) (let V3333 (shen.lazyderef (hd V3332) V3563) (if (= * V3333) (let V3334 (shen.lazyderef (tl V3332) V3563) (if (cons? V3334) (let B (hd V3334) (let V3335 (shen.lazyderef (tl V3334) V3563) (if (= () V3335) (let V3336 (shen.lazyderef (tl V3330) V3563) (if (= () V3336) (let Hyp (tl V3321) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (shen.lazyderef B V3563) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (if (shen.pvar? V3336) (do (shen.bindv V3336 () V3563) (let Result (let Hyp (tl V3321) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (shen.lazyderef B V3563) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (do (shen.unbindv V3336 V3563) Result))) false))) (if (shen.pvar? V3335) (do (shen.bindv V3335 () V3563) (let Result (let V3337 (shen.lazyderef (tl V3330) V3563) (if (= () V3337) (let Hyp (tl V3321) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (shen.lazyderef B V3563) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (if (shen.pvar? V3337) (do (shen.bindv V3337 () V3563) (let Result (let Hyp (tl V3321) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (shen.lazyderef B V3563) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (do (shen.unbindv V3337 V3563) Result))) false))) (do (shen.unbindv V3335 V3563) Result))) false)))) (if (shen.pvar? V3334) (let B (shen.newpv V3563) (do (shen.bindv V3334 (cons B ()) V3563) (let Result (let V3338 (shen.lazyderef (tl V3330) V3563) (if (= () V3338) (let Hyp (tl V3321) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (shen.lazyderef B V3563) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (if (shen.pvar? V3338) (do (shen.bindv V3338 () V3563) (let Result (let Hyp (tl V3321) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (shen.lazyderef B V3563) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (do (shen.unbindv V3338 V3563) Result))) false))) (do (shen.unbindv V3334 V3563) Result)))) false))) (if (shen.pvar? V3333) (do (shen.bindv V3333 * V3563) (let Result (let V3339 (shen.lazyderef (tl V3332) V3563) (if (cons? V3339) (let B (hd V3339) (let V3340 (shen.lazyderef (tl V3339) V3563) (if (= () V3340) (let V3341 (shen.lazyderef (tl V3330) V3563) (if (= () V3341) (let Hyp (tl V3321) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (shen.lazyderef B V3563) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (if (shen.pvar? V3341) (do (shen.bindv V3341 () V3563) (let Result (let Hyp (tl V3321) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (shen.lazyderef B V3563) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (do (shen.unbindv V3341 V3563) Result))) false))) (if (shen.pvar? V3340) (do (shen.bindv V3340 () V3563) (let Result (let V3342 (shen.lazyderef (tl V3330) V3563) (if (= () V3342) (let Hyp (tl V3321) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (shen.lazyderef B V3563) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (if (shen.pvar? V3342) (do (shen.bindv V3342 () V3563) (let Result (let Hyp (tl V3321) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (shen.lazyderef B V3563) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (do (shen.unbindv V3342 V3563) Result))) false))) (do (shen.unbindv V3340 V3563) Result))) false)))) (if (shen.pvar? V3339) (let B (shen.newpv V3563) (do (shen.bindv V3339 (cons B ()) V3563) (let Result (let V3343 (shen.lazyderef (tl V3330) V3563) (if (= () V3343) (let Hyp (tl V3321) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (shen.lazyderef B V3563) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (if (shen.pvar? V3343) (do (shen.bindv V3343 () V3563) (let Result (let Hyp (tl V3321) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (shen.lazyderef B V3563) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (do (shen.unbindv V3343 V3563) Result))) false))) (do (shen.unbindv V3339 V3563) Result)))) false))) (do (shen.unbindv V3333 V3563) Result))) false))) (if (shen.pvar? V3332) (let B (shen.newpv V3563) (do (shen.bindv V3332 (cons * (cons B ())) V3563) (let Result (let V3344 (shen.lazyderef (tl V3330) V3563) (if (= () V3344) (let Hyp (tl V3321) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (shen.lazyderef B V3563) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (if (shen.pvar? V3344) (do (shen.bindv V3344 () V3563) (let Result (let Hyp (tl V3321) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (shen.lazyderef B V3563) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (do (shen.unbindv V3344 V3563) Result))) false))) (do (shen.unbindv V3332 V3563) Result)))) false)))) (if (shen.pvar? V3331) (let A (shen.newpv V3563) (let B (shen.newpv V3563) (do (shen.bindv V3331 (cons A (cons * (cons B ()))) V3563) (let Result (let V3345 (shen.lazyderef (tl V3330) V3563) (if (= () V3345) (let Hyp (tl V3321) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (shen.lazyderef B V3563) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (if (shen.pvar? V3345) (do (shen.bindv V3345 () V3563) (let Result (let Hyp (tl V3321) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (shen.lazyderef B V3563) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (do (shen.unbindv V3345 V3563) Result))) false))) (do (shen.unbindv V3331 V3563) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3346 (shen.lazyderef V3561 V3563) (if (cons? V3346) (let V3347 (shen.lazyderef (hd V3346) V3563) (if (cons? V3347) (let V3348 (shen.lazyderef (hd V3347) V3563) (if (cons? V3348) (let V3349 (shen.lazyderef (hd V3348) V3563) (if (= @v V3349) (let V3350 (shen.lazyderef (tl V3348) V3563) (if (cons? V3350) (let X (hd V3350) (let V3351 (shen.lazyderef (tl V3350) V3563) (if (cons? V3351) (let Y (hd V3351) (let V3352 (shen.lazyderef (tl V3351) V3563) (if (= () V3352) (let V3353 (shen.lazyderef (tl V3347) V3563) (if (cons? V3353) (let V3354 (shen.lazyderef (hd V3353) V3563) (if (= : V3354) (let V3355 (shen.lazyderef (tl V3353) V3563) (if (cons? V3355) (let V3356 (shen.lazyderef (hd V3355) V3563) (if (cons? V3356) (let V3357 (shen.lazyderef (hd V3356) V3563) (if (= vector V3357) (let V3358 (shen.lazyderef (tl V3356) V3563) (if (cons? V3358) (let A (hd V3358) (let V3359 (shen.lazyderef (tl V3358) V3563) (if (= () V3359) (let V3360 (shen.lazyderef (tl V3355) V3563) (if (= () V3360) (let Hyp (tl V3346) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons vector (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (if (shen.pvar? V3360) (do (shen.bindv V3360 () V3563) (let Result (let Hyp (tl V3346) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons vector (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (do (shen.unbindv V3360 V3563) Result))) false))) (if (shen.pvar? V3359) (do (shen.bindv V3359 () V3563) (let Result (let V3361 (shen.lazyderef (tl V3355) V3563) (if (= () V3361) (let Hyp (tl V3346) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons vector (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (if (shen.pvar? V3361) (do (shen.bindv V3361 () V3563) (let Result (let Hyp (tl V3346) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons vector (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (do (shen.unbindv V3361 V3563) Result))) false))) (do (shen.unbindv V3359 V3563) Result))) false)))) (if (shen.pvar? V3358) (let A (shen.newpv V3563) (do (shen.bindv V3358 (cons A ()) V3563) (let Result (let V3362 (shen.lazyderef (tl V3355) V3563) (if (= () V3362) (let Hyp (tl V3346) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons vector (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (if (shen.pvar? V3362) (do (shen.bindv V3362 () V3563) (let Result (let Hyp (tl V3346) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons vector (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (do (shen.unbindv V3362 V3563) Result))) false))) (do (shen.unbindv V3358 V3563) Result)))) false))) (if (shen.pvar? V3357) (do (shen.bindv V3357 vector V3563) (let Result (let V3363 (shen.lazyderef (tl V3356) V3563) (if (cons? V3363) (let A (hd V3363) (let V3364 (shen.lazyderef (tl V3363) V3563) (if (= () V3364) (let V3365 (shen.lazyderef (tl V3355) V3563) (if (= () V3365) (let Hyp (tl V3346) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons vector (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (if (shen.pvar? V3365) (do (shen.bindv V3365 () V3563) (let Result (let Hyp (tl V3346) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons vector (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (do (shen.unbindv V3365 V3563) Result))) false))) (if (shen.pvar? V3364) (do (shen.bindv V3364 () V3563) (let Result (let V3366 (shen.lazyderef (tl V3355) V3563) (if (= () V3366) (let Hyp (tl V3346) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons vector (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (if (shen.pvar? V3366) (do (shen.bindv V3366 () V3563) (let Result (let Hyp (tl V3346) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons vector (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (do (shen.unbindv V3366 V3563) Result))) false))) (do (shen.unbindv V3364 V3563) Result))) false)))) (if (shen.pvar? V3363) (let A (shen.newpv V3563) (do (shen.bindv V3363 (cons A ()) V3563) (let Result (let V3367 (shen.lazyderef (tl V3355) V3563) (if (= () V3367) (let Hyp (tl V3346) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons vector (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (if (shen.pvar? V3367) (do (shen.bindv V3367 () V3563) (let Result (let Hyp (tl V3346) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons vector (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (do (shen.unbindv V3367 V3563) Result))) false))) (do (shen.unbindv V3363 V3563) Result)))) false))) (do (shen.unbindv V3357 V3563) Result))) false))) (if (shen.pvar? V3356) (let A (shen.newpv V3563) (do (shen.bindv V3356 (cons vector (cons A ())) V3563) (let Result (let V3368 (shen.lazyderef (tl V3355) V3563) (if (= () V3368) (let Hyp (tl V3346) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons vector (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (if (shen.pvar? V3368) (do (shen.bindv V3368 () V3563) (let Result (let Hyp (tl V3346) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons (shen.lazyderef A V3563) ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons (cons vector (cons (shen.lazyderef A V3563) ())) ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (do (shen.unbindv V3368 V3563) Result))) false))) (do (shen.unbindv V3356 V3563) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3369 (shen.lazyderef V3561 V3563) (if (cons? V3369) (let V3370 (shen.lazyderef (hd V3369) V3563) (if (cons? V3370) (let V3371 (shen.lazyderef (hd V3370) V3563) (if (cons? V3371) (let V3372 (shen.lazyderef (hd V3371) V3563) (if (= @s V3372) (let V3373 (shen.lazyderef (tl V3371) V3563) (if (cons? V3373) (let X (hd V3373) (let V3374 (shen.lazyderef (tl V3373) V3563) (if (cons? V3374) (let Y (hd V3374) (let V3375 (shen.lazyderef (tl V3374) V3563) (if (= () V3375) (let V3376 (shen.lazyderef (tl V3370) V3563) (if (cons? V3376) (let V3377 (shen.lazyderef (hd V3376) V3563) (if (= : V3377) (let V3378 (shen.lazyderef (tl V3376) V3563) (if (cons? V3378) (let V3379 (shen.lazyderef (hd V3378) V3563) (if (= string V3379) (let V3380 (shen.lazyderef (tl V3378) V3563) (if (= () V3380) (let Hyp (tl V3369) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons string ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (if (shen.pvar? V3380) (do (shen.bindv V3380 () V3563) (let Result (let Hyp (tl V3369) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons string ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (do (shen.unbindv V3380 V3563) Result))) false))) (if (shen.pvar? V3379) (do (shen.bindv V3379 string V3563) (let Result (let V3381 (shen.lazyderef (tl V3378) V3563) (if (= () V3381) (let Hyp (tl V3369) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons string ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (if (shen.pvar? V3381) (do (shen.bindv V3381 () V3563) (let Result (let Hyp (tl V3369) (do (shen.incinfs) (bind V3562 (cons (cons (shen.lazyderef X V3563) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3563) (cons : (cons string ()))) (shen.lazyderef Hyp V3563))) V3563 V3564))) (do (shen.unbindv V3381 V3563) Result))) false))) (do (shen.unbindv V3379 V3563) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V3382 (shen.lazyderef V3561 V3563) (if (cons? V3382) (let X (hd V3382) (let Hyp (tl V3382) (let NewHyps (shen.newpv V3563) (do (shen.incinfs) (bind V3562 (cons (shen.lazyderef X V3563) (shen.lazyderef NewHyps V3563)) V3563 (freeze (shen.t*-hyps Hyp NewHyps V3563 V3564))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V3581 V3582 V3583 V3584) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V3581 V3583)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V3582 V3583) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V3584))))))))) (true (thaw V3584))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V3586) (cond ((and (cons? V3586) (and (cons? (tl V3586)) (and (= : (hd (tl V3586))) (and (cons? (tl (tl V3586))) (= () (tl (tl (tl V3586)))))))) (shen.prhush (shen.app (hd V3586) (cn " : " (shen.app (hd (tl (tl V3586))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V3586 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V3591 V3592) (cond ((= () V3591) shen.skip) ((cons? V3591) (do (shen.prhush (shen.app V3592 ". " shen.a) (stoutput)) (do (shen.show-p (hd V3591)) (do (nl 1) (shen.show-assumptions (tl V3591) (+ V3592 1)))))) (true (shen.f_error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V3594) (cons? (assoc V3594 (value shen.*signedfuncs*))))

(defun shen.sigf (V3596) (concat shen.type-signature-of- V3596))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V3601 V3602 V3603 V3604) (let Case (let V3285 (shen.lazyderef V3602 V3603) (if (= number V3285) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3601 V3603)) V3603 V3604)) (if (shen.pvar? V3285) (do (shen.bindv V3285 number V3603) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3601 V3603)) V3603 V3604)) (do (shen.unbindv V3285 V3603) Result))) false))) (if (= Case false) (let Case (let V3286 (shen.lazyderef V3602 V3603) (if (= boolean V3286) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3601 V3603)) V3603 V3604)) (if (shen.pvar? V3286) (do (shen.bindv V3286 boolean V3603) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3601 V3603)) V3603 V3604)) (do (shen.unbindv V3286 V3603) Result))) false))) (if (= Case false) (let Case (let V3287 (shen.lazyderef V3602 V3603) (if (= string V3287) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3601 V3603)) V3603 V3604)) (if (shen.pvar? V3287) (do (shen.bindv V3287 string V3603) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3601 V3603)) V3603 V3604)) (do (shen.unbindv V3287 V3603) Result))) false))) (if (= Case false) (let Case (let V3288 (shen.lazyderef V3602 V3603) (if (= symbol V3288) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3601 V3603)) V3603 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3601 V3603))) V3603 V3604)))) (if (shen.pvar? V3288) (do (shen.bindv V3288 symbol V3603) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3601 V3603)) V3603 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3601 V3603))) V3603 V3604)))) (do (shen.unbindv V3288 V3603) Result))) false))) (if (= Case false) (let V3289 (shen.lazyderef V3601 V3603) (if (= () V3289) (let V3290 (shen.lazyderef V3602 V3603) (if (cons? V3290) (let V3291 (shen.lazyderef (hd V3290) V3603) (if (= list V3291) (let V3292 (shen.lazyderef (tl V3290) V3603) (if (cons? V3292) (let A (hd V3292) (let V3293 (shen.lazyderef (tl V3292) V3603) (if (= () V3293) (do (shen.incinfs) (thaw V3604)) (if (shen.pvar? V3293) (do (shen.bindv V3293 () V3603) (let Result (do (shen.incinfs) (thaw V3604)) (do (shen.unbindv V3293 V3603) Result))) false)))) (if (shen.pvar? V3292) (let A (shen.newpv V3603) (do (shen.bindv V3292 (cons A ()) V3603) (let Result (do (shen.incinfs) (thaw V3604)) (do (shen.unbindv V3292 V3603) Result)))) false))) (if (shen.pvar? V3291) (do (shen.bindv V3291 list V3603) (let Result (let V3294 (shen.lazyderef (tl V3290) V3603) (if (cons? V3294) (let A (hd V3294) (let V3295 (shen.lazyderef (tl V3294) V3603) (if (= () V3295) (do (shen.incinfs) (thaw V3604)) (if (shen.pvar? V3295) (do (shen.bindv V3295 () V3603) (let Result (do (shen.incinfs) (thaw V3604)) (do (shen.unbindv V3295 V3603) Result))) false)))) (if (shen.pvar? V3294) (let A (shen.newpv V3603) (do (shen.bindv V3294 (cons A ()) V3603) (let Result (do (shen.incinfs) (thaw V3604)) (do (shen.unbindv V3294 V3603) Result)))) false))) (do (shen.unbindv V3291 V3603) Result))) false))) (if (shen.pvar? V3290) (let A (shen.newpv V3603) (do (shen.bindv V3290 (cons list (cons A ())) V3603) (let Result (do (shen.incinfs) (thaw V3604)) (do (shen.unbindv V3290 V3603) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V3610 V3611 V3612 V3613 V3614) (let Case (let V3276 (shen.lazyderef V3612 V3613) (if (cons? V3276) (let V3277 (shen.lazyderef (hd V3276) V3613) (if (cons? V3277) (let Y (hd V3277) (let V3278 (shen.lazyderef (tl V3277) V3613) (if (cons? V3278) (let V3279 (shen.lazyderef (hd V3278) V3613) (if (= : V3279) (let V3280 (shen.lazyderef (tl V3278) V3613) (if (cons? V3280) (let B (hd V3280) (let V3281 (shen.lazyderef (tl V3280) V3613) (if (= () V3281) (do (shen.incinfs) (identical V3610 Y V3613 (freeze (unify! V3611 B V3613 V3614)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V3282 (shen.lazyderef V3612 V3613) (if (cons? V3282) (let Hyp (tl V3282) (do (shen.incinfs) (shen.by_hypothesis V3610 V3611 Hyp V3613 V3614))) false)) Case)))

(defun shen.t*-def (V3620 V3621 V3622 V3623 V3624) (let V3270 (shen.lazyderef V3620 V3623) (if (cons? V3270) (let V3271 (shen.lazyderef (hd V3270) V3623) (if (= define V3271) (let V3272 (shen.lazyderef (tl V3270) V3623) (if (cons? V3272) (let F (hd V3272) (let X (tl V3272) (let Y (shen.newpv V3623) (let E (shen.newpv V3623) (do (shen.incinfs) (shen.t*-defh (compile (lambda Y (shen.<sig+rules> Y)) X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V3621 V3622 V3623 V3624)))))) false)) false)) false)))

(defun shen.t*-defh (V3631 V3632 V3633 V3634 V3635 V3636) (let V3266 (shen.lazyderef V3631 V3635) (if (cons? V3266) (let Sig (hd V3266) (let Rules (tl V3266) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V3632 V3633 V3634 Rules V3635 V3636)))) false)))

(defun shen.t*-defhh (V3645 V3646 V3647 V3648 V3649 V3650 V3651 V3652) (do (shen.incinfs) (shen.t*-rules V3650 V3646 1 V3647 (cons (cons V3647 (cons : (cons V3646 ()))) V3649) V3651 (freeze (shen.memo V3647 V3645 V3648 V3651 V3652)))))

(defun shen.memo (V3658 V3659 V3660 V3661 V3662) (let Jnk (shen.newpv V3661) (do (shen.incinfs) (unify! V3660 V3659 V3661 (freeze (bind Jnk (declare (shen.lazyderef V3658 V3661) (shen.lazyderef V3660 V3661)) V3661 V3662))))))

(defun shen.<sig+rules> (V3664) (let Parse_shen.<signature> (shen.<signature> V3664) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))))

(defun shen.<non-ll-rules> (V3666) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V3666) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<rule>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V3666) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.hdtl Parse_shen.<rule>) ())) (fail))) YaccParse)))

(defun shen.ue (V3668) (cond ((and (cons? V3668) (and (cons? (tl V3668)) (and (= () (tl (tl V3668))) (= (hd V3668) protect)))) V3668) ((cons? V3668) (map (lambda Z (shen.ue Z)) V3668)) ((variable? V3668) (concat && V3668)) (true V3668)))

(defun shen.ue-sig (V3670) (cond ((cons? V3670) (map (lambda Z (shen.ue-sig Z)) V3670)) ((variable? V3670) (concat &&& V3670)) (true V3670)))

(defun shen.ues (V3676) (cond ((shen.ue? V3676) (cons V3676 ())) ((cons? V3676) (union (shen.ues (hd V3676)) (shen.ues (tl V3676)))) (true ())))

(defun shen.ue? (V3678) (and (symbol? V3678) (shen.ue-h? (str V3678))))

(defun shen.ue-h? (V3686) (cond ((and (shen.+string? V3686) (and (= "&" (pos V3686 0)) (and (shen.+string? (tlstr V3686)) (= "&" (pos (tlstr V3686) 0))))) true) (true false)))

(defun shen.t*-rules (V3694 V3695 V3696 V3697 V3698 V3699 V3700) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3250 (shen.lazyderef V3694 V3699) (if (= () V3250) (do (shen.incinfs) (thaw V3700)) false)) (if (= Case false) (let Case (let V3251 (shen.lazyderef V3694 V3699) (if (cons? V3251) (let Rule (hd V3251) (let Rules (tl V3251) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V3695 V3698 V3699 (freeze (cut Throwcontrol V3699 (freeze (shen.t*-rules Rules V3695 (+ V3696 1) V3697 V3698 V3699 V3700)))))))) false)) (if (= Case false) (let Err (shen.newpv V3699) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V3696 V3699) (cn " of " (shen.app (shen.lazyderef V3697 V3699) "" shen.a)) shen.a))) V3699 V3700))) Case)) Case)))))

(defun shen.t*-rule (V3706 V3707 V3708 V3709 V3710) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V3242 (shen.lazyderef V3706 V3709) (if (cons? V3242) (let Patterns (hd V3242) (let V3243 (shen.lazyderef (tl V3242) V3709) (if (cons? V3243) (let Action (hd V3243) (let V3244 (shen.lazyderef (tl V3243) V3709) (if (= () V3244) (let NewHyps (shen.newpv V3709) (do (shen.incinfs) (shen.newhyps (shen.placeholders Patterns) V3708 NewHyps V3709 (freeze (shen.t*-patterns Patterns V3707 NewHyps V3709 (freeze (cut Throwcontrol V3709 (freeze (shen.t*-action (shen.curry (shen.ue Action)) (shen.result-type Patterns V3707) (shen.patthyps Patterns V3707 V3708) V3709 V3710))))))))) false))) false))) false)))))

(defun shen.placeholders (V3716) (cond ((shen.ue? V3716) (cons V3716 ())) ((cons? V3716) (union (shen.placeholders (hd V3716)) (shen.placeholders (tl V3716)))) (true ())))

(defun shen.newhyps (V3722 V3723 V3724 V3725 V3726) (let Case (let V3229 (shen.lazyderef V3722 V3725) (if (= () V3229) (do (shen.incinfs) (unify! V3724 V3723 V3725 V3726)) false)) (if (= Case false) (let V3230 (shen.lazyderef V3722 V3725) (if (cons? V3230) (let V3225 (hd V3230) (let Vs (tl V3230) (let V3231 (shen.lazyderef V3724 V3725) (if (cons? V3231) (let V3232 (shen.lazyderef (hd V3231) V3725) (if (cons? V3232) (let V (hd V3232) (let V3233 (shen.lazyderef (tl V3232) V3725) (if (cons? V3233) (let V3234 (shen.lazyderef (hd V3233) V3725) (if (= : V3234) (let V3235 (shen.lazyderef (tl V3233) V3725) (if (cons? V3235) (let A (hd V3235) (let V3236 (shen.lazyderef (tl V3235) V3725) (if (= () V3236) (let NewHyp (tl V3231) (do (shen.incinfs) (unify! V V3225 V3725 (freeze (shen.newhyps Vs V3723 NewHyp V3725 V3726))))) (if (shen.pvar? V3236) (do (shen.bindv V3236 () V3725) (let Result (let NewHyp (tl V3231) (do (shen.incinfs) (unify! V V3225 V3725 (freeze (shen.newhyps Vs V3723 NewHyp V3725 V3726))))) (do (shen.unbindv V3236 V3725) Result))) false)))) (if (shen.pvar? V3235) (let A (shen.newpv V3725) (do (shen.bindv V3235 (cons A ()) V3725) (let Result (let NewHyp (tl V3231) (do (shen.incinfs) (unify! V V3225 V3725 (freeze (shen.newhyps Vs V3723 NewHyp V3725 V3726))))) (do (shen.unbindv V3235 V3725) Result)))) false))) (if (shen.pvar? V3234) (do (shen.bindv V3234 : V3725) (let Result (let V3237 (shen.lazyderef (tl V3233) V3725) (if (cons? V3237) (let A (hd V3237) (let V3238 (shen.lazyderef (tl V3237) V3725) (if (= () V3238) (let NewHyp (tl V3231) (do (shen.incinfs) (unify! V V3225 V3725 (freeze (shen.newhyps Vs V3723 NewHyp V3725 V3726))))) (if (shen.pvar? V3238) (do (shen.bindv V3238 () V3725) (let Result (let NewHyp (tl V3231) (do (shen.incinfs) (unify! V V3225 V3725 (freeze (shen.newhyps Vs V3723 NewHyp V3725 V3726))))) (do (shen.unbindv V3238 V3725) Result))) false)))) (if (shen.pvar? V3237) (let A (shen.newpv V3725) (do (shen.bindv V3237 (cons A ()) V3725) (let Result (let NewHyp (tl V3231) (do (shen.incinfs) (unify! V V3225 V3725 (freeze (shen.newhyps Vs V3723 NewHyp V3725 V3726))))) (do (shen.unbindv V3237 V3725) Result)))) false))) (do (shen.unbindv V3234 V3725) Result))) false))) (if (shen.pvar? V3233) (let A (shen.newpv V3725) (do (shen.bindv V3233 (cons : (cons A ())) V3725) (let Result (let NewHyp (tl V3231) (do (shen.incinfs) (unify! V V3225 V3725 (freeze (shen.newhyps Vs V3723 NewHyp V3725 V3726))))) (do (shen.unbindv V3233 V3725) Result)))) false)))) (if (shen.pvar? V3232) (let V (shen.newpv V3725) (let A (shen.newpv V3725) (do (shen.bindv V3232 (cons V (cons : (cons A ()))) V3725) (let Result (let NewHyp (tl V3231) (do (shen.incinfs) (unify! V V3225 V3725 (freeze (shen.newhyps Vs V3723 NewHyp V3725 V3726))))) (do (shen.unbindv V3232 V3725) Result))))) false))) (if (shen.pvar? V3231) (let V (shen.newpv V3725) (let A (shen.newpv V3725) (let NewHyp (shen.newpv V3725) (do (shen.bindv V3231 (cons (cons V (cons : (cons A ()))) NewHyp) V3725) (let Result (do (shen.incinfs) (unify! V V3225 V3725 (freeze (shen.newhyps Vs V3723 NewHyp V3725 V3726)))) (do (shen.unbindv V3231 V3725) Result)))))) false))))) false)) Case)))

(defun shen.patthyps (V3732 V3733 V3734) (cond ((= () V3732) V3734) ((and (cons? V3732) (and (cons? V3733) (and (cons? (tl V3733)) (and (= --> (hd (tl V3733))) (and (cons? (tl (tl V3733))) (= () (tl (tl (tl V3733))))))))) (adjoin (cons (hd V3732) (cons : (cons (hd V3733) ()))) (shen.patthyps (tl V3732) (hd (tl (tl V3733))) V3734))) (true (shen.f_error shen.patthyps))))

(defun shen.result-type (V3741 V3742) (cond ((and (= () V3741) (and (cons? V3742) (and (= --> (hd V3742)) (and (cons? (tl V3742)) (= () (tl (tl V3742))))))) (hd (tl V3742))) ((= () V3741) V3742) ((and (cons? V3741) (and (cons? V3742) (and (cons? (tl V3742)) (and (= --> (hd (tl V3742))) (and (cons? (tl (tl V3742))) (= () (tl (tl (tl V3742))))))))) (shen.result-type (tl V3741) (hd (tl (tl V3742))))) (true (shen.f_error shen.result-type))))

(defun shen.t*-patterns (V3748 V3749 V3750 V3751 V3752) (let Case (let V3217 (shen.lazyderef V3748 V3751) (if (= () V3217) (do (shen.incinfs) (thaw V3752)) false)) (if (= Case false) (let V3218 (shen.lazyderef V3748 V3751) (if (cons? V3218) (let Pattern (hd V3218) (let Patterns (tl V3218) (let V3219 (shen.lazyderef V3749 V3751) (if (cons? V3219) (let A (hd V3219) (let V3220 (shen.lazyderef (tl V3219) V3751) (if (cons? V3220) (let V3221 (shen.lazyderef (hd V3220) V3751) (if (= --> V3221) (let V3222 (shen.lazyderef (tl V3220) V3751) (if (cons? V3222) (let B (hd V3222) (let V3223 (shen.lazyderef (tl V3222) V3751) (if (= () V3223) (do (shen.incinfs) (shen.t* (cons Pattern (cons : (cons A ()))) V3750 V3751 (freeze (shen.t*-patterns Patterns B V3750 V3751 V3752)))) false))) false)) false)) false))) false)))) false)) Case)))

(defun shen.t*-action (V3758 V3759 V3760 V3761 V3762) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3194 (shen.lazyderef V3758 V3761) (if (cons? V3194) (let V3195 (shen.lazyderef (hd V3194) V3761) (if (= where V3195) (let V3196 (shen.lazyderef (tl V3194) V3761) (if (cons? V3196) (let P (hd V3196) (let V3197 (shen.lazyderef (tl V3196) V3761) (if (cons? V3197) (let Action (hd V3197) (let V3198 (shen.lazyderef (tl V3197) V3761) (if (= () V3198) (do (shen.incinfs) (cut Throwcontrol V3761 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V3760 V3761 (freeze (cut Throwcontrol V3761 (freeze (shen.t*-action Action V3759 (cons (cons P (cons : (cons verified ()))) V3760) V3761 V3762)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3199 (shen.lazyderef V3758 V3761) (if (cons? V3199) (let V3200 (shen.lazyderef (hd V3199) V3761) (if (= shen.choicepoint! V3200) (let V3201 (shen.lazyderef (tl V3199) V3761) (if (cons? V3201) (let V3202 (shen.lazyderef (hd V3201) V3761) (if (cons? V3202) (let V3203 (shen.lazyderef (hd V3202) V3761) (if (cons? V3203) (let V3204 (shen.lazyderef (hd V3203) V3761) (if (= fail-if V3204) (let V3205 (shen.lazyderef (tl V3203) V3761) (if (cons? V3205) (let F (hd V3205) (let V3206 (shen.lazyderef (tl V3205) V3761) (if (= () V3206) (let V3207 (shen.lazyderef (tl V3202) V3761) (if (cons? V3207) (let Action (hd V3207) (let V3208 (shen.lazyderef (tl V3207) V3761) (if (= () V3208) (let V3209 (shen.lazyderef (tl V3201) V3761) (if (= () V3209) (do (shen.incinfs) (cut Throwcontrol V3761 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V3759 V3760 V3761 V3762)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3210 (shen.lazyderef V3758 V3761) (if (cons? V3210) (let V3211 (shen.lazyderef (hd V3210) V3761) (if (= shen.choicepoint! V3211) (let V3212 (shen.lazyderef (tl V3210) V3761) (if (cons? V3212) (let Action (hd V3212) (let V3213 (shen.lazyderef (tl V3212) V3761) (if (= () V3213) (do (shen.incinfs) (cut Throwcontrol V3761 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V3759 V3760 V3761 V3762)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V3758 (cons : (cons V3759 ()))) V3760 V3761 V3762)) Case)) Case)) Case)))))

(defun findall (V3768 V3769 V3770 V3771 V3772) (let B (shen.newpv V3771) (let A (shen.newpv V3771) (do (shen.incinfs) (bind A (gensym shen.a) V3771 (freeze (bind B (set (shen.lazyderef A V3771) ()) V3771 (freeze (shen.findallhelp V3768 V3769 V3770 A V3771 V3772)))))))))

(defun shen.findallhelp (V3779 V3780 V3781 V3782 V3783 V3784) (let Case (do (shen.incinfs) (call V3780 V3783 (freeze (shen.remember V3782 V3779 V3783 (freeze (fwhen false V3783 V3784)))))) (if (= Case false) (do (shen.incinfs) (bind V3781 (value (shen.lazyderef V3782 V3783)) V3783 V3784)) Case)))

(defun shen.remember (V3789 V3790 V3791 V3792) (let B (shen.newpv V3791) (do (shen.incinfs) (bind B (set (shen.deref V3789 V3791) (cons (shen.deref V3790 V3791) (value (shen.deref V3789 V3791)))) V3791 V3792))))



