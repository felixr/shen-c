"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.typecheck (V3380 V3381) (let Curry (shen.curry V3380) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V3381)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V3383) (cond ((and (cons? V3383) (shen.special? (hd V3383))) (cons (hd V3383) (map (lambda Y (shen.curry Y)) (tl V3383)))) ((and (cons? V3383) (and (cons? (tl V3383)) (shen.extraspecial? (hd V3383)))) V3383) ((and (cons? V3383) (and (= type (hd V3383)) (and (cons? (tl V3383)) (and (cons? (tl (tl V3383))) (= () (tl (tl (tl V3383)))))))) (cons type (cons (shen.curry (hd (tl V3383))) (tl (tl V3383))))) ((and (cons? V3383) (and (cons? (tl V3383)) (cons? (tl (tl V3383))))) (shen.curry (cons (cons (hd V3383) (cons (hd (tl V3383)) ())) (tl (tl V3383))))) ((and (cons? V3383) (and (cons? (tl V3383)) (= () (tl (tl V3383))))) (cons (shen.curry (hd V3383)) (cons (shen.curry (hd (tl V3383))) ()))) (true V3383)))

(defun shen.special? (V3385) (element? V3385 (value shen.*special*)))

(defun shen.extraspecial? (V3387) (element? V3387 (value shen.*extraspecial*)))

(defun shen.t* (V3392 V3393 V3394 V3395) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V3394) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V3394 (freeze (bind Error (shen.errormaxinfs) V3394 V3395))))) (if (= Case false) (let Case (let V3372 (shen.lazyderef V3392 V3394) (if (= fail V3372) (do (shen.incinfs) (cut Throwcontrol V3394 (freeze (shen.prolog-failure V3394 V3395)))) false)) (if (= Case false) (let Case (let V3373 (shen.lazyderef V3392 V3394) (if (cons? V3373) (let X (hd V3373) (let V3374 (shen.lazyderef (tl V3373) V3394) (if (cons? V3374) (let V3375 (shen.lazyderef (hd V3374) V3394) (if (= : V3375) (let V3376 (shen.lazyderef (tl V3374) V3394) (if (cons? V3376) (let A (hd V3376) (let V3377 (shen.lazyderef (tl V3376) V3394) (if (= () V3377) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V3394 (freeze (cut Throwcontrol V3394 (freeze (shen.th* X A V3393 V3394 V3395)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V3394) (do (shen.incinfs) (shen.show V3392 V3393 V3394 (freeze (bind Datatypes (value shen.*datatypes*) V3394 (freeze (shen.udefs* V3392 V3393 Datatypes V3394 V3395))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V3401) (cond ((= + V3401) (set shen.*shen-type-theory-enabled?* true)) ((= - V3401) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V3412 V3413) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V3419 V3420 V3421 V3422 V3423) (let Case (let V3368 (shen.lazyderef V3421 V3422) (if (cons? V3368) (let D (hd V3368) (do (shen.incinfs) (call (cons D (cons V3419 (cons V3420 ()))) V3422 V3423))) false)) (if (= Case false) (let V3369 (shen.lazyderef V3421 V3422) (if (cons? V3369) (let Ds (tl V3369) (do (shen.incinfs) (shen.udefs* V3419 V3420 Ds V3422 V3423))) false)) Case)))

(defun shen.th* (V3429 V3430 V3431 V3432 V3433) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V3429 (cons : (cons V3430 ()))) V3431 V3432 (freeze (fwhen false V3432 V3433)))) (if (= Case false) (let Case (let F (shen.newpv V3432) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V3429 V3432)) V3432 (freeze (bind F (shen.sigf (shen.lazyderef V3429 V3432)) V3432 (freeze (call (cons F (cons V3430 ())) V3432 V3433))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V3429 V3430 V3432 V3433)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V3429 V3430 V3431 V3432 V3433)) (if (= Case false) (let Case (let V3264 (shen.lazyderef V3429 V3432) (if (cons? V3264) (let F (hd V3264) (let V3265 (shen.lazyderef (tl V3264) V3432) (if (= () V3265) (do (shen.incinfs) (shen.th* F (cons --> (cons V3430 ())) V3431 V3432 V3433)) false))) false)) (if (= Case false) (let Case (let V3266 (shen.lazyderef V3429 V3432) (if (cons? V3266) (let F (hd V3266) (let V3267 (shen.lazyderef (tl V3266) V3432) (if (cons? V3267) (let X (hd V3267) (let V3268 (shen.lazyderef (tl V3267) V3432) (if (= () V3268) (let B (shen.newpv V3432) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V3430 ()))) V3431 V3432 (freeze (shen.th* X B V3431 V3432 V3433))))) false))) false))) false)) (if (= Case false) (let Case (let V3269 (shen.lazyderef V3429 V3432) (if (cons? V3269) (let V3270 (shen.lazyderef (hd V3269) V3432) (if (= cons V3270) (let V3271 (shen.lazyderef (tl V3269) V3432) (if (cons? V3271) (let X (hd V3271) (let V3272 (shen.lazyderef (tl V3271) V3432) (if (cons? V3272) (let Y (hd V3272) (let V3273 (shen.lazyderef (tl V3272) V3432) (if (= () V3273) (let V3274 (shen.lazyderef V3430 V3432) (if (cons? V3274) (let V3275 (shen.lazyderef (hd V3274) V3432) (if (= list V3275) (let V3276 (shen.lazyderef (tl V3274) V3432) (if (cons? V3276) (let A (hd V3276) (let V3277 (shen.lazyderef (tl V3276) V3432) (if (= () V3277) (do (shen.incinfs) (shen.th* X A V3431 V3432 (freeze (shen.th* Y (cons list (cons A ())) V3431 V3432 V3433)))) (if (shen.pvar? V3277) (do (shen.bindv V3277 () V3432) (let Result (do (shen.incinfs) (shen.th* X A V3431 V3432 (freeze (shen.th* Y (cons list (cons A ())) V3431 V3432 V3433)))) (do (shen.unbindv V3277 V3432) Result))) false)))) (if (shen.pvar? V3276) (let A (shen.newpv V3432) (do (shen.bindv V3276 (cons A ()) V3432) (let Result (do (shen.incinfs) (shen.th* X A V3431 V3432 (freeze (shen.th* Y (cons list (cons A ())) V3431 V3432 V3433)))) (do (shen.unbindv V3276 V3432) Result)))) false))) (if (shen.pvar? V3275) (do (shen.bindv V3275 list V3432) (let Result (let V3278 (shen.lazyderef (tl V3274) V3432) (if (cons? V3278) (let A (hd V3278) (let V3279 (shen.lazyderef (tl V3278) V3432) (if (= () V3279) (do (shen.incinfs) (shen.th* X A V3431 V3432 (freeze (shen.th* Y (cons list (cons A ())) V3431 V3432 V3433)))) (if (shen.pvar? V3279) (do (shen.bindv V3279 () V3432) (let Result (do (shen.incinfs) (shen.th* X A V3431 V3432 (freeze (shen.th* Y (cons list (cons A ())) V3431 V3432 V3433)))) (do (shen.unbindv V3279 V3432) Result))) false)))) (if (shen.pvar? V3278) (let A (shen.newpv V3432) (do (shen.bindv V3278 (cons A ()) V3432) (let Result (do (shen.incinfs) (shen.th* X A V3431 V3432 (freeze (shen.th* Y (cons list (cons A ())) V3431 V3432 V3433)))) (do (shen.unbindv V3278 V3432) Result)))) false))) (do (shen.unbindv V3275 V3432) Result))) false))) (if (shen.pvar? V3274) (let A (shen.newpv V3432) (do (shen.bindv V3274 (cons list (cons A ())) V3432) (let Result (do (shen.incinfs) (shen.th* X A V3431 V3432 (freeze (shen.th* Y (cons list (cons A ())) V3431 V3432 V3433)))) (do (shen.unbindv V3274 V3432) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3280 (shen.lazyderef V3429 V3432) (if (cons? V3280) (let V3281 (shen.lazyderef (hd V3280) V3432) (if (= @p V3281) (let V3282 (shen.lazyderef (tl V3280) V3432) (if (cons? V3282) (let X (hd V3282) (let V3283 (shen.lazyderef (tl V3282) V3432) (if (cons? V3283) (let Y (hd V3283) (let V3284 (shen.lazyderef (tl V3283) V3432) (if (= () V3284) (let V3285 (shen.lazyderef V3430 V3432) (if (cons? V3285) (let A (hd V3285) (let V3286 (shen.lazyderef (tl V3285) V3432) (if (cons? V3286) (let V3287 (shen.lazyderef (hd V3286) V3432) (if (= * V3287) (let V3288 (shen.lazyderef (tl V3286) V3432) (if (cons? V3288) (let B (hd V3288) (let V3289 (shen.lazyderef (tl V3288) V3432) (if (= () V3289) (do (shen.incinfs) (shen.th* X A V3431 V3432 (freeze (shen.th* Y B V3431 V3432 V3433)))) (if (shen.pvar? V3289) (do (shen.bindv V3289 () V3432) (let Result (do (shen.incinfs) (shen.th* X A V3431 V3432 (freeze (shen.th* Y B V3431 V3432 V3433)))) (do (shen.unbindv V3289 V3432) Result))) false)))) (if (shen.pvar? V3288) (let B (shen.newpv V3432) (do (shen.bindv V3288 (cons B ()) V3432) (let Result (do (shen.incinfs) (shen.th* X A V3431 V3432 (freeze (shen.th* Y B V3431 V3432 V3433)))) (do (shen.unbindv V3288 V3432) Result)))) false))) (if (shen.pvar? V3287) (do (shen.bindv V3287 * V3432) (let Result (let V3290 (shen.lazyderef (tl V3286) V3432) (if (cons? V3290) (let B (hd V3290) (let V3291 (shen.lazyderef (tl V3290) V3432) (if (= () V3291) (do (shen.incinfs) (shen.th* X A V3431 V3432 (freeze (shen.th* Y B V3431 V3432 V3433)))) (if (shen.pvar? V3291) (do (shen.bindv V3291 () V3432) (let Result (do (shen.incinfs) (shen.th* X A V3431 V3432 (freeze (shen.th* Y B V3431 V3432 V3433)))) (do (shen.unbindv V3291 V3432) Result))) false)))) (if (shen.pvar? V3290) (let B (shen.newpv V3432) (do (shen.bindv V3290 (cons B ()) V3432) (let Result (do (shen.incinfs) (shen.th* X A V3431 V3432 (freeze (shen.th* Y B V3431 V3432 V3433)))) (do (shen.unbindv V3290 V3432) Result)))) false))) (do (shen.unbindv V3287 V3432) Result))) false))) (if (shen.pvar? V3286) (let B (shen.newpv V3432) (do (shen.bindv V3286 (cons * (cons B ())) V3432) (let Result (do (shen.incinfs) (shen.th* X A V3431 V3432 (freeze (shen.th* Y B V3431 V3432 V3433)))) (do (shen.unbindv V3286 V3432) Result)))) false)))) (if (shen.pvar? V3285) (let A (shen.newpv V3432) (let B (shen.newpv V3432) (do (shen.bindv V3285 (cons A (cons * (cons B ()))) V3432) (let Result (do (shen.incinfs) (shen.th* X A V3431 V3432 (freeze (shen.th* Y B V3431 V3432 V3433)))) (do (shen.unbindv V3285 V3432) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3292 (shen.lazyderef V3429 V3432) (if (cons? V3292) (let V3293 (shen.lazyderef (hd V3292) V3432) (if (= @v V3293) (let V3294 (shen.lazyderef (tl V3292) V3432) (if (cons? V3294) (let X (hd V3294) (let V3295 (shen.lazyderef (tl V3294) V3432) (if (cons? V3295) (let Y (hd V3295) (let V3296 (shen.lazyderef (tl V3295) V3432) (if (= () V3296) (let V3297 (shen.lazyderef V3430 V3432) (if (cons? V3297) (let V3298 (shen.lazyderef (hd V3297) V3432) (if (= vector V3298) (let V3299 (shen.lazyderef (tl V3297) V3432) (if (cons? V3299) (let A (hd V3299) (let V3300 (shen.lazyderef (tl V3299) V3432) (if (= () V3300) (do (shen.incinfs) (shen.th* X A V3431 V3432 (freeze (shen.th* Y (cons vector (cons A ())) V3431 V3432 V3433)))) (if (shen.pvar? V3300) (do (shen.bindv V3300 () V3432) (let Result (do (shen.incinfs) (shen.th* X A V3431 V3432 (freeze (shen.th* Y (cons vector (cons A ())) V3431 V3432 V3433)))) (do (shen.unbindv V3300 V3432) Result))) false)))) (if (shen.pvar? V3299) (let A (shen.newpv V3432) (do (shen.bindv V3299 (cons A ()) V3432) (let Result (do (shen.incinfs) (shen.th* X A V3431 V3432 (freeze (shen.th* Y (cons vector (cons A ())) V3431 V3432 V3433)))) (do (shen.unbindv V3299 V3432) Result)))) false))) (if (shen.pvar? V3298) (do (shen.bindv V3298 vector V3432) (let Result (let V3301 (shen.lazyderef (tl V3297) V3432) (if (cons? V3301) (let A (hd V3301) (let V3302 (shen.lazyderef (tl V3301) V3432) (if (= () V3302) (do (shen.incinfs) (shen.th* X A V3431 V3432 (freeze (shen.th* Y (cons vector (cons A ())) V3431 V3432 V3433)))) (if (shen.pvar? V3302) (do (shen.bindv V3302 () V3432) (let Result (do (shen.incinfs) (shen.th* X A V3431 V3432 (freeze (shen.th* Y (cons vector (cons A ())) V3431 V3432 V3433)))) (do (shen.unbindv V3302 V3432) Result))) false)))) (if (shen.pvar? V3301) (let A (shen.newpv V3432) (do (shen.bindv V3301 (cons A ()) V3432) (let Result (do (shen.incinfs) (shen.th* X A V3431 V3432 (freeze (shen.th* Y (cons vector (cons A ())) V3431 V3432 V3433)))) (do (shen.unbindv V3301 V3432) Result)))) false))) (do (shen.unbindv V3298 V3432) Result))) false))) (if (shen.pvar? V3297) (let A (shen.newpv V3432) (do (shen.bindv V3297 (cons vector (cons A ())) V3432) (let Result (do (shen.incinfs) (shen.th* X A V3431 V3432 (freeze (shen.th* Y (cons vector (cons A ())) V3431 V3432 V3433)))) (do (shen.unbindv V3297 V3432) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3303 (shen.lazyderef V3429 V3432) (if (cons? V3303) (let V3304 (shen.lazyderef (hd V3303) V3432) (if (= @s V3304) (let V3305 (shen.lazyderef (tl V3303) V3432) (if (cons? V3305) (let X (hd V3305) (let V3306 (shen.lazyderef (tl V3305) V3432) (if (cons? V3306) (let Y (hd V3306) (let V3307 (shen.lazyderef (tl V3306) V3432) (if (= () V3307) (let V3308 (shen.lazyderef V3430 V3432) (if (= string V3308) (do (shen.incinfs) (shen.th* X string V3431 V3432 (freeze (shen.th* Y string V3431 V3432 V3433)))) (if (shen.pvar? V3308) (do (shen.bindv V3308 string V3432) (let Result (do (shen.incinfs) (shen.th* X string V3431 V3432 (freeze (shen.th* Y string V3431 V3432 V3433)))) (do (shen.unbindv V3308 V3432) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3309 (shen.lazyderef V3429 V3432) (if (cons? V3309) (let V3310 (shen.lazyderef (hd V3309) V3432) (if (= lambda V3310) (let V3311 (shen.lazyderef (tl V3309) V3432) (if (cons? V3311) (let X (hd V3311) (let V3312 (shen.lazyderef (tl V3311) V3432) (if (cons? V3312) (let Y (hd V3312) (let V3313 (shen.lazyderef (tl V3312) V3432) (if (= () V3313) (let V3314 (shen.lazyderef V3430 V3432) (if (cons? V3314) (let A (hd V3314) (let V3315 (shen.lazyderef (tl V3314) V3432) (if (cons? V3315) (let V3316 (shen.lazyderef (hd V3315) V3432) (if (= --> V3316) (let V3317 (shen.lazyderef (tl V3315) V3432) (if (cons? V3317) (let B (hd V3317) (let V3318 (shen.lazyderef (tl V3317) V3432) (if (= () V3318) (let Z (shen.newpv V3432) (let X&& (shen.newpv V3432) (do (shen.incinfs) (cut Throwcontrol V3432 (freeze (bind X&& (shen.placeholder) V3432 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3432) (shen.lazyderef X V3432) (shen.lazyderef Y V3432)) V3432 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3431) V3432 V3433)))))))))) (if (shen.pvar? V3318) (do (shen.bindv V3318 () V3432) (let Result (let Z (shen.newpv V3432) (let X&& (shen.newpv V3432) (do (shen.incinfs) (cut Throwcontrol V3432 (freeze (bind X&& (shen.placeholder) V3432 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3432) (shen.lazyderef X V3432) (shen.lazyderef Y V3432)) V3432 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3431) V3432 V3433)))))))))) (do (shen.unbindv V3318 V3432) Result))) false)))) (if (shen.pvar? V3317) (let B (shen.newpv V3432) (do (shen.bindv V3317 (cons B ()) V3432) (let Result (let Z (shen.newpv V3432) (let X&& (shen.newpv V3432) (do (shen.incinfs) (cut Throwcontrol V3432 (freeze (bind X&& (shen.placeholder) V3432 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3432) (shen.lazyderef X V3432) (shen.lazyderef Y V3432)) V3432 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3431) V3432 V3433)))))))))) (do (shen.unbindv V3317 V3432) Result)))) false))) (if (shen.pvar? V3316) (do (shen.bindv V3316 --> V3432) (let Result (let V3319 (shen.lazyderef (tl V3315) V3432) (if (cons? V3319) (let B (hd V3319) (let V3320 (shen.lazyderef (tl V3319) V3432) (if (= () V3320) (let Z (shen.newpv V3432) (let X&& (shen.newpv V3432) (do (shen.incinfs) (cut Throwcontrol V3432 (freeze (bind X&& (shen.placeholder) V3432 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3432) (shen.lazyderef X V3432) (shen.lazyderef Y V3432)) V3432 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3431) V3432 V3433)))))))))) (if (shen.pvar? V3320) (do (shen.bindv V3320 () V3432) (let Result (let Z (shen.newpv V3432) (let X&& (shen.newpv V3432) (do (shen.incinfs) (cut Throwcontrol V3432 (freeze (bind X&& (shen.placeholder) V3432 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3432) (shen.lazyderef X V3432) (shen.lazyderef Y V3432)) V3432 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3431) V3432 V3433)))))))))) (do (shen.unbindv V3320 V3432) Result))) false)))) (if (shen.pvar? V3319) (let B (shen.newpv V3432) (do (shen.bindv V3319 (cons B ()) V3432) (let Result (let Z (shen.newpv V3432) (let X&& (shen.newpv V3432) (do (shen.incinfs) (cut Throwcontrol V3432 (freeze (bind X&& (shen.placeholder) V3432 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3432) (shen.lazyderef X V3432) (shen.lazyderef Y V3432)) V3432 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3431) V3432 V3433)))))))))) (do (shen.unbindv V3319 V3432) Result)))) false))) (do (shen.unbindv V3316 V3432) Result))) false))) (if (shen.pvar? V3315) (let B (shen.newpv V3432) (do (shen.bindv V3315 (cons --> (cons B ())) V3432) (let Result (let Z (shen.newpv V3432) (let X&& (shen.newpv V3432) (do (shen.incinfs) (cut Throwcontrol V3432 (freeze (bind X&& (shen.placeholder) V3432 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3432) (shen.lazyderef X V3432) (shen.lazyderef Y V3432)) V3432 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3431) V3432 V3433)))))))))) (do (shen.unbindv V3315 V3432) Result)))) false)))) (if (shen.pvar? V3314) (let A (shen.newpv V3432) (let B (shen.newpv V3432) (do (shen.bindv V3314 (cons A (cons --> (cons B ()))) V3432) (let Result (let Z (shen.newpv V3432) (let X&& (shen.newpv V3432) (do (shen.incinfs) (cut Throwcontrol V3432 (freeze (bind X&& (shen.placeholder) V3432 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3432) (shen.lazyderef X V3432) (shen.lazyderef Y V3432)) V3432 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3431) V3432 V3433)))))))))) (do (shen.unbindv V3314 V3432) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3321 (shen.lazyderef V3429 V3432) (if (cons? V3321) (let V3322 (shen.lazyderef (hd V3321) V3432) (if (= let V3322) (let V3323 (shen.lazyderef (tl V3321) V3432) (if (cons? V3323) (let X (hd V3323) (let V3324 (shen.lazyderef (tl V3323) V3432) (if (cons? V3324) (let Y (hd V3324) (let V3325 (shen.lazyderef (tl V3324) V3432) (if (cons? V3325) (let Z (hd V3325) (let V3326 (shen.lazyderef (tl V3325) V3432) (if (= () V3326) (let W (shen.newpv V3432) (let X&& (shen.newpv V3432) (let B (shen.newpv V3432) (do (shen.incinfs) (shen.th* Y B V3431 V3432 (freeze (bind X&& (shen.placeholder) V3432 (freeze (bind W (shen.ebr (shen.lazyderef X&& V3432) (shen.lazyderef X V3432) (shen.lazyderef Z V3432)) V3432 (freeze (shen.th* W V3430 (cons (cons X&& (cons : (cons B ()))) V3431) V3432 V3433))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3327 (shen.lazyderef V3429 V3432) (if (cons? V3327) (let V3328 (shen.lazyderef (hd V3327) V3432) (if (= open V3328) (let V3329 (shen.lazyderef (tl V3327) V3432) (if (cons? V3329) (let FileName (hd V3329) (let V3330 (shen.lazyderef (tl V3329) V3432) (if (cons? V3330) (let Direction3260 (hd V3330) (let V3331 (shen.lazyderef (tl V3330) V3432) (if (= () V3331) (let V3332 (shen.lazyderef V3430 V3432) (if (cons? V3332) (let V3333 (shen.lazyderef (hd V3332) V3432) (if (= stream V3333) (let V3334 (shen.lazyderef (tl V3332) V3432) (if (cons? V3334) (let Direction (hd V3334) (let V3335 (shen.lazyderef (tl V3334) V3432) (if (= () V3335) (do (shen.incinfs) (unify! Direction Direction3260 V3432 (freeze (cut Throwcontrol V3432 (freeze (fwhen (element? (shen.lazyderef Direction V3432) (cons in (cons out ()))) V3432 (freeze (shen.th* FileName string V3431 V3432 V3433)))))))) (if (shen.pvar? V3335) (do (shen.bindv V3335 () V3432) (let Result (do (shen.incinfs) (unify! Direction Direction3260 V3432 (freeze (cut Throwcontrol V3432 (freeze (fwhen (element? (shen.lazyderef Direction V3432) (cons in (cons out ()))) V3432 (freeze (shen.th* FileName string V3431 V3432 V3433)))))))) (do (shen.unbindv V3335 V3432) Result))) false)))) (if (shen.pvar? V3334) (let Direction (shen.newpv V3432) (do (shen.bindv V3334 (cons Direction ()) V3432) (let Result (do (shen.incinfs) (unify! Direction Direction3260 V3432 (freeze (cut Throwcontrol V3432 (freeze (fwhen (element? (shen.lazyderef Direction V3432) (cons in (cons out ()))) V3432 (freeze (shen.th* FileName string V3431 V3432 V3433)))))))) (do (shen.unbindv V3334 V3432) Result)))) false))) (if (shen.pvar? V3333) (do (shen.bindv V3333 stream V3432) (let Result (let V3336 (shen.lazyderef (tl V3332) V3432) (if (cons? V3336) (let Direction (hd V3336) (let V3337 (shen.lazyderef (tl V3336) V3432) (if (= () V3337) (do (shen.incinfs) (unify! Direction Direction3260 V3432 (freeze (cut Throwcontrol V3432 (freeze (fwhen (element? (shen.lazyderef Direction V3432) (cons in (cons out ()))) V3432 (freeze (shen.th* FileName string V3431 V3432 V3433)))))))) (if (shen.pvar? V3337) (do (shen.bindv V3337 () V3432) (let Result (do (shen.incinfs) (unify! Direction Direction3260 V3432 (freeze (cut Throwcontrol V3432 (freeze (fwhen (element? (shen.lazyderef Direction V3432) (cons in (cons out ()))) V3432 (freeze (shen.th* FileName string V3431 V3432 V3433)))))))) (do (shen.unbindv V3337 V3432) Result))) false)))) (if (shen.pvar? V3336) (let Direction (shen.newpv V3432) (do (shen.bindv V3336 (cons Direction ()) V3432) (let Result (do (shen.incinfs) (unify! Direction Direction3260 V3432 (freeze (cut Throwcontrol V3432 (freeze (fwhen (element? (shen.lazyderef Direction V3432) (cons in (cons out ()))) V3432 (freeze (shen.th* FileName string V3431 V3432 V3433)))))))) (do (shen.unbindv V3336 V3432) Result)))) false))) (do (shen.unbindv V3333 V3432) Result))) false))) (if (shen.pvar? V3332) (let Direction (shen.newpv V3432) (do (shen.bindv V3332 (cons stream (cons Direction ())) V3432) (let Result (do (shen.incinfs) (unify! Direction Direction3260 V3432 (freeze (cut Throwcontrol V3432 (freeze (fwhen (element? (shen.lazyderef Direction V3432) (cons in (cons out ()))) V3432 (freeze (shen.th* FileName string V3431 V3432 V3433)))))))) (do (shen.unbindv V3332 V3432) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3338 (shen.lazyderef V3429 V3432) (if (cons? V3338) (let V3339 (shen.lazyderef (hd V3338) V3432) (if (= type V3339) (let V3340 (shen.lazyderef (tl V3338) V3432) (if (cons? V3340) (let X (hd V3340) (let V3341 (shen.lazyderef (tl V3340) V3432) (if (cons? V3341) (let A (hd V3341) (let V3342 (shen.lazyderef (tl V3341) V3432) (if (= () V3342) (do (shen.incinfs) (cut Throwcontrol V3432 (freeze (unify A V3430 V3432 (freeze (shen.th* X A V3431 V3432 V3433)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3343 (shen.lazyderef V3429 V3432) (if (cons? V3343) (let V3344 (shen.lazyderef (hd V3343) V3432) (if (= input+ V3344) (let V3345 (shen.lazyderef (tl V3343) V3432) (if (cons? V3345) (let A (hd V3345) (let V3346 (shen.lazyderef (tl V3345) V3432) (if (cons? V3346) (let Stream (hd V3346) (let V3347 (shen.lazyderef (tl V3346) V3432) (if (= () V3347) (let C (shen.newpv V3432) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V3432)) V3432 (freeze (unify V3430 C V3432 (freeze (shen.th* Stream (cons stream (cons in ())) V3431 V3432 V3433))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3348 (shen.lazyderef V3429 V3432) (if (cons? V3348) (let V3349 (shen.lazyderef (hd V3348) V3432) (if (= set V3349) (let V3350 (shen.lazyderef (tl V3348) V3432) (if (cons? V3350) (let Var (hd V3350) (let V3351 (shen.lazyderef (tl V3350) V3432) (if (cons? V3351) (let Val (hd V3351) (let V3352 (shen.lazyderef (tl V3351) V3432) (if (= () V3352) (do (shen.incinfs) (cut Throwcontrol V3432 (freeze (shen.th* Var symbol V3431 V3432 (freeze (cut Throwcontrol V3432 (freeze (shen.th* (cons value (cons Var ())) V3430 V3431 V3432 (freeze (shen.th* Val V3430 V3431 V3432 V3433)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V3432) (do (shen.incinfs) (shen.t*-hyps V3431 NewHyp V3432 (freeze (shen.th* V3429 V3430 NewHyp V3432 V3433))))) (if (= Case false) (let Case (let V3353 (shen.lazyderef V3429 V3432) (if (cons? V3353) (let V3354 (shen.lazyderef (hd V3353) V3432) (if (= define V3354) (let V3355 (shen.lazyderef (tl V3353) V3432) (if (cons? V3355) (let F (hd V3355) (let X (tl V3355) (do (shen.incinfs) (cut Throwcontrol V3432 (freeze (shen.t*-def (cons define (cons F X)) V3430 V3431 V3432 V3433)))))) false)) false)) false)) (if (= Case false) (let Case (let V3356 (shen.lazyderef V3429 V3432) (if (cons? V3356) (let V3357 (shen.lazyderef (hd V3356) V3432) (if (= defmacro V3357) (let V3358 (shen.lazyderef V3430 V3432) (if (= unit V3358) (do (shen.incinfs) (cut Throwcontrol V3432 V3433)) (if (shen.pvar? V3358) (do (shen.bindv V3358 unit V3432) (let Result (do (shen.incinfs) (cut Throwcontrol V3432 V3433)) (do (shen.unbindv V3358 V3432) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3359 (shen.lazyderef V3429 V3432) (if (cons? V3359) (let V3360 (shen.lazyderef (hd V3359) V3432) (if (= shen.process-datatype V3360) (let V3361 (shen.lazyderef V3430 V3432) (if (= symbol V3361) (do (shen.incinfs) (thaw V3433)) (if (shen.pvar? V3361) (do (shen.bindv V3361 symbol V3432) (let Result (do (shen.incinfs) (thaw V3433)) (do (shen.unbindv V3361 V3432) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3362 (shen.lazyderef V3429 V3432) (if (cons? V3362) (let V3363 (shen.lazyderef (hd V3362) V3432) (if (= shen.synonyms-help V3363) (let V3364 (shen.lazyderef V3430 V3432) (if (= symbol V3364) (do (shen.incinfs) (thaw V3433)) (if (shen.pvar? V3364) (do (shen.bindv V3364 symbol V3432) (let Result (do (shen.incinfs) (thaw V3433)) (do (shen.unbindv V3364 V3432) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V3432) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V3432 (freeze (shen.udefs* (cons V3429 (cons : (cons V3430 ()))) V3431 Datatypes V3432 V3433))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V3438 V3439 V3440 V3441) (let Case (let V3175 (shen.lazyderef V3438 V3440) (if (cons? V3175) (let V3176 (shen.lazyderef (hd V3175) V3440) (if (cons? V3176) (let V3177 (shen.lazyderef (hd V3176) V3440) (if (cons? V3177) (let V3178 (shen.lazyderef (hd V3177) V3440) (if (= cons V3178) (let V3179 (shen.lazyderef (tl V3177) V3440) (if (cons? V3179) (let X (hd V3179) (let V3180 (shen.lazyderef (tl V3179) V3440) (if (cons? V3180) (let Y (hd V3180) (let V3181 (shen.lazyderef (tl V3180) V3440) (if (= () V3181) (let V3182 (shen.lazyderef (tl V3176) V3440) (if (cons? V3182) (let V3183 (shen.lazyderef (hd V3182) V3440) (if (= : V3183) (let V3184 (shen.lazyderef (tl V3182) V3440) (if (cons? V3184) (let V3185 (shen.lazyderef (hd V3184) V3440) (if (cons? V3185) (let V3186 (shen.lazyderef (hd V3185) V3440) (if (= list V3186) (let V3187 (shen.lazyderef (tl V3185) V3440) (if (cons? V3187) (let A (hd V3187) (let V3188 (shen.lazyderef (tl V3187) V3440) (if (= () V3188) (let V3189 (shen.lazyderef (tl V3184) V3440) (if (= () V3189) (let Hyp (tl V3175) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons list (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (if (shen.pvar? V3189) (do (shen.bindv V3189 () V3440) (let Result (let Hyp (tl V3175) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons list (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (do (shen.unbindv V3189 V3440) Result))) false))) (if (shen.pvar? V3188) (do (shen.bindv V3188 () V3440) (let Result (let V3190 (shen.lazyderef (tl V3184) V3440) (if (= () V3190) (let Hyp (tl V3175) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons list (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (if (shen.pvar? V3190) (do (shen.bindv V3190 () V3440) (let Result (let Hyp (tl V3175) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons list (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (do (shen.unbindv V3190 V3440) Result))) false))) (do (shen.unbindv V3188 V3440) Result))) false)))) (if (shen.pvar? V3187) (let A (shen.newpv V3440) (do (shen.bindv V3187 (cons A ()) V3440) (let Result (let V3191 (shen.lazyderef (tl V3184) V3440) (if (= () V3191) (let Hyp (tl V3175) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons list (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (if (shen.pvar? V3191) (do (shen.bindv V3191 () V3440) (let Result (let Hyp (tl V3175) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons list (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (do (shen.unbindv V3191 V3440) Result))) false))) (do (shen.unbindv V3187 V3440) Result)))) false))) (if (shen.pvar? V3186) (do (shen.bindv V3186 list V3440) (let Result (let V3192 (shen.lazyderef (tl V3185) V3440) (if (cons? V3192) (let A (hd V3192) (let V3193 (shen.lazyderef (tl V3192) V3440) (if (= () V3193) (let V3194 (shen.lazyderef (tl V3184) V3440) (if (= () V3194) (let Hyp (tl V3175) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons list (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (if (shen.pvar? V3194) (do (shen.bindv V3194 () V3440) (let Result (let Hyp (tl V3175) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons list (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (do (shen.unbindv V3194 V3440) Result))) false))) (if (shen.pvar? V3193) (do (shen.bindv V3193 () V3440) (let Result (let V3195 (shen.lazyderef (tl V3184) V3440) (if (= () V3195) (let Hyp (tl V3175) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons list (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (if (shen.pvar? V3195) (do (shen.bindv V3195 () V3440) (let Result (let Hyp (tl V3175) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons list (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (do (shen.unbindv V3195 V3440) Result))) false))) (do (shen.unbindv V3193 V3440) Result))) false)))) (if (shen.pvar? V3192) (let A (shen.newpv V3440) (do (shen.bindv V3192 (cons A ()) V3440) (let Result (let V3196 (shen.lazyderef (tl V3184) V3440) (if (= () V3196) (let Hyp (tl V3175) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons list (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (if (shen.pvar? V3196) (do (shen.bindv V3196 () V3440) (let Result (let Hyp (tl V3175) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons list (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (do (shen.unbindv V3196 V3440) Result))) false))) (do (shen.unbindv V3192 V3440) Result)))) false))) (do (shen.unbindv V3186 V3440) Result))) false))) (if (shen.pvar? V3185) (let A (shen.newpv V3440) (do (shen.bindv V3185 (cons list (cons A ())) V3440) (let Result (let V3197 (shen.lazyderef (tl V3184) V3440) (if (= () V3197) (let Hyp (tl V3175) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons list (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (if (shen.pvar? V3197) (do (shen.bindv V3197 () V3440) (let Result (let Hyp (tl V3175) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons list (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (do (shen.unbindv V3197 V3440) Result))) false))) (do (shen.unbindv V3185 V3440) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3198 (shen.lazyderef V3438 V3440) (if (cons? V3198) (let V3199 (shen.lazyderef (hd V3198) V3440) (if (cons? V3199) (let V3200 (shen.lazyderef (hd V3199) V3440) (if (cons? V3200) (let V3201 (shen.lazyderef (hd V3200) V3440) (if (= @p V3201) (let V3202 (shen.lazyderef (tl V3200) V3440) (if (cons? V3202) (let X (hd V3202) (let V3203 (shen.lazyderef (tl V3202) V3440) (if (cons? V3203) (let Y (hd V3203) (let V3204 (shen.lazyderef (tl V3203) V3440) (if (= () V3204) (let V3205 (shen.lazyderef (tl V3199) V3440) (if (cons? V3205) (let V3206 (shen.lazyderef (hd V3205) V3440) (if (= : V3206) (let V3207 (shen.lazyderef (tl V3205) V3440) (if (cons? V3207) (let V3208 (shen.lazyderef (hd V3207) V3440) (if (cons? V3208) (let A (hd V3208) (let V3209 (shen.lazyderef (tl V3208) V3440) (if (cons? V3209) (let V3210 (shen.lazyderef (hd V3209) V3440) (if (= * V3210) (let V3211 (shen.lazyderef (tl V3209) V3440) (if (cons? V3211) (let B (hd V3211) (let V3212 (shen.lazyderef (tl V3211) V3440) (if (= () V3212) (let V3213 (shen.lazyderef (tl V3207) V3440) (if (= () V3213) (let Hyp (tl V3198) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (shen.lazyderef B V3440) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (if (shen.pvar? V3213) (do (shen.bindv V3213 () V3440) (let Result (let Hyp (tl V3198) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (shen.lazyderef B V3440) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (do (shen.unbindv V3213 V3440) Result))) false))) (if (shen.pvar? V3212) (do (shen.bindv V3212 () V3440) (let Result (let V3214 (shen.lazyderef (tl V3207) V3440) (if (= () V3214) (let Hyp (tl V3198) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (shen.lazyderef B V3440) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (if (shen.pvar? V3214) (do (shen.bindv V3214 () V3440) (let Result (let Hyp (tl V3198) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (shen.lazyderef B V3440) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (do (shen.unbindv V3214 V3440) Result))) false))) (do (shen.unbindv V3212 V3440) Result))) false)))) (if (shen.pvar? V3211) (let B (shen.newpv V3440) (do (shen.bindv V3211 (cons B ()) V3440) (let Result (let V3215 (shen.lazyderef (tl V3207) V3440) (if (= () V3215) (let Hyp (tl V3198) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (shen.lazyderef B V3440) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (if (shen.pvar? V3215) (do (shen.bindv V3215 () V3440) (let Result (let Hyp (tl V3198) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (shen.lazyderef B V3440) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (do (shen.unbindv V3215 V3440) Result))) false))) (do (shen.unbindv V3211 V3440) Result)))) false))) (if (shen.pvar? V3210) (do (shen.bindv V3210 * V3440) (let Result (let V3216 (shen.lazyderef (tl V3209) V3440) (if (cons? V3216) (let B (hd V3216) (let V3217 (shen.lazyderef (tl V3216) V3440) (if (= () V3217) (let V3218 (shen.lazyderef (tl V3207) V3440) (if (= () V3218) (let Hyp (tl V3198) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (shen.lazyderef B V3440) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (if (shen.pvar? V3218) (do (shen.bindv V3218 () V3440) (let Result (let Hyp (tl V3198) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (shen.lazyderef B V3440) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (do (shen.unbindv V3218 V3440) Result))) false))) (if (shen.pvar? V3217) (do (shen.bindv V3217 () V3440) (let Result (let V3219 (shen.lazyderef (tl V3207) V3440) (if (= () V3219) (let Hyp (tl V3198) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (shen.lazyderef B V3440) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (if (shen.pvar? V3219) (do (shen.bindv V3219 () V3440) (let Result (let Hyp (tl V3198) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (shen.lazyderef B V3440) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (do (shen.unbindv V3219 V3440) Result))) false))) (do (shen.unbindv V3217 V3440) Result))) false)))) (if (shen.pvar? V3216) (let B (shen.newpv V3440) (do (shen.bindv V3216 (cons B ()) V3440) (let Result (let V3220 (shen.lazyderef (tl V3207) V3440) (if (= () V3220) (let Hyp (tl V3198) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (shen.lazyderef B V3440) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (if (shen.pvar? V3220) (do (shen.bindv V3220 () V3440) (let Result (let Hyp (tl V3198) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (shen.lazyderef B V3440) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (do (shen.unbindv V3220 V3440) Result))) false))) (do (shen.unbindv V3216 V3440) Result)))) false))) (do (shen.unbindv V3210 V3440) Result))) false))) (if (shen.pvar? V3209) (let B (shen.newpv V3440) (do (shen.bindv V3209 (cons * (cons B ())) V3440) (let Result (let V3221 (shen.lazyderef (tl V3207) V3440) (if (= () V3221) (let Hyp (tl V3198) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (shen.lazyderef B V3440) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (if (shen.pvar? V3221) (do (shen.bindv V3221 () V3440) (let Result (let Hyp (tl V3198) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (shen.lazyderef B V3440) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (do (shen.unbindv V3221 V3440) Result))) false))) (do (shen.unbindv V3209 V3440) Result)))) false)))) (if (shen.pvar? V3208) (let A (shen.newpv V3440) (let B (shen.newpv V3440) (do (shen.bindv V3208 (cons A (cons * (cons B ()))) V3440) (let Result (let V3222 (shen.lazyderef (tl V3207) V3440) (if (= () V3222) (let Hyp (tl V3198) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (shen.lazyderef B V3440) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (if (shen.pvar? V3222) (do (shen.bindv V3222 () V3440) (let Result (let Hyp (tl V3198) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (shen.lazyderef B V3440) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (do (shen.unbindv V3222 V3440) Result))) false))) (do (shen.unbindv V3208 V3440) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3223 (shen.lazyderef V3438 V3440) (if (cons? V3223) (let V3224 (shen.lazyderef (hd V3223) V3440) (if (cons? V3224) (let V3225 (shen.lazyderef (hd V3224) V3440) (if (cons? V3225) (let V3226 (shen.lazyderef (hd V3225) V3440) (if (= @v V3226) (let V3227 (shen.lazyderef (tl V3225) V3440) (if (cons? V3227) (let X (hd V3227) (let V3228 (shen.lazyderef (tl V3227) V3440) (if (cons? V3228) (let Y (hd V3228) (let V3229 (shen.lazyderef (tl V3228) V3440) (if (= () V3229) (let V3230 (shen.lazyderef (tl V3224) V3440) (if (cons? V3230) (let V3231 (shen.lazyderef (hd V3230) V3440) (if (= : V3231) (let V3232 (shen.lazyderef (tl V3230) V3440) (if (cons? V3232) (let V3233 (shen.lazyderef (hd V3232) V3440) (if (cons? V3233) (let V3234 (shen.lazyderef (hd V3233) V3440) (if (= vector V3234) (let V3235 (shen.lazyderef (tl V3233) V3440) (if (cons? V3235) (let A (hd V3235) (let V3236 (shen.lazyderef (tl V3235) V3440) (if (= () V3236) (let V3237 (shen.lazyderef (tl V3232) V3440) (if (= () V3237) (let Hyp (tl V3223) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons vector (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (if (shen.pvar? V3237) (do (shen.bindv V3237 () V3440) (let Result (let Hyp (tl V3223) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons vector (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (do (shen.unbindv V3237 V3440) Result))) false))) (if (shen.pvar? V3236) (do (shen.bindv V3236 () V3440) (let Result (let V3238 (shen.lazyderef (tl V3232) V3440) (if (= () V3238) (let Hyp (tl V3223) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons vector (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (if (shen.pvar? V3238) (do (shen.bindv V3238 () V3440) (let Result (let Hyp (tl V3223) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons vector (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (do (shen.unbindv V3238 V3440) Result))) false))) (do (shen.unbindv V3236 V3440) Result))) false)))) (if (shen.pvar? V3235) (let A (shen.newpv V3440) (do (shen.bindv V3235 (cons A ()) V3440) (let Result (let V3239 (shen.lazyderef (tl V3232) V3440) (if (= () V3239) (let Hyp (tl V3223) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons vector (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (if (shen.pvar? V3239) (do (shen.bindv V3239 () V3440) (let Result (let Hyp (tl V3223) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons vector (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (do (shen.unbindv V3239 V3440) Result))) false))) (do (shen.unbindv V3235 V3440) Result)))) false))) (if (shen.pvar? V3234) (do (shen.bindv V3234 vector V3440) (let Result (let V3240 (shen.lazyderef (tl V3233) V3440) (if (cons? V3240) (let A (hd V3240) (let V3241 (shen.lazyderef (tl V3240) V3440) (if (= () V3241) (let V3242 (shen.lazyderef (tl V3232) V3440) (if (= () V3242) (let Hyp (tl V3223) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons vector (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (if (shen.pvar? V3242) (do (shen.bindv V3242 () V3440) (let Result (let Hyp (tl V3223) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons vector (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (do (shen.unbindv V3242 V3440) Result))) false))) (if (shen.pvar? V3241) (do (shen.bindv V3241 () V3440) (let Result (let V3243 (shen.lazyderef (tl V3232) V3440) (if (= () V3243) (let Hyp (tl V3223) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons vector (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (if (shen.pvar? V3243) (do (shen.bindv V3243 () V3440) (let Result (let Hyp (tl V3223) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons vector (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (do (shen.unbindv V3243 V3440) Result))) false))) (do (shen.unbindv V3241 V3440) Result))) false)))) (if (shen.pvar? V3240) (let A (shen.newpv V3440) (do (shen.bindv V3240 (cons A ()) V3440) (let Result (let V3244 (shen.lazyderef (tl V3232) V3440) (if (= () V3244) (let Hyp (tl V3223) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons vector (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (if (shen.pvar? V3244) (do (shen.bindv V3244 () V3440) (let Result (let Hyp (tl V3223) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons vector (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (do (shen.unbindv V3244 V3440) Result))) false))) (do (shen.unbindv V3240 V3440) Result)))) false))) (do (shen.unbindv V3234 V3440) Result))) false))) (if (shen.pvar? V3233) (let A (shen.newpv V3440) (do (shen.bindv V3233 (cons vector (cons A ())) V3440) (let Result (let V3245 (shen.lazyderef (tl V3232) V3440) (if (= () V3245) (let Hyp (tl V3223) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons vector (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (if (shen.pvar? V3245) (do (shen.bindv V3245 () V3440) (let Result (let Hyp (tl V3223) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons (shen.lazyderef A V3440) ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons (cons vector (cons (shen.lazyderef A V3440) ())) ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (do (shen.unbindv V3245 V3440) Result))) false))) (do (shen.unbindv V3233 V3440) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3246 (shen.lazyderef V3438 V3440) (if (cons? V3246) (let V3247 (shen.lazyderef (hd V3246) V3440) (if (cons? V3247) (let V3248 (shen.lazyderef (hd V3247) V3440) (if (cons? V3248) (let V3249 (shen.lazyderef (hd V3248) V3440) (if (= @s V3249) (let V3250 (shen.lazyderef (tl V3248) V3440) (if (cons? V3250) (let X (hd V3250) (let V3251 (shen.lazyderef (tl V3250) V3440) (if (cons? V3251) (let Y (hd V3251) (let V3252 (shen.lazyderef (tl V3251) V3440) (if (= () V3252) (let V3253 (shen.lazyderef (tl V3247) V3440) (if (cons? V3253) (let V3254 (shen.lazyderef (hd V3253) V3440) (if (= : V3254) (let V3255 (shen.lazyderef (tl V3253) V3440) (if (cons? V3255) (let V3256 (shen.lazyderef (hd V3255) V3440) (if (= string V3256) (let V3257 (shen.lazyderef (tl V3255) V3440) (if (= () V3257) (let Hyp (tl V3246) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons string ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (if (shen.pvar? V3257) (do (shen.bindv V3257 () V3440) (let Result (let Hyp (tl V3246) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons string ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (do (shen.unbindv V3257 V3440) Result))) false))) (if (shen.pvar? V3256) (do (shen.bindv V3256 string V3440) (let Result (let V3258 (shen.lazyderef (tl V3255) V3440) (if (= () V3258) (let Hyp (tl V3246) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons string ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (if (shen.pvar? V3258) (do (shen.bindv V3258 () V3440) (let Result (let Hyp (tl V3246) (do (shen.incinfs) (bind V3439 (cons (cons (shen.lazyderef X V3440) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3440) (cons : (cons string ()))) (shen.lazyderef Hyp V3440))) V3440 V3441))) (do (shen.unbindv V3258 V3440) Result))) false))) (do (shen.unbindv V3256 V3440) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V3259 (shen.lazyderef V3438 V3440) (if (cons? V3259) (let X (hd V3259) (let Hyp (tl V3259) (let NewHyps (shen.newpv V3440) (do (shen.incinfs) (bind V3439 (cons (shen.lazyderef X V3440) (shen.lazyderef NewHyps V3440)) V3440 (freeze (shen.t*-hyps Hyp NewHyps V3440 V3441))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V3458 V3459 V3460 V3461) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V3458 V3460)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V3459 V3460) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V3461))))))))) (true (thaw V3461))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V3463) (cond ((and (cons? V3463) (and (cons? (tl V3463)) (and (= : (hd (tl V3463))) (and (cons? (tl (tl V3463))) (= () (tl (tl (tl V3463)))))))) (shen.prhush (shen.app (hd V3463) (cn " : " (shen.app (hd (tl (tl V3463))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V3463 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V3468 V3469) (cond ((= () V3468) shen.skip) ((cons? V3468) (do (shen.prhush (shen.app V3469 ". " shen.a) (stoutput)) (do (shen.show-p (hd V3468)) (do (nl 1) (shen.show-assumptions (tl V3468) (+ V3469 1)))))) (true (shen.f_error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V3471) (cons? (assoc V3471 (value shen.*signedfuncs*))))

(defun shen.sigf (V3473) (concat shen.type-signature-of- V3473))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V3478 V3479 V3480 V3481) (let Case (let V3162 (shen.lazyderef V3479 V3480) (if (= number V3162) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3478 V3480)) V3480 V3481)) (if (shen.pvar? V3162) (do (shen.bindv V3162 number V3480) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3478 V3480)) V3480 V3481)) (do (shen.unbindv V3162 V3480) Result))) false))) (if (= Case false) (let Case (let V3163 (shen.lazyderef V3479 V3480) (if (= boolean V3163) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3478 V3480)) V3480 V3481)) (if (shen.pvar? V3163) (do (shen.bindv V3163 boolean V3480) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3478 V3480)) V3480 V3481)) (do (shen.unbindv V3163 V3480) Result))) false))) (if (= Case false) (let Case (let V3164 (shen.lazyderef V3479 V3480) (if (= string V3164) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3478 V3480)) V3480 V3481)) (if (shen.pvar? V3164) (do (shen.bindv V3164 string V3480) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3478 V3480)) V3480 V3481)) (do (shen.unbindv V3164 V3480) Result))) false))) (if (= Case false) (let Case (let V3165 (shen.lazyderef V3479 V3480) (if (= symbol V3165) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3478 V3480)) V3480 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3478 V3480))) V3480 V3481)))) (if (shen.pvar? V3165) (do (shen.bindv V3165 symbol V3480) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3478 V3480)) V3480 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3478 V3480))) V3480 V3481)))) (do (shen.unbindv V3165 V3480) Result))) false))) (if (= Case false) (let V3166 (shen.lazyderef V3478 V3480) (if (= () V3166) (let V3167 (shen.lazyderef V3479 V3480) (if (cons? V3167) (let V3168 (shen.lazyderef (hd V3167) V3480) (if (= list V3168) (let V3169 (shen.lazyderef (tl V3167) V3480) (if (cons? V3169) (let A (hd V3169) (let V3170 (shen.lazyderef (tl V3169) V3480) (if (= () V3170) (do (shen.incinfs) (thaw V3481)) (if (shen.pvar? V3170) (do (shen.bindv V3170 () V3480) (let Result (do (shen.incinfs) (thaw V3481)) (do (shen.unbindv V3170 V3480) Result))) false)))) (if (shen.pvar? V3169) (let A (shen.newpv V3480) (do (shen.bindv V3169 (cons A ()) V3480) (let Result (do (shen.incinfs) (thaw V3481)) (do (shen.unbindv V3169 V3480) Result)))) false))) (if (shen.pvar? V3168) (do (shen.bindv V3168 list V3480) (let Result (let V3171 (shen.lazyderef (tl V3167) V3480) (if (cons? V3171) (let A (hd V3171) (let V3172 (shen.lazyderef (tl V3171) V3480) (if (= () V3172) (do (shen.incinfs) (thaw V3481)) (if (shen.pvar? V3172) (do (shen.bindv V3172 () V3480) (let Result (do (shen.incinfs) (thaw V3481)) (do (shen.unbindv V3172 V3480) Result))) false)))) (if (shen.pvar? V3171) (let A (shen.newpv V3480) (do (shen.bindv V3171 (cons A ()) V3480) (let Result (do (shen.incinfs) (thaw V3481)) (do (shen.unbindv V3171 V3480) Result)))) false))) (do (shen.unbindv V3168 V3480) Result))) false))) (if (shen.pvar? V3167) (let A (shen.newpv V3480) (do (shen.bindv V3167 (cons list (cons A ())) V3480) (let Result (do (shen.incinfs) (thaw V3481)) (do (shen.unbindv V3167 V3480) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V3487 V3488 V3489 V3490 V3491) (let Case (let V3153 (shen.lazyderef V3489 V3490) (if (cons? V3153) (let V3154 (shen.lazyderef (hd V3153) V3490) (if (cons? V3154) (let Y (hd V3154) (let V3155 (shen.lazyderef (tl V3154) V3490) (if (cons? V3155) (let V3156 (shen.lazyderef (hd V3155) V3490) (if (= : V3156) (let V3157 (shen.lazyderef (tl V3155) V3490) (if (cons? V3157) (let B (hd V3157) (let V3158 (shen.lazyderef (tl V3157) V3490) (if (= () V3158) (do (shen.incinfs) (identical V3487 Y V3490 (freeze (unify! V3488 B V3490 V3491)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V3159 (shen.lazyderef V3489 V3490) (if (cons? V3159) (let Hyp (tl V3159) (do (shen.incinfs) (shen.by_hypothesis V3487 V3488 Hyp V3490 V3491))) false)) Case)))

(defun shen.t*-def (V3497 V3498 V3499 V3500 V3501) (let V3147 (shen.lazyderef V3497 V3500) (if (cons? V3147) (let V3148 (shen.lazyderef (hd V3147) V3500) (if (= define V3148) (let V3149 (shen.lazyderef (tl V3147) V3500) (if (cons? V3149) (let F (hd V3149) (let X (tl V3149) (let Y (shen.newpv V3500) (let E (shen.newpv V3500) (do (shen.incinfs) (shen.t*-defh (compile (lambda Y (shen.<sig+rules> Y)) X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V3498 V3499 V3500 V3501)))))) false)) false)) false)))

(defun shen.t*-defh (V3508 V3509 V3510 V3511 V3512 V3513) (let V3143 (shen.lazyderef V3508 V3512) (if (cons? V3143) (let Sig (hd V3143) (let Rules (tl V3143) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V3509 V3510 V3511 Rules V3512 V3513)))) false)))

(defun shen.t*-defhh (V3522 V3523 V3524 V3525 V3526 V3527 V3528 V3529) (do (shen.incinfs) (shen.t*-rules V3527 V3523 1 V3524 (cons (cons V3524 (cons : (cons V3523 ()))) V3526) V3528 (freeze (shen.memo V3524 V3522 V3525 V3528 V3529)))))

(defun shen.memo (V3535 V3536 V3537 V3538 V3539) (let Jnk (shen.newpv V3538) (do (shen.incinfs) (unify! V3537 V3536 V3538 (freeze (bind Jnk (declare (shen.lazyderef V3535 V3538) (shen.lazyderef V3537 V3538)) V3538 V3539))))))

(defun shen.<sig+rules> (V3541) (let Parse_shen.<signature> (shen.<signature> V3541) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))))

(defun shen.<non-ll-rules> (V3543) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V3543) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<rule>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V3543) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.hdtl Parse_shen.<rule>) ())) (fail))) YaccParse)))

(defun shen.ue (V3545) (cond ((and (cons? V3545) (and (cons? (tl V3545)) (and (= () (tl (tl V3545))) (= (hd V3545) protect)))) V3545) ((cons? V3545) (map (lambda Z (shen.ue Z)) V3545)) ((variable? V3545) (concat && V3545)) (true V3545)))

(defun shen.ue-sig (V3547) (cond ((cons? V3547) (map (lambda Z (shen.ue-sig Z)) V3547)) ((variable? V3547) (concat &&& V3547)) (true V3547)))

(defun shen.ues (V3553) (cond ((shen.ue? V3553) (cons V3553 ())) ((cons? V3553) (union (shen.ues (hd V3553)) (shen.ues (tl V3553)))) (true ())))

(defun shen.ue? (V3555) (and (symbol? V3555) (shen.ue-h? (str V3555))))

(defun shen.ue-h? (V3563) (cond ((and (shen.+string? V3563) (and (= "&" (pos V3563 0)) (and (shen.+string? (tlstr V3563)) (= "&" (pos (tlstr V3563) 0))))) true) (true false)))

(defun shen.t*-rules (V3571 V3572 V3573 V3574 V3575 V3576 V3577) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3127 (shen.lazyderef V3571 V3576) (if (= () V3127) (do (shen.incinfs) (thaw V3577)) false)) (if (= Case false) (let Case (let V3128 (shen.lazyderef V3571 V3576) (if (cons? V3128) (let Rule (hd V3128) (let Rules (tl V3128) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V3572 V3575 V3576 (freeze (cut Throwcontrol V3576 (freeze (shen.t*-rules Rules V3572 (+ V3573 1) V3574 V3575 V3576 V3577)))))))) false)) (if (= Case false) (let Err (shen.newpv V3576) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V3573 V3576) (cn " of " (shen.app (shen.lazyderef V3574 V3576) "" shen.a)) shen.a))) V3576 V3577))) Case)) Case)))))

(defun shen.t*-rule (V3583 V3584 V3585 V3586 V3587) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V3119 (shen.lazyderef V3583 V3586) (if (cons? V3119) (let Patterns (hd V3119) (let V3120 (shen.lazyderef (tl V3119) V3586) (if (cons? V3120) (let Action (hd V3120) (let V3121 (shen.lazyderef (tl V3120) V3586) (if (= () V3121) (let NewHyps (shen.newpv V3586) (do (shen.incinfs) (shen.newhyps (shen.placeholders Patterns) V3585 NewHyps V3586 (freeze (shen.t*-patterns Patterns V3584 NewHyps V3586 (freeze (cut Throwcontrol V3586 (freeze (shen.t*-action (shen.curry (shen.ue Action)) (shen.result-type Patterns V3584) (shen.patthyps Patterns V3584 V3585) V3586 V3587))))))))) false))) false))) false)))))

(defun shen.placeholders (V3593) (cond ((shen.ue? V3593) (cons V3593 ())) ((cons? V3593) (union (shen.placeholders (hd V3593)) (shen.placeholders (tl V3593)))) (true ())))

(defun shen.newhyps (V3599 V3600 V3601 V3602 V3603) (let Case (let V3106 (shen.lazyderef V3599 V3602) (if (= () V3106) (do (shen.incinfs) (unify! V3601 V3600 V3602 V3603)) false)) (if (= Case false) (let V3107 (shen.lazyderef V3599 V3602) (if (cons? V3107) (let V3102 (hd V3107) (let Vs (tl V3107) (let V3108 (shen.lazyderef V3601 V3602) (if (cons? V3108) (let V3109 (shen.lazyderef (hd V3108) V3602) (if (cons? V3109) (let V (hd V3109) (let V3110 (shen.lazyderef (tl V3109) V3602) (if (cons? V3110) (let V3111 (shen.lazyderef (hd V3110) V3602) (if (= : V3111) (let V3112 (shen.lazyderef (tl V3110) V3602) (if (cons? V3112) (let A (hd V3112) (let V3113 (shen.lazyderef (tl V3112) V3602) (if (= () V3113) (let NewHyp (tl V3108) (do (shen.incinfs) (unify! V V3102 V3602 (freeze (shen.newhyps Vs V3600 NewHyp V3602 V3603))))) (if (shen.pvar? V3113) (do (shen.bindv V3113 () V3602) (let Result (let NewHyp (tl V3108) (do (shen.incinfs) (unify! V V3102 V3602 (freeze (shen.newhyps Vs V3600 NewHyp V3602 V3603))))) (do (shen.unbindv V3113 V3602) Result))) false)))) (if (shen.pvar? V3112) (let A (shen.newpv V3602) (do (shen.bindv V3112 (cons A ()) V3602) (let Result (let NewHyp (tl V3108) (do (shen.incinfs) (unify! V V3102 V3602 (freeze (shen.newhyps Vs V3600 NewHyp V3602 V3603))))) (do (shen.unbindv V3112 V3602) Result)))) false))) (if (shen.pvar? V3111) (do (shen.bindv V3111 : V3602) (let Result (let V3114 (shen.lazyderef (tl V3110) V3602) (if (cons? V3114) (let A (hd V3114) (let V3115 (shen.lazyderef (tl V3114) V3602) (if (= () V3115) (let NewHyp (tl V3108) (do (shen.incinfs) (unify! V V3102 V3602 (freeze (shen.newhyps Vs V3600 NewHyp V3602 V3603))))) (if (shen.pvar? V3115) (do (shen.bindv V3115 () V3602) (let Result (let NewHyp (tl V3108) (do (shen.incinfs) (unify! V V3102 V3602 (freeze (shen.newhyps Vs V3600 NewHyp V3602 V3603))))) (do (shen.unbindv V3115 V3602) Result))) false)))) (if (shen.pvar? V3114) (let A (shen.newpv V3602) (do (shen.bindv V3114 (cons A ()) V3602) (let Result (let NewHyp (tl V3108) (do (shen.incinfs) (unify! V V3102 V3602 (freeze (shen.newhyps Vs V3600 NewHyp V3602 V3603))))) (do (shen.unbindv V3114 V3602) Result)))) false))) (do (shen.unbindv V3111 V3602) Result))) false))) (if (shen.pvar? V3110) (let A (shen.newpv V3602) (do (shen.bindv V3110 (cons : (cons A ())) V3602) (let Result (let NewHyp (tl V3108) (do (shen.incinfs) (unify! V V3102 V3602 (freeze (shen.newhyps Vs V3600 NewHyp V3602 V3603))))) (do (shen.unbindv V3110 V3602) Result)))) false)))) (if (shen.pvar? V3109) (let V (shen.newpv V3602) (let A (shen.newpv V3602) (do (shen.bindv V3109 (cons V (cons : (cons A ()))) V3602) (let Result (let NewHyp (tl V3108) (do (shen.incinfs) (unify! V V3102 V3602 (freeze (shen.newhyps Vs V3600 NewHyp V3602 V3603))))) (do (shen.unbindv V3109 V3602) Result))))) false))) (if (shen.pvar? V3108) (let V (shen.newpv V3602) (let A (shen.newpv V3602) (let NewHyp (shen.newpv V3602) (do (shen.bindv V3108 (cons (cons V (cons : (cons A ()))) NewHyp) V3602) (let Result (do (shen.incinfs) (unify! V V3102 V3602 (freeze (shen.newhyps Vs V3600 NewHyp V3602 V3603)))) (do (shen.unbindv V3108 V3602) Result)))))) false))))) false)) Case)))

(defun shen.patthyps (V3609 V3610 V3611) (cond ((= () V3609) V3611) ((and (cons? V3609) (and (cons? V3610) (and (cons? (tl V3610)) (and (= --> (hd (tl V3610))) (and (cons? (tl (tl V3610))) (= () (tl (tl (tl V3610))))))))) (adjoin (cons (hd V3609) (cons : (cons (hd V3610) ()))) (shen.patthyps (tl V3609) (hd (tl (tl V3610))) V3611))) (true (shen.f_error shen.patthyps))))

(defun shen.result-type (V3618 V3619) (cond ((and (= () V3618) (and (cons? V3619) (and (= --> (hd V3619)) (and (cons? (tl V3619)) (= () (tl (tl V3619))))))) (hd (tl V3619))) ((= () V3618) V3619) ((and (cons? V3618) (and (cons? V3619) (and (cons? (tl V3619)) (and (= --> (hd (tl V3619))) (and (cons? (tl (tl V3619))) (= () (tl (tl (tl V3619))))))))) (shen.result-type (tl V3618) (hd (tl (tl V3619))))) (true (shen.f_error shen.result-type))))

(defun shen.t*-patterns (V3625 V3626 V3627 V3628 V3629) (let Case (let V3094 (shen.lazyderef V3625 V3628) (if (= () V3094) (do (shen.incinfs) (thaw V3629)) false)) (if (= Case false) (let V3095 (shen.lazyderef V3625 V3628) (if (cons? V3095) (let Pattern (hd V3095) (let Patterns (tl V3095) (let V3096 (shen.lazyderef V3626 V3628) (if (cons? V3096) (let A (hd V3096) (let V3097 (shen.lazyderef (tl V3096) V3628) (if (cons? V3097) (let V3098 (shen.lazyderef (hd V3097) V3628) (if (= --> V3098) (let V3099 (shen.lazyderef (tl V3097) V3628) (if (cons? V3099) (let B (hd V3099) (let V3100 (shen.lazyderef (tl V3099) V3628) (if (= () V3100) (do (shen.incinfs) (shen.t* (cons Pattern (cons : (cons A ()))) V3627 V3628 (freeze (shen.t*-patterns Patterns B V3627 V3628 V3629)))) false))) false)) false)) false))) false)))) false)) Case)))

(defun shen.t*-action (V3635 V3636 V3637 V3638 V3639) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3071 (shen.lazyderef V3635 V3638) (if (cons? V3071) (let V3072 (shen.lazyderef (hd V3071) V3638) (if (= where V3072) (let V3073 (shen.lazyderef (tl V3071) V3638) (if (cons? V3073) (let P (hd V3073) (let V3074 (shen.lazyderef (tl V3073) V3638) (if (cons? V3074) (let Action (hd V3074) (let V3075 (shen.lazyderef (tl V3074) V3638) (if (= () V3075) (do (shen.incinfs) (cut Throwcontrol V3638 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V3637 V3638 (freeze (cut Throwcontrol V3638 (freeze (shen.t*-action Action V3636 (cons (cons P (cons : (cons verified ()))) V3637) V3638 V3639)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3076 (shen.lazyderef V3635 V3638) (if (cons? V3076) (let V3077 (shen.lazyderef (hd V3076) V3638) (if (= shen.choicepoint! V3077) (let V3078 (shen.lazyderef (tl V3076) V3638) (if (cons? V3078) (let V3079 (shen.lazyderef (hd V3078) V3638) (if (cons? V3079) (let V3080 (shen.lazyderef (hd V3079) V3638) (if (cons? V3080) (let V3081 (shen.lazyderef (hd V3080) V3638) (if (= fail-if V3081) (let V3082 (shen.lazyderef (tl V3080) V3638) (if (cons? V3082) (let F (hd V3082) (let V3083 (shen.lazyderef (tl V3082) V3638) (if (= () V3083) (let V3084 (shen.lazyderef (tl V3079) V3638) (if (cons? V3084) (let Action (hd V3084) (let V3085 (shen.lazyderef (tl V3084) V3638) (if (= () V3085) (let V3086 (shen.lazyderef (tl V3078) V3638) (if (= () V3086) (do (shen.incinfs) (cut Throwcontrol V3638 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V3636 V3637 V3638 V3639)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3087 (shen.lazyderef V3635 V3638) (if (cons? V3087) (let V3088 (shen.lazyderef (hd V3087) V3638) (if (= shen.choicepoint! V3088) (let V3089 (shen.lazyderef (tl V3087) V3638) (if (cons? V3089) (let Action (hd V3089) (let V3090 (shen.lazyderef (tl V3089) V3638) (if (= () V3090) (do (shen.incinfs) (cut Throwcontrol V3638 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V3636 V3637 V3638 V3639)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V3635 (cons : (cons V3636 ()))) V3637 V3638 V3639)) Case)) Case)) Case)))))

(defun findall (V3645 V3646 V3647 V3648 V3649) (let B (shen.newpv V3648) (let A (shen.newpv V3648) (do (shen.incinfs) (bind A (gensym shen.a) V3648 (freeze (bind B (set (shen.lazyderef A V3648) ()) V3648 (freeze (shen.findallhelp V3645 V3646 V3647 A V3648 V3649)))))))))

(defun shen.findallhelp (V3656 V3657 V3658 V3659 V3660 V3661) (let Case (do (shen.incinfs) (call V3657 V3660 (freeze (shen.remember V3659 V3656 V3660 (freeze (fwhen false V3660 V3661)))))) (if (= Case false) (do (shen.incinfs) (bind V3658 (value (shen.lazyderef V3659 V3660)) V3660 V3661)) Case)))

(defun shen.remember (V3666 V3667 V3668 V3669) (let B (shen.newpv V3668) (do (shen.incinfs) (bind B (set (shen.deref V3666 V3668) (cons (shen.deref V3667 V3668) (value (shen.deref V3666 V3668)))) V3668 V3669))))



