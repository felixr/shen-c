"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun read-file-as-bytelist (V2164) (let Stream (open V2164 in) (let Byte (read-byte Stream) (let Bytes (shen.read-file-as-bytelist-help Stream Byte ()) (let Close (close Stream) (reverse Bytes))))))

(defun shen.read-file-as-bytelist-help (V2168 V2169 V2170) (cond ((= -1 V2169) V2170) (true (shen.read-file-as-bytelist-help V2168 (read-byte V2168) (cons V2169 V2170)))))

(defun read-file-as-string (V2172) (let Stream (open V2172 in) (shen.rfas-h Stream (read-byte Stream) "")))

(defun shen.rfas-h (V2176 V2177 V2178) (cond ((= -1 V2177) (do (close V2176) V2178)) (true (shen.rfas-h V2176 (read-byte V2176) (cn V2178 (n->string V2177))))))

(defun input (V2180) (eval-kl (read V2180)))

(defun input+ (V2183 V2184) (let Mono? (shen.monotype V2183) (let Input (read V2184) (if (= false (shen.typecheck Input (shen.demodulate V2183))) (simple-error (cn "type error: " (shen.app Input (cn " is not of type " (shen.app V2183 "
" shen.r)) shen.r))) (eval-kl Input)))))

(defun shen.monotype (V2186) (cond ((cons? V2186) (map (lambda Z (shen.monotype Z)) V2186)) (true (if (variable? V2186) (simple-error (cn "input+ expects a monotype: not " (shen.app V2186 "
" shen.a))) V2186))))

(defun read (V2188) (hd (shen.read-loop V2188 (read-byte V2188) ())))

(defun it () (value shen.*it*))

(defun shen.read-loop (V2196 V2197 V2198) (cond ((= 94 V2197) (simple-error "read aborted")) ((= -1 V2197) (if (empty? V2198) (simple-error "error: empty stream") (compile (lambda X (shen.<st_input> X)) V2198 (lambda E E)))) ((shen.terminator? V2197) (let AllBytes (append V2198 (cons V2197 ())) (let It (shen.record-it AllBytes) (let Read (compile (lambda X (shen.<st_input> X)) AllBytes (lambda E shen.nextbyte)) (if (or (= Read shen.nextbyte) (empty? Read)) (shen.read-loop V2196 (read-byte V2196) AllBytes) Read))))) (true (shen.read-loop V2196 (read-byte V2196) (append V2198 (cons V2197 ()))))))

(defun shen.terminator? (V2200) (element? V2200 (cons 9 (cons 10 (cons 13 (cons 32 (cons 34 (cons 41 (cons 93 ())))))))))

(defun lineread (V2202) (shen.lineread-loop (read-byte V2202) () V2202))

(defun shen.lineread-loop (V2207 V2208 V2209) (cond ((= -1 V2207) (if (empty? V2208) (simple-error "empty stream") (compile (lambda X (shen.<st_input> X)) V2208 (lambda E E)))) ((= V2207 (shen.hat)) (simple-error "line read aborted")) ((element? V2207 (cons (shen.newline) (cons (shen.carriage-return) ()))) (let Line (compile (lambda X (shen.<st_input> X)) V2208 (lambda E shen.nextline)) (let It (shen.record-it V2208) (if (or (= Line shen.nextline) (empty? Line)) (shen.lineread-loop (read-byte V2209) (append V2208 (cons V2207 ())) V2209) Line)))) (true (shen.lineread-loop (read-byte V2209) (append V2208 (cons V2207 ())) V2209))))

(defun shen.record-it (V2211) (let TrimLeft (shen.trim-whitespace V2211) (let TrimRight (shen.trim-whitespace (reverse TrimLeft)) (let Trimmed (reverse TrimRight) (shen.record-it-h Trimmed)))))

(defun shen.trim-whitespace (V2213) (cond ((and (cons? V2213) (element? (hd V2213) (cons 9 (cons 10 (cons 13 (cons 32 ())))))) (shen.trim-whitespace (tl V2213))) (true V2213)))

(defun shen.record-it-h (V2215) (do (set shen.*it* (shen.cn-all (map (lambda X (n->string X)) V2215))) V2215))

(defun shen.cn-all (V2217) (cond ((= () V2217) "") ((cons? V2217) (cn (hd V2217) (shen.cn-all (tl V2217)))) (true (shen.f_error shen.cn-all))))

(defun read-file (V2219) (let Bytelist (read-file-as-bytelist V2219) (compile (lambda X (shen.<st_input> X)) Bytelist (lambda X (shen.read-error X)))))

(defun read-from-string (V2221) (let Ns (map (lambda X (string->n X)) (explode V2221)) (compile (lambda X (shen.<st_input> X)) Ns (lambda X (shen.read-error X)))))

(defun shen.read-error (V2229) (cond ((and (cons? V2229) (and (cons? (hd V2229)) (and (cons? (tl V2229)) (= () (tl (tl V2229)))))) (simple-error (cn "read error here:

 " (shen.app (shen.compress-50 50 (hd V2229)) "
" shen.a)))) (true (simple-error "read error
"))))

(defun shen.compress-50 (V2236 V2237) (cond ((= () V2237) "") ((= 0 V2236) "") ((cons? V2237) (cn (n->string (hd V2237)) (shen.compress-50 (- V2236 1) (tl V2237)))) (true (shen.f_error shen.compress-50))))

(defun shen.<st_input> (V2239) (let YaccParse (let Parse_shen.<lsb> (shen.<lsb> V2239) (if (not (= (fail) Parse_shen.<lsb>)) (let Parse_shen.<st_input1> (shen.<st_input1> Parse_shen.<lsb>) (if (not (= (fail) Parse_shen.<st_input1>)) (let Parse_shen.<rsb> (shen.<rsb> Parse_shen.<st_input1>) (if (not (= (fail) Parse_shen.<rsb>)) (let Parse_shen.<st_input2> (shen.<st_input2> Parse_shen.<rsb>) (if (not (= (fail) Parse_shen.<st_input2>)) (shen.pair (hd Parse_shen.<st_input2>) (cons (macroexpand (shen.cons_form (shen.hdtl Parse_shen.<st_input1>))) (shen.hdtl Parse_shen.<st_input2>))) (fail))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<lrb> (shen.<lrb> V2239) (if (not (= (fail) Parse_shen.<lrb>)) (let Parse_shen.<st_input1> (shen.<st_input1> Parse_shen.<lrb>) (if (not (= (fail) Parse_shen.<st_input1>)) (let Parse_shen.<rrb> (shen.<rrb> Parse_shen.<st_input1>) (if (not (= (fail) Parse_shen.<rrb>)) (let Parse_shen.<st_input2> (shen.<st_input2> Parse_shen.<rrb>) (if (not (= (fail) Parse_shen.<st_input2>)) (shen.pair (hd Parse_shen.<st_input2>) (shen.package-macro (macroexpand (shen.hdtl Parse_shen.<st_input1>)) (shen.hdtl Parse_shen.<st_input2>))) (fail))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<lcurly> (shen.<lcurly> V2239) (if (not (= (fail) Parse_shen.<lcurly>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<lcurly>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons { (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<rcurly> (shen.<rcurly> V2239) (if (not (= (fail) Parse_shen.<rcurly>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<rcurly>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons } (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<bar> (shen.<bar> V2239) (if (not (= (fail) Parse_shen.<bar>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<bar>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons bar! (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<semicolon> (shen.<semicolon> V2239) (if (not (= (fail) Parse_shen.<semicolon>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<semicolon>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons ; (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<colon> (shen.<colon> V2239) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<equal> (shen.<equal> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<equal>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<equal>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons := (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<colon> (shen.<colon> V2239) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<minus> (shen.<minus> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons :- (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<colon> (shen.<colon> V2239) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons : (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<comma> (shen.<comma> V2239) (if (not (= (fail) Parse_shen.<comma>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<comma>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons (intern ",") (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<comment> (shen.<comment> V2239) (if (not (= (fail) Parse_shen.<comment>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<comment>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<atom> (shen.<atom> V2239) (if (not (= (fail) Parse_shen.<atom>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<atom>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons (macroexpand (shen.hdtl Parse_shen.<atom>)) (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<whitespaces> (shen.<whitespaces> V2239) (if (not (= (fail) Parse_shen.<whitespaces>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<whitespaces>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2239) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.<lsb> (V2241) (if (and (cons? (hd V2241)) (= 91 (hd (hd V2241)))) (shen.pair (hd (shen.pair (tl (hd V2241)) (shen.hdtl V2241))) shen.skip) (fail)))

(defun shen.<rsb> (V2243) (if (and (cons? (hd V2243)) (= 93 (hd (hd V2243)))) (shen.pair (hd (shen.pair (tl (hd V2243)) (shen.hdtl V2243))) shen.skip) (fail)))

(defun shen.<lcurly> (V2245) (if (and (cons? (hd V2245)) (= 123 (hd (hd V2245)))) (shen.pair (hd (shen.pair (tl (hd V2245)) (shen.hdtl V2245))) shen.skip) (fail)))

(defun shen.<rcurly> (V2247) (if (and (cons? (hd V2247)) (= 125 (hd (hd V2247)))) (shen.pair (hd (shen.pair (tl (hd V2247)) (shen.hdtl V2247))) shen.skip) (fail)))

(defun shen.<bar> (V2249) (if (and (cons? (hd V2249)) (= 124 (hd (hd V2249)))) (shen.pair (hd (shen.pair (tl (hd V2249)) (shen.hdtl V2249))) shen.skip) (fail)))

(defun shen.<semicolon> (V2251) (if (and (cons? (hd V2251)) (= 59 (hd (hd V2251)))) (shen.pair (hd (shen.pair (tl (hd V2251)) (shen.hdtl V2251))) shen.skip) (fail)))

(defun shen.<colon> (V2253) (if (and (cons? (hd V2253)) (= 58 (hd (hd V2253)))) (shen.pair (hd (shen.pair (tl (hd V2253)) (shen.hdtl V2253))) shen.skip) (fail)))

(defun shen.<comma> (V2255) (if (and (cons? (hd V2255)) (= 44 (hd (hd V2255)))) (shen.pair (hd (shen.pair (tl (hd V2255)) (shen.hdtl V2255))) shen.skip) (fail)))

(defun shen.<equal> (V2257) (if (and (cons? (hd V2257)) (= 61 (hd (hd V2257)))) (shen.pair (hd (shen.pair (tl (hd V2257)) (shen.hdtl V2257))) shen.skip) (fail)))

(defun shen.<minus> (V2259) (if (and (cons? (hd V2259)) (= 45 (hd (hd V2259)))) (shen.pair (hd (shen.pair (tl (hd V2259)) (shen.hdtl V2259))) shen.skip) (fail)))

(defun shen.<lrb> (V2261) (if (and (cons? (hd V2261)) (= 40 (hd (hd V2261)))) (shen.pair (hd (shen.pair (tl (hd V2261)) (shen.hdtl V2261))) shen.skip) (fail)))

(defun shen.<rrb> (V2263) (if (and (cons? (hd V2263)) (= 41 (hd (hd V2263)))) (shen.pair (hd (shen.pair (tl (hd V2263)) (shen.hdtl V2263))) shen.skip) (fail)))

(defun shen.<atom> (V2265) (let YaccParse (let Parse_shen.<str> (shen.<str> V2265) (if (not (= (fail) Parse_shen.<str>)) (shen.pair (hd Parse_shen.<str>) (shen.control-chars (shen.hdtl Parse_shen.<str>))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<number> (shen.<number> V2265) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (shen.hdtl Parse_shen.<number>)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<sym> (shen.<sym> V2265) (if (not (= (fail) Parse_shen.<sym>)) (shen.pair (hd Parse_shen.<sym>) (if (= (shen.hdtl Parse_shen.<sym>) "<>") (cons vector (cons 0 ())) (intern (shen.hdtl Parse_shen.<sym>)))) (fail))) YaccParse)) YaccParse)))

(defun shen.control-chars (V2267) (cond ((= () V2267) "") ((and (cons? V2267) (and (= "c" (hd V2267)) (and (cons? (tl V2267)) (= "#" (hd (tl V2267)))))) (let CodePoint (shen.code-point (tl (tl V2267))) (let AfterCodePoint (shen.after-codepoint (tl (tl V2267))) (@s (n->string (shen.decimalise CodePoint)) (shen.control-chars AfterCodePoint))))) ((cons? V2267) (@s (hd V2267) (shen.control-chars (tl V2267)))) (true (shen.f_error shen.control-chars))))

(defun shen.code-point (V2271) (cond ((and (cons? V2271) (= ";" (hd V2271))) "") ((and (cons? V2271) (element? (hd V2271) (cons "0" (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" ()))))))))))))) (cons (hd V2271) (shen.code-point (tl V2271)))) (true (simple-error (cn "code point parse error " (shen.app V2271 "
" shen.a))))))

(defun shen.after-codepoint (V2277) (cond ((= () V2277) ()) ((and (cons? V2277) (= ";" (hd V2277))) (tl V2277)) ((cons? V2277) (shen.after-codepoint (tl V2277))) (true (shen.f_error shen.after-codepoint))))

(defun shen.decimalise (V2279) (shen.pre (reverse (shen.digits->integers V2279)) 0))

(defun shen.digits->integers (V2285) (cond ((and (cons? V2285) (= "0" (hd V2285))) (cons 0 (shen.digits->integers (tl V2285)))) ((and (cons? V2285) (= "1" (hd V2285))) (cons 1 (shen.digits->integers (tl V2285)))) ((and (cons? V2285) (= "2" (hd V2285))) (cons 2 (shen.digits->integers (tl V2285)))) ((and (cons? V2285) (= "3" (hd V2285))) (cons 3 (shen.digits->integers (tl V2285)))) ((and (cons? V2285) (= "4" (hd V2285))) (cons 4 (shen.digits->integers (tl V2285)))) ((and (cons? V2285) (= "5" (hd V2285))) (cons 5 (shen.digits->integers (tl V2285)))) ((and (cons? V2285) (= "6" (hd V2285))) (cons 6 (shen.digits->integers (tl V2285)))) ((and (cons? V2285) (= "7" (hd V2285))) (cons 7 (shen.digits->integers (tl V2285)))) ((and (cons? V2285) (= "8" (hd V2285))) (cons 8 (shen.digits->integers (tl V2285)))) ((and (cons? V2285) (= "9" (hd V2285))) (cons 9 (shen.digits->integers (tl V2285)))) (true ())))

(defun shen.<sym> (V2287) (let Parse_shen.<alpha> (shen.<alpha> V2287) (if (not (= (fail) Parse_shen.<alpha>)) (let Parse_shen.<alphanums> (shen.<alphanums> Parse_shen.<alpha>) (if (not (= (fail) Parse_shen.<alphanums>)) (shen.pair (hd Parse_shen.<alphanums>) (@s (shen.hdtl Parse_shen.<alpha>) (shen.hdtl Parse_shen.<alphanums>))) (fail))) (fail))))

(defun shen.<alphanums> (V2289) (let YaccParse (let Parse_shen.<alphanum> (shen.<alphanum> V2289) (if (not (= (fail) Parse_shen.<alphanum>)) (let Parse_shen.<alphanums> (shen.<alphanums> Parse_shen.<alphanum>) (if (not (= (fail) Parse_shen.<alphanums>)) (shen.pair (hd Parse_shen.<alphanums>) (@s (shen.hdtl Parse_shen.<alphanum>) (shen.hdtl Parse_shen.<alphanums>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2289) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) "") (fail))) YaccParse)))

(defun shen.<alphanum> (V2291) (let YaccParse (let Parse_shen.<alpha> (shen.<alpha> V2291) (if (not (= (fail) Parse_shen.<alpha>)) (shen.pair (hd Parse_shen.<alpha>) (shen.hdtl Parse_shen.<alpha>)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<num> (shen.<num> V2291) (if (not (= (fail) Parse_shen.<num>)) (shen.pair (hd Parse_shen.<num>) (shen.hdtl Parse_shen.<num>)) (fail))) YaccParse)))

(defun shen.<num> (V2293) (if (cons? (hd V2293)) (let Parse_Byte (hd (hd V2293)) (if (shen.numbyte? Parse_Byte) (shen.pair (hd (shen.pair (tl (hd V2293)) (shen.hdtl V2293))) (n->string Parse_Byte)) (fail))) (fail)))

(defun shen.numbyte? (V2299) (cond ((= 48 V2299) true) ((= 49 V2299) true) ((= 50 V2299) true) ((= 51 V2299) true) ((= 52 V2299) true) ((= 53 V2299) true) ((= 54 V2299) true) ((= 55 V2299) true) ((= 56 V2299) true) ((= 57 V2299) true) (true false)))

(defun shen.<alpha> (V2301) (if (cons? (hd V2301)) (let Parse_Byte (hd (hd V2301)) (if (shen.symbol-code? Parse_Byte) (shen.pair (hd (shen.pair (tl (hd V2301)) (shen.hdtl V2301))) (n->string Parse_Byte)) (fail))) (fail)))

(defun shen.symbol-code? (V2303) (or (= V2303 126) (or (and (> V2303 94) (< V2303 123)) (or (and (> V2303 59) (< V2303 91)) (or (and (> V2303 41) (and (< V2303 58) (not (= V2303 44)))) (or (and (> V2303 34) (< V2303 40)) (= V2303 33)))))))

(defun shen.<str> (V2305) (let Parse_shen.<dbq> (shen.<dbq> V2305) (if (not (= (fail) Parse_shen.<dbq>)) (let Parse_shen.<strcontents> (shen.<strcontents> Parse_shen.<dbq>) (if (not (= (fail) Parse_shen.<strcontents>)) (let Parse_shen.<dbq> (shen.<dbq> Parse_shen.<strcontents>) (if (not (= (fail) Parse_shen.<dbq>)) (shen.pair (hd Parse_shen.<dbq>) (shen.hdtl Parse_shen.<strcontents>)) (fail))) (fail))) (fail))))

(defun shen.<dbq> (V2307) (if (cons? (hd V2307)) (let Parse_Byte (hd (hd V2307)) (if (= Parse_Byte 34) (shen.pair (hd (shen.pair (tl (hd V2307)) (shen.hdtl V2307))) Parse_Byte) (fail))) (fail)))

(defun shen.<strcontents> (V2309) (let YaccParse (let Parse_shen.<strc> (shen.<strc> V2309) (if (not (= (fail) Parse_shen.<strc>)) (let Parse_shen.<strcontents> (shen.<strcontents> Parse_shen.<strc>) (if (not (= (fail) Parse_shen.<strcontents>)) (shen.pair (hd Parse_shen.<strcontents>) (cons (shen.hdtl Parse_shen.<strc>) (shen.hdtl Parse_shen.<strcontents>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2309) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<byte> (V2311) (if (cons? (hd V2311)) (let Parse_Byte (hd (hd V2311)) (shen.pair (hd (shen.pair (tl (hd V2311)) (shen.hdtl V2311))) (n->string Parse_Byte))) (fail)))

(defun shen.<strc> (V2313) (if (cons? (hd V2313)) (let Parse_Byte (hd (hd V2313)) (if (not (= Parse_Byte 34)) (shen.pair (hd (shen.pair (tl (hd V2313)) (shen.hdtl V2313))) (n->string Parse_Byte)) (fail))) (fail)))

(defun shen.<number> (V2315) (let YaccParse (let Parse_shen.<minus> (shen.<minus> V2315) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<number> (shen.<number> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (- 0 (shen.hdtl Parse_shen.<number>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<plus> (shen.<plus> V2315) (if (not (= (fail) Parse_shen.<plus>)) (let Parse_shen.<number> (shen.<number> Parse_shen.<plus>) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (shen.hdtl Parse_shen.<number>)) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<predigits> (shen.<predigits> V2315) (if (not (= (fail) Parse_shen.<predigits>)) (let Parse_shen.<stop> (shen.<stop> Parse_shen.<predigits>) (if (not (= (fail) Parse_shen.<stop>)) (let Parse_shen.<postdigits> (shen.<postdigits> Parse_shen.<stop>) (if (not (= (fail) Parse_shen.<postdigits>)) (let Parse_shen.<E> (shen.<E> Parse_shen.<postdigits>) (if (not (= (fail) Parse_shen.<E>)) (let Parse_shen.<log10> (shen.<log10> Parse_shen.<E>) (if (not (= (fail) Parse_shen.<log10>)) (shen.pair (hd Parse_shen.<log10>) (* (shen.expt 10 (shen.hdtl Parse_shen.<log10>)) (+ (shen.pre (reverse (shen.hdtl Parse_shen.<predigits>)) 0) (shen.post (shen.hdtl Parse_shen.<postdigits>) 1)))) (fail))) (fail))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<digits> (shen.<digits> V2315) (if (not (= (fail) Parse_shen.<digits>)) (let Parse_shen.<E> (shen.<E> Parse_shen.<digits>) (if (not (= (fail) Parse_shen.<E>)) (let Parse_shen.<log10> (shen.<log10> Parse_shen.<E>) (if (not (= (fail) Parse_shen.<log10>)) (shen.pair (hd Parse_shen.<log10>) (* (shen.expt 10 (shen.hdtl Parse_shen.<log10>)) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<predigits> (shen.<predigits> V2315) (if (not (= (fail) Parse_shen.<predigits>)) (let Parse_shen.<stop> (shen.<stop> Parse_shen.<predigits>) (if (not (= (fail) Parse_shen.<stop>)) (let Parse_shen.<postdigits> (shen.<postdigits> Parse_shen.<stop>) (if (not (= (fail) Parse_shen.<postdigits>)) (shen.pair (hd Parse_shen.<postdigits>) (+ (shen.pre (reverse (shen.hdtl Parse_shen.<predigits>)) 0) (shen.post (shen.hdtl Parse_shen.<postdigits>) 1))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<digits> (shen.<digits> V2315) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.<E> (V2317) (if (and (cons? (hd V2317)) (= 101 (hd (hd V2317)))) (shen.pair (hd (shen.pair (tl (hd V2317)) (shen.hdtl V2317))) shen.skip) (fail)))

(defun shen.<log10> (V2319) (let YaccParse (let Parse_shen.<minus> (shen.<minus> V2319) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<digits> (shen.<digits> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (- 0 (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<digits> (shen.<digits> V2319) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0)) (fail))) YaccParse)))

(defun shen.<plus> (V2321) (if (cons? (hd V2321)) (let Parse_Byte (hd (hd V2321)) (if (= Parse_Byte 43) (shen.pair (hd (shen.pair (tl (hd V2321)) (shen.hdtl V2321))) Parse_Byte) (fail))) (fail)))

(defun shen.<stop> (V2323) (if (cons? (hd V2323)) (let Parse_Byte (hd (hd V2323)) (if (= Parse_Byte 46) (shen.pair (hd (shen.pair (tl (hd V2323)) (shen.hdtl V2323))) Parse_Byte) (fail))) (fail)))

(defun shen.<predigits> (V2325) (let YaccParse (let Parse_shen.<digits> (shen.<digits> V2325) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.hdtl Parse_shen.<digits>)) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2325) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<postdigits> (V2327) (let Parse_shen.<digits> (shen.<digits> V2327) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.hdtl Parse_shen.<digits>)) (fail))))

(defun shen.<digits> (V2329) (let YaccParse (let Parse_shen.<digit> (shen.<digit> V2329) (if (not (= (fail) Parse_shen.<digit>)) (let Parse_shen.<digits> (shen.<digits> Parse_shen.<digit>) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (cons (shen.hdtl Parse_shen.<digit>) (shen.hdtl Parse_shen.<digits>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<digit> (shen.<digit> V2329) (if (not (= (fail) Parse_shen.<digit>)) (shen.pair (hd Parse_shen.<digit>) (cons (shen.hdtl Parse_shen.<digit>) ())) (fail))) YaccParse)))

(defun shen.<digit> (V2331) (if (cons? (hd V2331)) (let Parse_X (hd (hd V2331)) (if (shen.numbyte? Parse_X) (shen.pair (hd (shen.pair (tl (hd V2331)) (shen.hdtl V2331))) (shen.byte->digit Parse_X)) (fail))) (fail)))

(defun shen.byte->digit (V2333) (cond ((= 48 V2333) 0) ((= 49 V2333) 1) ((= 50 V2333) 2) ((= 51 V2333) 3) ((= 52 V2333) 4) ((= 53 V2333) 5) ((= 54 V2333) 6) ((= 55 V2333) 7) ((= 56 V2333) 8) ((= 57 V2333) 9) (true (shen.f_error shen.byte->digit))))

(defun shen.pre (V2338 V2339) (cond ((= () V2338) 0) ((cons? V2338) (+ (* (shen.expt 10 V2339) (hd V2338)) (shen.pre (tl V2338) (+ V2339 1)))) (true (shen.f_error shen.pre))))

(defun shen.post (V2344 V2345) (cond ((= () V2344) 0) ((cons? V2344) (+ (* (shen.expt 10 (- 0 V2345)) (hd V2344)) (shen.post (tl V2344) (+ V2345 1)))) (true (shen.f_error shen.post))))

(defun shen.expt (V2350 V2351) (cond ((= 0 V2351) 1) ((> V2351 0) (* V2350 (shen.expt V2350 (- V2351 1)))) (true (* 1.0 (/ (shen.expt V2350 (+ V2351 1)) V2350)))))

(defun shen.<st_input1> (V2353) (let Parse_shen.<st_input> (shen.<st_input> V2353) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))))

(defun shen.<st_input2> (V2355) (let Parse_shen.<st_input> (shen.<st_input> V2355) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))))

(defun shen.<comment> (V2357) (let YaccParse (let Parse_shen.<singleline> (shen.<singleline> V2357) (if (not (= (fail) Parse_shen.<singleline>)) (shen.pair (hd Parse_shen.<singleline>) shen.skip) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<multiline> (shen.<multiline> V2357) (if (not (= (fail) Parse_shen.<multiline>)) (shen.pair (hd Parse_shen.<multiline>) shen.skip) (fail))) YaccParse)))

(defun shen.<singleline> (V2359) (let Parse_shen.<backslash> (shen.<backslash> V2359) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<backslash> (shen.<backslash> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<anysingle> (shen.<anysingle> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<anysingle>)) (let Parse_shen.<return> (shen.<return> Parse_shen.<anysingle>) (if (not (= (fail) Parse_shen.<return>)) (shen.pair (hd Parse_shen.<return>) shen.skip) (fail))) (fail))) (fail))) (fail))))

(defun shen.<backslash> (V2361) (if (and (cons? (hd V2361)) (= 92 (hd (hd V2361)))) (shen.pair (hd (shen.pair (tl (hd V2361)) (shen.hdtl V2361))) shen.skip) (fail)))

(defun shen.<anysingle> (V2363) (let YaccParse (let Parse_shen.<non-return> (shen.<non-return> V2363) (if (not (= (fail) Parse_shen.<non-return>)) (let Parse_shen.<anysingle> (shen.<anysingle> Parse_shen.<non-return>) (if (not (= (fail) Parse_shen.<anysingle>)) (shen.pair (hd Parse_shen.<anysingle>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2363) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) shen.skip) (fail))) YaccParse)))

(defun shen.<non-return> (V2365) (if (cons? (hd V2365)) (let Parse_X (hd (hd V2365)) (if (not (element? Parse_X (cons 10 (cons 13 ())))) (shen.pair (hd (shen.pair (tl (hd V2365)) (shen.hdtl V2365))) shen.skip) (fail))) (fail)))

(defun shen.<return> (V2367) (if (cons? (hd V2367)) (let Parse_X (hd (hd V2367)) (if (element? Parse_X (cons 10 (cons 13 ()))) (shen.pair (hd (shen.pair (tl (hd V2367)) (shen.hdtl V2367))) shen.skip) (fail))) (fail)))

(defun shen.<multiline> (V2369) (let Parse_shen.<backslash> (shen.<backslash> V2369) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<times> (shen.<times> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<times>)) (let Parse_shen.<anymulti> (shen.<anymulti> Parse_shen.<times>) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail))) (fail))) (fail))))

(defun shen.<times> (V2371) (if (and (cons? (hd V2371)) (= 42 (hd (hd V2371)))) (shen.pair (hd (shen.pair (tl (hd V2371)) (shen.hdtl V2371))) shen.skip) (fail)))

(defun shen.<anymulti> (V2373) (let YaccParse (let Parse_shen.<comment> (shen.<comment> V2373) (if (not (= (fail) Parse_shen.<comment>)) (let Parse_shen.<anymulti> (shen.<anymulti> Parse_shen.<comment>) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<times> (shen.<times> V2373) (if (not (= (fail) Parse_shen.<times>)) (let Parse_shen.<backslash> (shen.<backslash> Parse_shen.<times>) (if (not (= (fail) Parse_shen.<backslash>)) (shen.pair (hd Parse_shen.<backslash>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (if (cons? (hd V2373)) (let Parse_X (hd (hd V2373)) (let Parse_shen.<anymulti> (shen.<anymulti> (shen.pair (tl (hd V2373)) (shen.hdtl V2373))) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail)))) (fail)) YaccParse)) YaccParse)))

(defun shen.<whitespaces> (V2375) (let YaccParse (let Parse_shen.<whitespace> (shen.<whitespace> V2375) (if (not (= (fail) Parse_shen.<whitespace>)) (let Parse_shen.<whitespaces> (shen.<whitespaces> Parse_shen.<whitespace>) (if (not (= (fail) Parse_shen.<whitespaces>)) (shen.pair (hd Parse_shen.<whitespaces>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<whitespace> (shen.<whitespace> V2375) (if (not (= (fail) Parse_shen.<whitespace>)) (shen.pair (hd Parse_shen.<whitespace>) shen.skip) (fail))) YaccParse)))

(defun shen.<whitespace> (V2377) (if (cons? (hd V2377)) (let Parse_X (hd (hd V2377)) (if (let Parse_Case Parse_X (or (= Parse_Case 32) (or (= Parse_Case 13) (or (= Parse_Case 10) (= Parse_Case 9))))) (shen.pair (hd (shen.pair (tl (hd V2377)) (shen.hdtl V2377))) shen.skip) (fail))) (fail)))

(defun shen.cons_form (V2379) (cond ((= () V2379) ()) ((and (cons? V2379) (and (cons? (tl V2379)) (and (cons? (tl (tl V2379))) (and (= () (tl (tl (tl V2379)))) (= (hd (tl V2379)) bar!))))) (cons cons (cons (hd V2379) (tl (tl V2379))))) ((cons? V2379) (cons cons (cons (hd V2379) (cons (shen.cons_form (tl V2379)) ())))) (true (shen.f_error shen.cons_form))))

(defun shen.package-macro (V2384 V2385) (cond ((and (cons? V2384) (and (= $ (hd V2384)) (and (cons? (tl V2384)) (= () (tl (tl V2384)))))) (append (explode (hd (tl V2384))) V2385)) ((and (cons? V2384) (and (= package (hd V2384)) (and (cons? (tl V2384)) (and (= null (hd (tl V2384))) (cons? (tl (tl V2384))))))) (append (tl (tl (tl V2384))) V2385)) ((and (cons? V2384) (and (= package (hd V2384)) (and (cons? (tl V2384)) (cons? (tl (tl V2384)))))) (let ListofExceptions (shen.eval-without-macros (hd (tl (tl V2384)))) (let External (shen.record-exceptions ListofExceptions (hd (tl V2384))) (let PackageNameDot (intern (cn (str (hd (tl V2384))) ".")) (let ExpPackageNameDot (explode PackageNameDot) (let Packaged (shen.packageh PackageNameDot ListofExceptions (tl (tl (tl V2384))) ExpPackageNameDot) (let Internal (shen.record-internal (hd (tl V2384)) (shen.internal-symbols ExpPackageNameDot Packaged)) (append Packaged V2385)))))))) (true (cons V2384 V2385))))

(defun shen.record-exceptions (V2388 V2389) (let CurrExceptions (trap-error (get V2389 shen.external-symbols (value *property-vector*)) (lambda E ())) (let AllExceptions (union V2388 CurrExceptions) (put V2389 shen.external-symbols AllExceptions (value *property-vector*)))))

(defun shen.record-internal (V2392 V2393) (put V2392 shen.internal-symbols (union V2393 (trap-error (get V2392 shen.internal-symbols (value *property-vector*)) (lambda E ()))) (value *property-vector*)))

(defun shen.internal-symbols (V2404 V2405) (cond ((and (symbol? V2405) (shen.prefix? V2404 (explode V2405))) (cons V2405 ())) ((cons? V2405) (union (shen.internal-symbols V2404 (hd V2405)) (shen.internal-symbols V2404 (tl V2405)))) (true ())))

(defun shen.packageh (V2422 V2423 V2424 V2425) (cond ((cons? V2424) (cons (shen.packageh V2422 V2423 (hd V2424) V2425) (shen.packageh V2422 V2423 (tl V2424) V2425))) ((or (shen.sysfunc? V2424) (or (variable? V2424) (or (element? V2424 V2423) (or (shen.doubleunderline? V2424) (shen.singleunderline? V2424))))) V2424) ((and (symbol? V2424) (let ExplodeX (explode V2424) (and (not (shen.prefix? (cons "s" (cons "h" (cons "e" (cons "n" (cons "." ()))))) ExplodeX)) (not (shen.prefix? V2425 ExplodeX))))) (concat V2422 V2424)) (true V2424)))



