"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.typecheck (V3682 V3683) (let Curry (shen.curry V3682) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V3683)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V3685) (cond ((and (cons? V3685) (shen.special? (hd V3685))) (cons (hd V3685) (map (lambda Y (shen.curry Y)) (tl V3685)))) ((and (cons? V3685) (and (cons? (tl V3685)) (shen.extraspecial? (hd V3685)))) V3685) ((and (cons? V3685) (and (= type (hd V3685)) (and (cons? (tl V3685)) (and (cons? (tl (tl V3685))) (= () (tl (tl (tl V3685)))))))) (cons type (cons (shen.curry (hd (tl V3685))) (tl (tl V3685))))) ((and (cons? V3685) (and (cons? (tl V3685)) (cons? (tl (tl V3685))))) (shen.curry (cons (cons (hd V3685) (cons (hd (tl V3685)) ())) (tl (tl V3685))))) ((and (cons? V3685) (and (cons? (tl V3685)) (= () (tl (tl V3685))))) (cons (shen.curry (hd V3685)) (cons (shen.curry (hd (tl V3685))) ()))) (true V3685)))

(defun shen.special? (V3687) (element? V3687 (value shen.*special*)))

(defun shen.extraspecial? (V3689) (element? V3689 (value shen.*extraspecial*)))

(defun shen.t* (V3694 V3695 V3696 V3697) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V3696) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V3696 (freeze (bind Error (shen.errormaxinfs) V3696 V3697))))) (if (= Case false) (let Case (let V3674 (shen.lazyderef V3694 V3696) (if (= fail V3674) (do (shen.incinfs) (cut Throwcontrol V3696 (freeze (shen.prolog-failure V3696 V3697)))) false)) (if (= Case false) (let Case (let V3675 (shen.lazyderef V3694 V3696) (if (cons? V3675) (let X (hd V3675) (let V3676 (shen.lazyderef (tl V3675) V3696) (if (cons? V3676) (let V3677 (shen.lazyderef (hd V3676) V3696) (if (= : V3677) (let V3678 (shen.lazyderef (tl V3676) V3696) (if (cons? V3678) (let A (hd V3678) (let V3679 (shen.lazyderef (tl V3678) V3696) (if (= () V3679) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V3696 (freeze (cut Throwcontrol V3696 (freeze (shen.th* X A V3695 V3696 V3697)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V3696) (do (shen.incinfs) (shen.show V3694 V3695 V3696 (freeze (bind Datatypes (value shen.*datatypes*) V3696 (freeze (shen.udefs* V3694 V3695 Datatypes V3696 V3697))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V3703) (cond ((= + V3703) (set shen.*shen-type-theory-enabled?* true)) ((= - V3703) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V3714 V3715) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V3721 V3722 V3723 V3724 V3725) (let Case (let V3670 (shen.lazyderef V3723 V3724) (if (cons? V3670) (let D (hd V3670) (do (shen.incinfs) (call (cons D (cons V3721 (cons V3722 ()))) V3724 V3725))) false)) (if (= Case false) (let V3671 (shen.lazyderef V3723 V3724) (if (cons? V3671) (let Ds (tl V3671) (do (shen.incinfs) (shen.udefs* V3721 V3722 Ds V3724 V3725))) false)) Case)))

(defun shen.th* (V3731 V3732 V3733 V3734 V3735) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V3731 (cons : (cons V3732 ()))) V3733 V3734 (freeze (fwhen false V3734 V3735)))) (if (= Case false) (let Case (let F (shen.newpv V3734) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V3731 V3734)) V3734 (freeze (bind F (shen.sigf (shen.lazyderef V3731 V3734)) V3734 (freeze (call (cons F (cons V3732 ())) V3734 V3735))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V3731 V3732 V3734 V3735)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V3731 V3732 V3733 V3734 V3735)) (if (= Case false) (let Case (let V3566 (shen.lazyderef V3731 V3734) (if (cons? V3566) (let F (hd V3566) (let V3567 (shen.lazyderef (tl V3566) V3734) (if (= () V3567) (do (shen.incinfs) (shen.th* F (cons --> (cons V3732 ())) V3733 V3734 V3735)) false))) false)) (if (= Case false) (let Case (let V3568 (shen.lazyderef V3731 V3734) (if (cons? V3568) (let F (hd V3568) (let V3569 (shen.lazyderef (tl V3568) V3734) (if (cons? V3569) (let X (hd V3569) (let V3570 (shen.lazyderef (tl V3569) V3734) (if (= () V3570) (let B (shen.newpv V3734) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V3732 ()))) V3733 V3734 (freeze (shen.th* X B V3733 V3734 V3735))))) false))) false))) false)) (if (= Case false) (let Case (let V3571 (shen.lazyderef V3731 V3734) (if (cons? V3571) (let V3572 (shen.lazyderef (hd V3571) V3734) (if (= cons V3572) (let V3573 (shen.lazyderef (tl V3571) V3734) (if (cons? V3573) (let X (hd V3573) (let V3574 (shen.lazyderef (tl V3573) V3734) (if (cons? V3574) (let Y (hd V3574) (let V3575 (shen.lazyderef (tl V3574) V3734) (if (= () V3575) (let V3576 (shen.lazyderef V3732 V3734) (if (cons? V3576) (let V3577 (shen.lazyderef (hd V3576) V3734) (if (= list V3577) (let V3578 (shen.lazyderef (tl V3576) V3734) (if (cons? V3578) (let A (hd V3578) (let V3579 (shen.lazyderef (tl V3578) V3734) (if (= () V3579) (do (shen.incinfs) (shen.th* X A V3733 V3734 (freeze (shen.th* Y (cons list (cons A ())) V3733 V3734 V3735)))) (if (shen.pvar? V3579) (do (shen.bindv V3579 () V3734) (let Result (do (shen.incinfs) (shen.th* X A V3733 V3734 (freeze (shen.th* Y (cons list (cons A ())) V3733 V3734 V3735)))) (do (shen.unbindv V3579 V3734) Result))) false)))) (if (shen.pvar? V3578) (let A (shen.newpv V3734) (do (shen.bindv V3578 (cons A ()) V3734) (let Result (do (shen.incinfs) (shen.th* X A V3733 V3734 (freeze (shen.th* Y (cons list (cons A ())) V3733 V3734 V3735)))) (do (shen.unbindv V3578 V3734) Result)))) false))) (if (shen.pvar? V3577) (do (shen.bindv V3577 list V3734) (let Result (let V3580 (shen.lazyderef (tl V3576) V3734) (if (cons? V3580) (let A (hd V3580) (let V3581 (shen.lazyderef (tl V3580) V3734) (if (= () V3581) (do (shen.incinfs) (shen.th* X A V3733 V3734 (freeze (shen.th* Y (cons list (cons A ())) V3733 V3734 V3735)))) (if (shen.pvar? V3581) (do (shen.bindv V3581 () V3734) (let Result (do (shen.incinfs) (shen.th* X A V3733 V3734 (freeze (shen.th* Y (cons list (cons A ())) V3733 V3734 V3735)))) (do (shen.unbindv V3581 V3734) Result))) false)))) (if (shen.pvar? V3580) (let A (shen.newpv V3734) (do (shen.bindv V3580 (cons A ()) V3734) (let Result (do (shen.incinfs) (shen.th* X A V3733 V3734 (freeze (shen.th* Y (cons list (cons A ())) V3733 V3734 V3735)))) (do (shen.unbindv V3580 V3734) Result)))) false))) (do (shen.unbindv V3577 V3734) Result))) false))) (if (shen.pvar? V3576) (let A (shen.newpv V3734) (do (shen.bindv V3576 (cons list (cons A ())) V3734) (let Result (do (shen.incinfs) (shen.th* X A V3733 V3734 (freeze (shen.th* Y (cons list (cons A ())) V3733 V3734 V3735)))) (do (shen.unbindv V3576 V3734) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3582 (shen.lazyderef V3731 V3734) (if (cons? V3582) (let V3583 (shen.lazyderef (hd V3582) V3734) (if (= @p V3583) (let V3584 (shen.lazyderef (tl V3582) V3734) (if (cons? V3584) (let X (hd V3584) (let V3585 (shen.lazyderef (tl V3584) V3734) (if (cons? V3585) (let Y (hd V3585) (let V3586 (shen.lazyderef (tl V3585) V3734) (if (= () V3586) (let V3587 (shen.lazyderef V3732 V3734) (if (cons? V3587) (let A (hd V3587) (let V3588 (shen.lazyderef (tl V3587) V3734) (if (cons? V3588) (let V3589 (shen.lazyderef (hd V3588) V3734) (if (= * V3589) (let V3590 (shen.lazyderef (tl V3588) V3734) (if (cons? V3590) (let B (hd V3590) (let V3591 (shen.lazyderef (tl V3590) V3734) (if (= () V3591) (do (shen.incinfs) (shen.th* X A V3733 V3734 (freeze (shen.th* Y B V3733 V3734 V3735)))) (if (shen.pvar? V3591) (do (shen.bindv V3591 () V3734) (let Result (do (shen.incinfs) (shen.th* X A V3733 V3734 (freeze (shen.th* Y B V3733 V3734 V3735)))) (do (shen.unbindv V3591 V3734) Result))) false)))) (if (shen.pvar? V3590) (let B (shen.newpv V3734) (do (shen.bindv V3590 (cons B ()) V3734) (let Result (do (shen.incinfs) (shen.th* X A V3733 V3734 (freeze (shen.th* Y B V3733 V3734 V3735)))) (do (shen.unbindv V3590 V3734) Result)))) false))) (if (shen.pvar? V3589) (do (shen.bindv V3589 * V3734) (let Result (let V3592 (shen.lazyderef (tl V3588) V3734) (if (cons? V3592) (let B (hd V3592) (let V3593 (shen.lazyderef (tl V3592) V3734) (if (= () V3593) (do (shen.incinfs) (shen.th* X A V3733 V3734 (freeze (shen.th* Y B V3733 V3734 V3735)))) (if (shen.pvar? V3593) (do (shen.bindv V3593 () V3734) (let Result (do (shen.incinfs) (shen.th* X A V3733 V3734 (freeze (shen.th* Y B V3733 V3734 V3735)))) (do (shen.unbindv V3593 V3734) Result))) false)))) (if (shen.pvar? V3592) (let B (shen.newpv V3734) (do (shen.bindv V3592 (cons B ()) V3734) (let Result (do (shen.incinfs) (shen.th* X A V3733 V3734 (freeze (shen.th* Y B V3733 V3734 V3735)))) (do (shen.unbindv V3592 V3734) Result)))) false))) (do (shen.unbindv V3589 V3734) Result))) false))) (if (shen.pvar? V3588) (let B (shen.newpv V3734) (do (shen.bindv V3588 (cons * (cons B ())) V3734) (let Result (do (shen.incinfs) (shen.th* X A V3733 V3734 (freeze (shen.th* Y B V3733 V3734 V3735)))) (do (shen.unbindv V3588 V3734) Result)))) false)))) (if (shen.pvar? V3587) (let A (shen.newpv V3734) (let B (shen.newpv V3734) (do (shen.bindv V3587 (cons A (cons * (cons B ()))) V3734) (let Result (do (shen.incinfs) (shen.th* X A V3733 V3734 (freeze (shen.th* Y B V3733 V3734 V3735)))) (do (shen.unbindv V3587 V3734) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3594 (shen.lazyderef V3731 V3734) (if (cons? V3594) (let V3595 (shen.lazyderef (hd V3594) V3734) (if (= @v V3595) (let V3596 (shen.lazyderef (tl V3594) V3734) (if (cons? V3596) (let X (hd V3596) (let V3597 (shen.lazyderef (tl V3596) V3734) (if (cons? V3597) (let Y (hd V3597) (let V3598 (shen.lazyderef (tl V3597) V3734) (if (= () V3598) (let V3599 (shen.lazyderef V3732 V3734) (if (cons? V3599) (let V3600 (shen.lazyderef (hd V3599) V3734) (if (= vector V3600) (let V3601 (shen.lazyderef (tl V3599) V3734) (if (cons? V3601) (let A (hd V3601) (let V3602 (shen.lazyderef (tl V3601) V3734) (if (= () V3602) (do (shen.incinfs) (shen.th* X A V3733 V3734 (freeze (shen.th* Y (cons vector (cons A ())) V3733 V3734 V3735)))) (if (shen.pvar? V3602) (do (shen.bindv V3602 () V3734) (let Result (do (shen.incinfs) (shen.th* X A V3733 V3734 (freeze (shen.th* Y (cons vector (cons A ())) V3733 V3734 V3735)))) (do (shen.unbindv V3602 V3734) Result))) false)))) (if (shen.pvar? V3601) (let A (shen.newpv V3734) (do (shen.bindv V3601 (cons A ()) V3734) (let Result (do (shen.incinfs) (shen.th* X A V3733 V3734 (freeze (shen.th* Y (cons vector (cons A ())) V3733 V3734 V3735)))) (do (shen.unbindv V3601 V3734) Result)))) false))) (if (shen.pvar? V3600) (do (shen.bindv V3600 vector V3734) (let Result (let V3603 (shen.lazyderef (tl V3599) V3734) (if (cons? V3603) (let A (hd V3603) (let V3604 (shen.lazyderef (tl V3603) V3734) (if (= () V3604) (do (shen.incinfs) (shen.th* X A V3733 V3734 (freeze (shen.th* Y (cons vector (cons A ())) V3733 V3734 V3735)))) (if (shen.pvar? V3604) (do (shen.bindv V3604 () V3734) (let Result (do (shen.incinfs) (shen.th* X A V3733 V3734 (freeze (shen.th* Y (cons vector (cons A ())) V3733 V3734 V3735)))) (do (shen.unbindv V3604 V3734) Result))) false)))) (if (shen.pvar? V3603) (let A (shen.newpv V3734) (do (shen.bindv V3603 (cons A ()) V3734) (let Result (do (shen.incinfs) (shen.th* X A V3733 V3734 (freeze (shen.th* Y (cons vector (cons A ())) V3733 V3734 V3735)))) (do (shen.unbindv V3603 V3734) Result)))) false))) (do (shen.unbindv V3600 V3734) Result))) false))) (if (shen.pvar? V3599) (let A (shen.newpv V3734) (do (shen.bindv V3599 (cons vector (cons A ())) V3734) (let Result (do (shen.incinfs) (shen.th* X A V3733 V3734 (freeze (shen.th* Y (cons vector (cons A ())) V3733 V3734 V3735)))) (do (shen.unbindv V3599 V3734) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3605 (shen.lazyderef V3731 V3734) (if (cons? V3605) (let V3606 (shen.lazyderef (hd V3605) V3734) (if (= @s V3606) (let V3607 (shen.lazyderef (tl V3605) V3734) (if (cons? V3607) (let X (hd V3607) (let V3608 (shen.lazyderef (tl V3607) V3734) (if (cons? V3608) (let Y (hd V3608) (let V3609 (shen.lazyderef (tl V3608) V3734) (if (= () V3609) (let V3610 (shen.lazyderef V3732 V3734) (if (= string V3610) (do (shen.incinfs) (shen.th* X string V3733 V3734 (freeze (shen.th* Y string V3733 V3734 V3735)))) (if (shen.pvar? V3610) (do (shen.bindv V3610 string V3734) (let Result (do (shen.incinfs) (shen.th* X string V3733 V3734 (freeze (shen.th* Y string V3733 V3734 V3735)))) (do (shen.unbindv V3610 V3734) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3611 (shen.lazyderef V3731 V3734) (if (cons? V3611) (let V3612 (shen.lazyderef (hd V3611) V3734) (if (= lambda V3612) (let V3613 (shen.lazyderef (tl V3611) V3734) (if (cons? V3613) (let X (hd V3613) (let V3614 (shen.lazyderef (tl V3613) V3734) (if (cons? V3614) (let Y (hd V3614) (let V3615 (shen.lazyderef (tl V3614) V3734) (if (= () V3615) (let V3616 (shen.lazyderef V3732 V3734) (if (cons? V3616) (let A (hd V3616) (let V3617 (shen.lazyderef (tl V3616) V3734) (if (cons? V3617) (let V3618 (shen.lazyderef (hd V3617) V3734) (if (= --> V3618) (let V3619 (shen.lazyderef (tl V3617) V3734) (if (cons? V3619) (let B (hd V3619) (let V3620 (shen.lazyderef (tl V3619) V3734) (if (= () V3620) (let Z (shen.newpv V3734) (let X&& (shen.newpv V3734) (do (shen.incinfs) (cut Throwcontrol V3734 (freeze (bind X&& (shen.placeholder) V3734 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3734) (shen.lazyderef X V3734) (shen.lazyderef Y V3734)) V3734 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3733) V3734 V3735)))))))))) (if (shen.pvar? V3620) (do (shen.bindv V3620 () V3734) (let Result (let Z (shen.newpv V3734) (let X&& (shen.newpv V3734) (do (shen.incinfs) (cut Throwcontrol V3734 (freeze (bind X&& (shen.placeholder) V3734 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3734) (shen.lazyderef X V3734) (shen.lazyderef Y V3734)) V3734 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3733) V3734 V3735)))))))))) (do (shen.unbindv V3620 V3734) Result))) false)))) (if (shen.pvar? V3619) (let B (shen.newpv V3734) (do (shen.bindv V3619 (cons B ()) V3734) (let Result (let Z (shen.newpv V3734) (let X&& (shen.newpv V3734) (do (shen.incinfs) (cut Throwcontrol V3734 (freeze (bind X&& (shen.placeholder) V3734 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3734) (shen.lazyderef X V3734) (shen.lazyderef Y V3734)) V3734 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3733) V3734 V3735)))))))))) (do (shen.unbindv V3619 V3734) Result)))) false))) (if (shen.pvar? V3618) (do (shen.bindv V3618 --> V3734) (let Result (let V3621 (shen.lazyderef (tl V3617) V3734) (if (cons? V3621) (let B (hd V3621) (let V3622 (shen.lazyderef (tl V3621) V3734) (if (= () V3622) (let Z (shen.newpv V3734) (let X&& (shen.newpv V3734) (do (shen.incinfs) (cut Throwcontrol V3734 (freeze (bind X&& (shen.placeholder) V3734 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3734) (shen.lazyderef X V3734) (shen.lazyderef Y V3734)) V3734 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3733) V3734 V3735)))))))))) (if (shen.pvar? V3622) (do (shen.bindv V3622 () V3734) (let Result (let Z (shen.newpv V3734) (let X&& (shen.newpv V3734) (do (shen.incinfs) (cut Throwcontrol V3734 (freeze (bind X&& (shen.placeholder) V3734 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3734) (shen.lazyderef X V3734) (shen.lazyderef Y V3734)) V3734 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3733) V3734 V3735)))))))))) (do (shen.unbindv V3622 V3734) Result))) false)))) (if (shen.pvar? V3621) (let B (shen.newpv V3734) (do (shen.bindv V3621 (cons B ()) V3734) (let Result (let Z (shen.newpv V3734) (let X&& (shen.newpv V3734) (do (shen.incinfs) (cut Throwcontrol V3734 (freeze (bind X&& (shen.placeholder) V3734 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3734) (shen.lazyderef X V3734) (shen.lazyderef Y V3734)) V3734 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3733) V3734 V3735)))))))))) (do (shen.unbindv V3621 V3734) Result)))) false))) (do (shen.unbindv V3618 V3734) Result))) false))) (if (shen.pvar? V3617) (let B (shen.newpv V3734) (do (shen.bindv V3617 (cons --> (cons B ())) V3734) (let Result (let Z (shen.newpv V3734) (let X&& (shen.newpv V3734) (do (shen.incinfs) (cut Throwcontrol V3734 (freeze (bind X&& (shen.placeholder) V3734 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3734) (shen.lazyderef X V3734) (shen.lazyderef Y V3734)) V3734 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3733) V3734 V3735)))))))))) (do (shen.unbindv V3617 V3734) Result)))) false)))) (if (shen.pvar? V3616) (let A (shen.newpv V3734) (let B (shen.newpv V3734) (do (shen.bindv V3616 (cons A (cons --> (cons B ()))) V3734) (let Result (let Z (shen.newpv V3734) (let X&& (shen.newpv V3734) (do (shen.incinfs) (cut Throwcontrol V3734 (freeze (bind X&& (shen.placeholder) V3734 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3734) (shen.lazyderef X V3734) (shen.lazyderef Y V3734)) V3734 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3733) V3734 V3735)))))))))) (do (shen.unbindv V3616 V3734) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3623 (shen.lazyderef V3731 V3734) (if (cons? V3623) (let V3624 (shen.lazyderef (hd V3623) V3734) (if (= let V3624) (let V3625 (shen.lazyderef (tl V3623) V3734) (if (cons? V3625) (let X (hd V3625) (let V3626 (shen.lazyderef (tl V3625) V3734) (if (cons? V3626) (let Y (hd V3626) (let V3627 (shen.lazyderef (tl V3626) V3734) (if (cons? V3627) (let Z (hd V3627) (let V3628 (shen.lazyderef (tl V3627) V3734) (if (= () V3628) (let W (shen.newpv V3734) (let X&& (shen.newpv V3734) (let B (shen.newpv V3734) (do (shen.incinfs) (shen.th* Y B V3733 V3734 (freeze (bind X&& (shen.placeholder) V3734 (freeze (bind W (shen.ebr (shen.lazyderef X&& V3734) (shen.lazyderef X V3734) (shen.lazyderef Z V3734)) V3734 (freeze (shen.th* W V3732 (cons (cons X&& (cons : (cons B ()))) V3733) V3734 V3735))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3629 (shen.lazyderef V3731 V3734) (if (cons? V3629) (let V3630 (shen.lazyderef (hd V3629) V3734) (if (= open V3630) (let V3631 (shen.lazyderef (tl V3629) V3734) (if (cons? V3631) (let FileName (hd V3631) (let V3632 (shen.lazyderef (tl V3631) V3734) (if (cons? V3632) (let Direction3562 (hd V3632) (let V3633 (shen.lazyderef (tl V3632) V3734) (if (= () V3633) (let V3634 (shen.lazyderef V3732 V3734) (if (cons? V3634) (let V3635 (shen.lazyderef (hd V3634) V3734) (if (= stream V3635) (let V3636 (shen.lazyderef (tl V3634) V3734) (if (cons? V3636) (let Direction (hd V3636) (let V3637 (shen.lazyderef (tl V3636) V3734) (if (= () V3637) (do (shen.incinfs) (unify! Direction Direction3562 V3734 (freeze (cut Throwcontrol V3734 (freeze (fwhen (element? (shen.lazyderef Direction V3734) (cons in (cons out ()))) V3734 (freeze (shen.th* FileName string V3733 V3734 V3735)))))))) (if (shen.pvar? V3637) (do (shen.bindv V3637 () V3734) (let Result (do (shen.incinfs) (unify! Direction Direction3562 V3734 (freeze (cut Throwcontrol V3734 (freeze (fwhen (element? (shen.lazyderef Direction V3734) (cons in (cons out ()))) V3734 (freeze (shen.th* FileName string V3733 V3734 V3735)))))))) (do (shen.unbindv V3637 V3734) Result))) false)))) (if (shen.pvar? V3636) (let Direction (shen.newpv V3734) (do (shen.bindv V3636 (cons Direction ()) V3734) (let Result (do (shen.incinfs) (unify! Direction Direction3562 V3734 (freeze (cut Throwcontrol V3734 (freeze (fwhen (element? (shen.lazyderef Direction V3734) (cons in (cons out ()))) V3734 (freeze (shen.th* FileName string V3733 V3734 V3735)))))))) (do (shen.unbindv V3636 V3734) Result)))) false))) (if (shen.pvar? V3635) (do (shen.bindv V3635 stream V3734) (let Result (let V3638 (shen.lazyderef (tl V3634) V3734) (if (cons? V3638) (let Direction (hd V3638) (let V3639 (shen.lazyderef (tl V3638) V3734) (if (= () V3639) (do (shen.incinfs) (unify! Direction Direction3562 V3734 (freeze (cut Throwcontrol V3734 (freeze (fwhen (element? (shen.lazyderef Direction V3734) (cons in (cons out ()))) V3734 (freeze (shen.th* FileName string V3733 V3734 V3735)))))))) (if (shen.pvar? V3639) (do (shen.bindv V3639 () V3734) (let Result (do (shen.incinfs) (unify! Direction Direction3562 V3734 (freeze (cut Throwcontrol V3734 (freeze (fwhen (element? (shen.lazyderef Direction V3734) (cons in (cons out ()))) V3734 (freeze (shen.th* FileName string V3733 V3734 V3735)))))))) (do (shen.unbindv V3639 V3734) Result))) false)))) (if (shen.pvar? V3638) (let Direction (shen.newpv V3734) (do (shen.bindv V3638 (cons Direction ()) V3734) (let Result (do (shen.incinfs) (unify! Direction Direction3562 V3734 (freeze (cut Throwcontrol V3734 (freeze (fwhen (element? (shen.lazyderef Direction V3734) (cons in (cons out ()))) V3734 (freeze (shen.th* FileName string V3733 V3734 V3735)))))))) (do (shen.unbindv V3638 V3734) Result)))) false))) (do (shen.unbindv V3635 V3734) Result))) false))) (if (shen.pvar? V3634) (let Direction (shen.newpv V3734) (do (shen.bindv V3634 (cons stream (cons Direction ())) V3734) (let Result (do (shen.incinfs) (unify! Direction Direction3562 V3734 (freeze (cut Throwcontrol V3734 (freeze (fwhen (element? (shen.lazyderef Direction V3734) (cons in (cons out ()))) V3734 (freeze (shen.th* FileName string V3733 V3734 V3735)))))))) (do (shen.unbindv V3634 V3734) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3640 (shen.lazyderef V3731 V3734) (if (cons? V3640) (let V3641 (shen.lazyderef (hd V3640) V3734) (if (= type V3641) (let V3642 (shen.lazyderef (tl V3640) V3734) (if (cons? V3642) (let X (hd V3642) (let V3643 (shen.lazyderef (tl V3642) V3734) (if (cons? V3643) (let A (hd V3643) (let V3644 (shen.lazyderef (tl V3643) V3734) (if (= () V3644) (do (shen.incinfs) (cut Throwcontrol V3734 (freeze (unify A V3732 V3734 (freeze (shen.th* X A V3733 V3734 V3735)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3645 (shen.lazyderef V3731 V3734) (if (cons? V3645) (let V3646 (shen.lazyderef (hd V3645) V3734) (if (= input+ V3646) (let V3647 (shen.lazyderef (tl V3645) V3734) (if (cons? V3647) (let A (hd V3647) (let V3648 (shen.lazyderef (tl V3647) V3734) (if (cons? V3648) (let Stream (hd V3648) (let V3649 (shen.lazyderef (tl V3648) V3734) (if (= () V3649) (let C (shen.newpv V3734) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V3734)) V3734 (freeze (unify V3732 C V3734 (freeze (shen.th* Stream (cons stream (cons in ())) V3733 V3734 V3735))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3650 (shen.lazyderef V3731 V3734) (if (cons? V3650) (let V3651 (shen.lazyderef (hd V3650) V3734) (if (= set V3651) (let V3652 (shen.lazyderef (tl V3650) V3734) (if (cons? V3652) (let Var (hd V3652) (let V3653 (shen.lazyderef (tl V3652) V3734) (if (cons? V3653) (let Val (hd V3653) (let V3654 (shen.lazyderef (tl V3653) V3734) (if (= () V3654) (do (shen.incinfs) (cut Throwcontrol V3734 (freeze (shen.th* Var symbol V3733 V3734 (freeze (cut Throwcontrol V3734 (freeze (shen.th* (cons value (cons Var ())) V3732 V3733 V3734 (freeze (shen.th* Val V3732 V3733 V3734 V3735)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V3734) (do (shen.incinfs) (shen.t*-hyps V3733 NewHyp V3734 (freeze (shen.th* V3731 V3732 NewHyp V3734 V3735))))) (if (= Case false) (let Case (let V3655 (shen.lazyderef V3731 V3734) (if (cons? V3655) (let V3656 (shen.lazyderef (hd V3655) V3734) (if (= define V3656) (let V3657 (shen.lazyderef (tl V3655) V3734) (if (cons? V3657) (let F (hd V3657) (let X (tl V3657) (do (shen.incinfs) (cut Throwcontrol V3734 (freeze (shen.t*-def (cons define (cons F X)) V3732 V3733 V3734 V3735)))))) false)) false)) false)) (if (= Case false) (let Case (let V3658 (shen.lazyderef V3731 V3734) (if (cons? V3658) (let V3659 (shen.lazyderef (hd V3658) V3734) (if (= defmacro V3659) (let V3660 (shen.lazyderef V3732 V3734) (if (= unit V3660) (do (shen.incinfs) (cut Throwcontrol V3734 V3735)) (if (shen.pvar? V3660) (do (shen.bindv V3660 unit V3734) (let Result (do (shen.incinfs) (cut Throwcontrol V3734 V3735)) (do (shen.unbindv V3660 V3734) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3661 (shen.lazyderef V3731 V3734) (if (cons? V3661) (let V3662 (shen.lazyderef (hd V3661) V3734) (if (= shen.process-datatype V3662) (let V3663 (shen.lazyderef V3732 V3734) (if (= symbol V3663) (do (shen.incinfs) (thaw V3735)) (if (shen.pvar? V3663) (do (shen.bindv V3663 symbol V3734) (let Result (do (shen.incinfs) (thaw V3735)) (do (shen.unbindv V3663 V3734) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3664 (shen.lazyderef V3731 V3734) (if (cons? V3664) (let V3665 (shen.lazyderef (hd V3664) V3734) (if (= shen.synonyms-help V3665) (let V3666 (shen.lazyderef V3732 V3734) (if (= symbol V3666) (do (shen.incinfs) (thaw V3735)) (if (shen.pvar? V3666) (do (shen.bindv V3666 symbol V3734) (let Result (do (shen.incinfs) (thaw V3735)) (do (shen.unbindv V3666 V3734) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V3734) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V3734 (freeze (shen.udefs* (cons V3731 (cons : (cons V3732 ()))) V3733 Datatypes V3734 V3735))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V3740 V3741 V3742 V3743) (let Case (let V3477 (shen.lazyderef V3740 V3742) (if (cons? V3477) (let V3478 (shen.lazyderef (hd V3477) V3742) (if (cons? V3478) (let V3479 (shen.lazyderef (hd V3478) V3742) (if (cons? V3479) (let V3480 (shen.lazyderef (hd V3479) V3742) (if (= cons V3480) (let V3481 (shen.lazyderef (tl V3479) V3742) (if (cons? V3481) (let X (hd V3481) (let V3482 (shen.lazyderef (tl V3481) V3742) (if (cons? V3482) (let Y (hd V3482) (let V3483 (shen.lazyderef (tl V3482) V3742) (if (= () V3483) (let V3484 (shen.lazyderef (tl V3478) V3742) (if (cons? V3484) (let V3485 (shen.lazyderef (hd V3484) V3742) (if (= : V3485) (let V3486 (shen.lazyderef (tl V3484) V3742) (if (cons? V3486) (let V3487 (shen.lazyderef (hd V3486) V3742) (if (cons? V3487) (let V3488 (shen.lazyderef (hd V3487) V3742) (if (= list V3488) (let V3489 (shen.lazyderef (tl V3487) V3742) (if (cons? V3489) (let A (hd V3489) (let V3490 (shen.lazyderef (tl V3489) V3742) (if (= () V3490) (let V3491 (shen.lazyderef (tl V3486) V3742) (if (= () V3491) (let Hyp (tl V3477) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons list (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (if (shen.pvar? V3491) (do (shen.bindv V3491 () V3742) (let Result (let Hyp (tl V3477) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons list (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (do (shen.unbindv V3491 V3742) Result))) false))) (if (shen.pvar? V3490) (do (shen.bindv V3490 () V3742) (let Result (let V3492 (shen.lazyderef (tl V3486) V3742) (if (= () V3492) (let Hyp (tl V3477) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons list (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (if (shen.pvar? V3492) (do (shen.bindv V3492 () V3742) (let Result (let Hyp (tl V3477) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons list (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (do (shen.unbindv V3492 V3742) Result))) false))) (do (shen.unbindv V3490 V3742) Result))) false)))) (if (shen.pvar? V3489) (let A (shen.newpv V3742) (do (shen.bindv V3489 (cons A ()) V3742) (let Result (let V3493 (shen.lazyderef (tl V3486) V3742) (if (= () V3493) (let Hyp (tl V3477) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons list (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (if (shen.pvar? V3493) (do (shen.bindv V3493 () V3742) (let Result (let Hyp (tl V3477) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons list (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (do (shen.unbindv V3493 V3742) Result))) false))) (do (shen.unbindv V3489 V3742) Result)))) false))) (if (shen.pvar? V3488) (do (shen.bindv V3488 list V3742) (let Result (let V3494 (shen.lazyderef (tl V3487) V3742) (if (cons? V3494) (let A (hd V3494) (let V3495 (shen.lazyderef (tl V3494) V3742) (if (= () V3495) (let V3496 (shen.lazyderef (tl V3486) V3742) (if (= () V3496) (let Hyp (tl V3477) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons list (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (if (shen.pvar? V3496) (do (shen.bindv V3496 () V3742) (let Result (let Hyp (tl V3477) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons list (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (do (shen.unbindv V3496 V3742) Result))) false))) (if (shen.pvar? V3495) (do (shen.bindv V3495 () V3742) (let Result (let V3497 (shen.lazyderef (tl V3486) V3742) (if (= () V3497) (let Hyp (tl V3477) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons list (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (if (shen.pvar? V3497) (do (shen.bindv V3497 () V3742) (let Result (let Hyp (tl V3477) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons list (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (do (shen.unbindv V3497 V3742) Result))) false))) (do (shen.unbindv V3495 V3742) Result))) false)))) (if (shen.pvar? V3494) (let A (shen.newpv V3742) (do (shen.bindv V3494 (cons A ()) V3742) (let Result (let V3498 (shen.lazyderef (tl V3486) V3742) (if (= () V3498) (let Hyp (tl V3477) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons list (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (if (shen.pvar? V3498) (do (shen.bindv V3498 () V3742) (let Result (let Hyp (tl V3477) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons list (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (do (shen.unbindv V3498 V3742) Result))) false))) (do (shen.unbindv V3494 V3742) Result)))) false))) (do (shen.unbindv V3488 V3742) Result))) false))) (if (shen.pvar? V3487) (let A (shen.newpv V3742) (do (shen.bindv V3487 (cons list (cons A ())) V3742) (let Result (let V3499 (shen.lazyderef (tl V3486) V3742) (if (= () V3499) (let Hyp (tl V3477) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons list (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (if (shen.pvar? V3499) (do (shen.bindv V3499 () V3742) (let Result (let Hyp (tl V3477) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons list (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (do (shen.unbindv V3499 V3742) Result))) false))) (do (shen.unbindv V3487 V3742) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3500 (shen.lazyderef V3740 V3742) (if (cons? V3500) (let V3501 (shen.lazyderef (hd V3500) V3742) (if (cons? V3501) (let V3502 (shen.lazyderef (hd V3501) V3742) (if (cons? V3502) (let V3503 (shen.lazyderef (hd V3502) V3742) (if (= @p V3503) (let V3504 (shen.lazyderef (tl V3502) V3742) (if (cons? V3504) (let X (hd V3504) (let V3505 (shen.lazyderef (tl V3504) V3742) (if (cons? V3505) (let Y (hd V3505) (let V3506 (shen.lazyderef (tl V3505) V3742) (if (= () V3506) (let V3507 (shen.lazyderef (tl V3501) V3742) (if (cons? V3507) (let V3508 (shen.lazyderef (hd V3507) V3742) (if (= : V3508) (let V3509 (shen.lazyderef (tl V3507) V3742) (if (cons? V3509) (let V3510 (shen.lazyderef (hd V3509) V3742) (if (cons? V3510) (let A (hd V3510) (let V3511 (shen.lazyderef (tl V3510) V3742) (if (cons? V3511) (let V3512 (shen.lazyderef (hd V3511) V3742) (if (= * V3512) (let V3513 (shen.lazyderef (tl V3511) V3742) (if (cons? V3513) (let B (hd V3513) (let V3514 (shen.lazyderef (tl V3513) V3742) (if (= () V3514) (let V3515 (shen.lazyderef (tl V3509) V3742) (if (= () V3515) (let Hyp (tl V3500) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (shen.lazyderef B V3742) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (if (shen.pvar? V3515) (do (shen.bindv V3515 () V3742) (let Result (let Hyp (tl V3500) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (shen.lazyderef B V3742) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (do (shen.unbindv V3515 V3742) Result))) false))) (if (shen.pvar? V3514) (do (shen.bindv V3514 () V3742) (let Result (let V3516 (shen.lazyderef (tl V3509) V3742) (if (= () V3516) (let Hyp (tl V3500) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (shen.lazyderef B V3742) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (if (shen.pvar? V3516) (do (shen.bindv V3516 () V3742) (let Result (let Hyp (tl V3500) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (shen.lazyderef B V3742) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (do (shen.unbindv V3516 V3742) Result))) false))) (do (shen.unbindv V3514 V3742) Result))) false)))) (if (shen.pvar? V3513) (let B (shen.newpv V3742) (do (shen.bindv V3513 (cons B ()) V3742) (let Result (let V3517 (shen.lazyderef (tl V3509) V3742) (if (= () V3517) (let Hyp (tl V3500) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (shen.lazyderef B V3742) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (if (shen.pvar? V3517) (do (shen.bindv V3517 () V3742) (let Result (let Hyp (tl V3500) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (shen.lazyderef B V3742) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (do (shen.unbindv V3517 V3742) Result))) false))) (do (shen.unbindv V3513 V3742) Result)))) false))) (if (shen.pvar? V3512) (do (shen.bindv V3512 * V3742) (let Result (let V3518 (shen.lazyderef (tl V3511) V3742) (if (cons? V3518) (let B (hd V3518) (let V3519 (shen.lazyderef (tl V3518) V3742) (if (= () V3519) (let V3520 (shen.lazyderef (tl V3509) V3742) (if (= () V3520) (let Hyp (tl V3500) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (shen.lazyderef B V3742) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (if (shen.pvar? V3520) (do (shen.bindv V3520 () V3742) (let Result (let Hyp (tl V3500) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (shen.lazyderef B V3742) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (do (shen.unbindv V3520 V3742) Result))) false))) (if (shen.pvar? V3519) (do (shen.bindv V3519 () V3742) (let Result (let V3521 (shen.lazyderef (tl V3509) V3742) (if (= () V3521) (let Hyp (tl V3500) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (shen.lazyderef B V3742) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (if (shen.pvar? V3521) (do (shen.bindv V3521 () V3742) (let Result (let Hyp (tl V3500) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (shen.lazyderef B V3742) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (do (shen.unbindv V3521 V3742) Result))) false))) (do (shen.unbindv V3519 V3742) Result))) false)))) (if (shen.pvar? V3518) (let B (shen.newpv V3742) (do (shen.bindv V3518 (cons B ()) V3742) (let Result (let V3522 (shen.lazyderef (tl V3509) V3742) (if (= () V3522) (let Hyp (tl V3500) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (shen.lazyderef B V3742) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (if (shen.pvar? V3522) (do (shen.bindv V3522 () V3742) (let Result (let Hyp (tl V3500) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (shen.lazyderef B V3742) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (do (shen.unbindv V3522 V3742) Result))) false))) (do (shen.unbindv V3518 V3742) Result)))) false))) (do (shen.unbindv V3512 V3742) Result))) false))) (if (shen.pvar? V3511) (let B (shen.newpv V3742) (do (shen.bindv V3511 (cons * (cons B ())) V3742) (let Result (let V3523 (shen.lazyderef (tl V3509) V3742) (if (= () V3523) (let Hyp (tl V3500) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (shen.lazyderef B V3742) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (if (shen.pvar? V3523) (do (shen.bindv V3523 () V3742) (let Result (let Hyp (tl V3500) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (shen.lazyderef B V3742) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (do (shen.unbindv V3523 V3742) Result))) false))) (do (shen.unbindv V3511 V3742) Result)))) false)))) (if (shen.pvar? V3510) (let A (shen.newpv V3742) (let B (shen.newpv V3742) (do (shen.bindv V3510 (cons A (cons * (cons B ()))) V3742) (let Result (let V3524 (shen.lazyderef (tl V3509) V3742) (if (= () V3524) (let Hyp (tl V3500) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (shen.lazyderef B V3742) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (if (shen.pvar? V3524) (do (shen.bindv V3524 () V3742) (let Result (let Hyp (tl V3500) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (shen.lazyderef B V3742) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (do (shen.unbindv V3524 V3742) Result))) false))) (do (shen.unbindv V3510 V3742) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3525 (shen.lazyderef V3740 V3742) (if (cons? V3525) (let V3526 (shen.lazyderef (hd V3525) V3742) (if (cons? V3526) (let V3527 (shen.lazyderef (hd V3526) V3742) (if (cons? V3527) (let V3528 (shen.lazyderef (hd V3527) V3742) (if (= @v V3528) (let V3529 (shen.lazyderef (tl V3527) V3742) (if (cons? V3529) (let X (hd V3529) (let V3530 (shen.lazyderef (tl V3529) V3742) (if (cons? V3530) (let Y (hd V3530) (let V3531 (shen.lazyderef (tl V3530) V3742) (if (= () V3531) (let V3532 (shen.lazyderef (tl V3526) V3742) (if (cons? V3532) (let V3533 (shen.lazyderef (hd V3532) V3742) (if (= : V3533) (let V3534 (shen.lazyderef (tl V3532) V3742) (if (cons? V3534) (let V3535 (shen.lazyderef (hd V3534) V3742) (if (cons? V3535) (let V3536 (shen.lazyderef (hd V3535) V3742) (if (= vector V3536) (let V3537 (shen.lazyderef (tl V3535) V3742) (if (cons? V3537) (let A (hd V3537) (let V3538 (shen.lazyderef (tl V3537) V3742) (if (= () V3538) (let V3539 (shen.lazyderef (tl V3534) V3742) (if (= () V3539) (let Hyp (tl V3525) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons vector (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (if (shen.pvar? V3539) (do (shen.bindv V3539 () V3742) (let Result (let Hyp (tl V3525) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons vector (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (do (shen.unbindv V3539 V3742) Result))) false))) (if (shen.pvar? V3538) (do (shen.bindv V3538 () V3742) (let Result (let V3540 (shen.lazyderef (tl V3534) V3742) (if (= () V3540) (let Hyp (tl V3525) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons vector (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (if (shen.pvar? V3540) (do (shen.bindv V3540 () V3742) (let Result (let Hyp (tl V3525) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons vector (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (do (shen.unbindv V3540 V3742) Result))) false))) (do (shen.unbindv V3538 V3742) Result))) false)))) (if (shen.pvar? V3537) (let A (shen.newpv V3742) (do (shen.bindv V3537 (cons A ()) V3742) (let Result (let V3541 (shen.lazyderef (tl V3534) V3742) (if (= () V3541) (let Hyp (tl V3525) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons vector (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (if (shen.pvar? V3541) (do (shen.bindv V3541 () V3742) (let Result (let Hyp (tl V3525) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons vector (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (do (shen.unbindv V3541 V3742) Result))) false))) (do (shen.unbindv V3537 V3742) Result)))) false))) (if (shen.pvar? V3536) (do (shen.bindv V3536 vector V3742) (let Result (let V3542 (shen.lazyderef (tl V3535) V3742) (if (cons? V3542) (let A (hd V3542) (let V3543 (shen.lazyderef (tl V3542) V3742) (if (= () V3543) (let V3544 (shen.lazyderef (tl V3534) V3742) (if (= () V3544) (let Hyp (tl V3525) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons vector (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (if (shen.pvar? V3544) (do (shen.bindv V3544 () V3742) (let Result (let Hyp (tl V3525) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons vector (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (do (shen.unbindv V3544 V3742) Result))) false))) (if (shen.pvar? V3543) (do (shen.bindv V3543 () V3742) (let Result (let V3545 (shen.lazyderef (tl V3534) V3742) (if (= () V3545) (let Hyp (tl V3525) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons vector (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (if (shen.pvar? V3545) (do (shen.bindv V3545 () V3742) (let Result (let Hyp (tl V3525) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons vector (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (do (shen.unbindv V3545 V3742) Result))) false))) (do (shen.unbindv V3543 V3742) Result))) false)))) (if (shen.pvar? V3542) (let A (shen.newpv V3742) (do (shen.bindv V3542 (cons A ()) V3742) (let Result (let V3546 (shen.lazyderef (tl V3534) V3742) (if (= () V3546) (let Hyp (tl V3525) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons vector (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (if (shen.pvar? V3546) (do (shen.bindv V3546 () V3742) (let Result (let Hyp (tl V3525) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons vector (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (do (shen.unbindv V3546 V3742) Result))) false))) (do (shen.unbindv V3542 V3742) Result)))) false))) (do (shen.unbindv V3536 V3742) Result))) false))) (if (shen.pvar? V3535) (let A (shen.newpv V3742) (do (shen.bindv V3535 (cons vector (cons A ())) V3742) (let Result (let V3547 (shen.lazyderef (tl V3534) V3742) (if (= () V3547) (let Hyp (tl V3525) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons vector (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (if (shen.pvar? V3547) (do (shen.bindv V3547 () V3742) (let Result (let Hyp (tl V3525) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons (shen.lazyderef A V3742) ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons (cons vector (cons (shen.lazyderef A V3742) ())) ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (do (shen.unbindv V3547 V3742) Result))) false))) (do (shen.unbindv V3535 V3742) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3548 (shen.lazyderef V3740 V3742) (if (cons? V3548) (let V3549 (shen.lazyderef (hd V3548) V3742) (if (cons? V3549) (let V3550 (shen.lazyderef (hd V3549) V3742) (if (cons? V3550) (let V3551 (shen.lazyderef (hd V3550) V3742) (if (= @s V3551) (let V3552 (shen.lazyderef (tl V3550) V3742) (if (cons? V3552) (let X (hd V3552) (let V3553 (shen.lazyderef (tl V3552) V3742) (if (cons? V3553) (let Y (hd V3553) (let V3554 (shen.lazyderef (tl V3553) V3742) (if (= () V3554) (let V3555 (shen.lazyderef (tl V3549) V3742) (if (cons? V3555) (let V3556 (shen.lazyderef (hd V3555) V3742) (if (= : V3556) (let V3557 (shen.lazyderef (tl V3555) V3742) (if (cons? V3557) (let V3558 (shen.lazyderef (hd V3557) V3742) (if (= string V3558) (let V3559 (shen.lazyderef (tl V3557) V3742) (if (= () V3559) (let Hyp (tl V3548) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons string ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (if (shen.pvar? V3559) (do (shen.bindv V3559 () V3742) (let Result (let Hyp (tl V3548) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons string ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (do (shen.unbindv V3559 V3742) Result))) false))) (if (shen.pvar? V3558) (do (shen.bindv V3558 string V3742) (let Result (let V3560 (shen.lazyderef (tl V3557) V3742) (if (= () V3560) (let Hyp (tl V3548) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons string ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (if (shen.pvar? V3560) (do (shen.bindv V3560 () V3742) (let Result (let Hyp (tl V3548) (do (shen.incinfs) (bind V3741 (cons (cons (shen.lazyderef X V3742) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3742) (cons : (cons string ()))) (shen.lazyderef Hyp V3742))) V3742 V3743))) (do (shen.unbindv V3560 V3742) Result))) false))) (do (shen.unbindv V3558 V3742) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V3561 (shen.lazyderef V3740 V3742) (if (cons? V3561) (let X (hd V3561) (let Hyp (tl V3561) (let NewHyps (shen.newpv V3742) (do (shen.incinfs) (bind V3741 (cons (shen.lazyderef X V3742) (shen.lazyderef NewHyps V3742)) V3742 (freeze (shen.t*-hyps Hyp NewHyps V3742 V3743))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V3760 V3761 V3762 V3763) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V3760 V3762)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V3761 V3762) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V3763))))))))) (true (thaw V3763))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V3765) (cond ((and (cons? V3765) (and (cons? (tl V3765)) (and (= : (hd (tl V3765))) (and (cons? (tl (tl V3765))) (= () (tl (tl (tl V3765)))))))) (shen.prhush (shen.app (hd V3765) (cn " : " (shen.app (hd (tl (tl V3765))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V3765 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V3770 V3771) (cond ((= () V3770) shen.skip) ((cons? V3770) (do (shen.prhush (shen.app V3771 ". " shen.a) (stoutput)) (do (shen.show-p (hd V3770)) (do (nl 1) (shen.show-assumptions (tl V3770) (+ V3771 1)))))) (true (shen.f_error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V3773) (cons? (assoc V3773 (value shen.*signedfuncs*))))

(defun shen.sigf (V3775) (concat shen.type-signature-of- V3775))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V3780 V3781 V3782 V3783) (let Case (let V3464 (shen.lazyderef V3781 V3782) (if (= number V3464) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3780 V3782)) V3782 V3783)) (if (shen.pvar? V3464) (do (shen.bindv V3464 number V3782) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3780 V3782)) V3782 V3783)) (do (shen.unbindv V3464 V3782) Result))) false))) (if (= Case false) (let Case (let V3465 (shen.lazyderef V3781 V3782) (if (= boolean V3465) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3780 V3782)) V3782 V3783)) (if (shen.pvar? V3465) (do (shen.bindv V3465 boolean V3782) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3780 V3782)) V3782 V3783)) (do (shen.unbindv V3465 V3782) Result))) false))) (if (= Case false) (let Case (let V3466 (shen.lazyderef V3781 V3782) (if (= string V3466) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3780 V3782)) V3782 V3783)) (if (shen.pvar? V3466) (do (shen.bindv V3466 string V3782) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3780 V3782)) V3782 V3783)) (do (shen.unbindv V3466 V3782) Result))) false))) (if (= Case false) (let Case (let V3467 (shen.lazyderef V3781 V3782) (if (= symbol V3467) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3780 V3782)) V3782 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3780 V3782))) V3782 V3783)))) (if (shen.pvar? V3467) (do (shen.bindv V3467 symbol V3782) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3780 V3782)) V3782 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3780 V3782))) V3782 V3783)))) (do (shen.unbindv V3467 V3782) Result))) false))) (if (= Case false) (let V3468 (shen.lazyderef V3780 V3782) (if (= () V3468) (let V3469 (shen.lazyderef V3781 V3782) (if (cons? V3469) (let V3470 (shen.lazyderef (hd V3469) V3782) (if (= list V3470) (let V3471 (shen.lazyderef (tl V3469) V3782) (if (cons? V3471) (let A (hd V3471) (let V3472 (shen.lazyderef (tl V3471) V3782) (if (= () V3472) (do (shen.incinfs) (thaw V3783)) (if (shen.pvar? V3472) (do (shen.bindv V3472 () V3782) (let Result (do (shen.incinfs) (thaw V3783)) (do (shen.unbindv V3472 V3782) Result))) false)))) (if (shen.pvar? V3471) (let A (shen.newpv V3782) (do (shen.bindv V3471 (cons A ()) V3782) (let Result (do (shen.incinfs) (thaw V3783)) (do (shen.unbindv V3471 V3782) Result)))) false))) (if (shen.pvar? V3470) (do (shen.bindv V3470 list V3782) (let Result (let V3473 (shen.lazyderef (tl V3469) V3782) (if (cons? V3473) (let A (hd V3473) (let V3474 (shen.lazyderef (tl V3473) V3782) (if (= () V3474) (do (shen.incinfs) (thaw V3783)) (if (shen.pvar? V3474) (do (shen.bindv V3474 () V3782) (let Result (do (shen.incinfs) (thaw V3783)) (do (shen.unbindv V3474 V3782) Result))) false)))) (if (shen.pvar? V3473) (let A (shen.newpv V3782) (do (shen.bindv V3473 (cons A ()) V3782) (let Result (do (shen.incinfs) (thaw V3783)) (do (shen.unbindv V3473 V3782) Result)))) false))) (do (shen.unbindv V3470 V3782) Result))) false))) (if (shen.pvar? V3469) (let A (shen.newpv V3782) (do (shen.bindv V3469 (cons list (cons A ())) V3782) (let Result (do (shen.incinfs) (thaw V3783)) (do (shen.unbindv V3469 V3782) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V3789 V3790 V3791 V3792 V3793) (let Case (let V3455 (shen.lazyderef V3791 V3792) (if (cons? V3455) (let V3456 (shen.lazyderef (hd V3455) V3792) (if (cons? V3456) (let Y (hd V3456) (let V3457 (shen.lazyderef (tl V3456) V3792) (if (cons? V3457) (let V3458 (shen.lazyderef (hd V3457) V3792) (if (= : V3458) (let V3459 (shen.lazyderef (tl V3457) V3792) (if (cons? V3459) (let B (hd V3459) (let V3460 (shen.lazyderef (tl V3459) V3792) (if (= () V3460) (do (shen.incinfs) (identical V3789 Y V3792 (freeze (unify! V3790 B V3792 V3793)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V3461 (shen.lazyderef V3791 V3792) (if (cons? V3461) (let Hyp (tl V3461) (do (shen.incinfs) (shen.by_hypothesis V3789 V3790 Hyp V3792 V3793))) false)) Case)))

(defun shen.t*-def (V3799 V3800 V3801 V3802 V3803) (let V3449 (shen.lazyderef V3799 V3802) (if (cons? V3449) (let V3450 (shen.lazyderef (hd V3449) V3802) (if (= define V3450) (let V3451 (shen.lazyderef (tl V3449) V3802) (if (cons? V3451) (let F (hd V3451) (let X (tl V3451) (let Y (shen.newpv V3802) (let E (shen.newpv V3802) (do (shen.incinfs) (shen.t*-defh (compile (lambda Y (shen.<sig+rules> Y)) X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V3800 V3801 V3802 V3803)))))) false)) false)) false)))

(defun shen.t*-defh (V3810 V3811 V3812 V3813 V3814 V3815) (let V3445 (shen.lazyderef V3810 V3814) (if (cons? V3445) (let Sig (hd V3445) (let Rules (tl V3445) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V3811 V3812 V3813 Rules V3814 V3815)))) false)))

(defun shen.t*-defhh (V3824 V3825 V3826 V3827 V3828 V3829 V3830 V3831) (do (shen.incinfs) (shen.t*-rules V3829 V3825 1 V3826 (cons (cons V3826 (cons : (cons V3825 ()))) V3828) V3830 (freeze (shen.memo V3826 V3824 V3827 V3830 V3831)))))

(defun shen.memo (V3837 V3838 V3839 V3840 V3841) (let Jnk (shen.newpv V3840) (do (shen.incinfs) (unify! V3839 V3838 V3840 (freeze (bind Jnk (declare (shen.lazyderef V3837 V3840) (shen.lazyderef V3839 V3840)) V3840 V3841))))))

(defun shen.<sig+rules> (V3843) (let Parse_shen.<signature> (shen.<signature> V3843) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))))

(defun shen.<non-ll-rules> (V3845) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V3845) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<rule>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V3845) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.hdtl Parse_shen.<rule>) ())) (fail))) YaccParse)))

(defun shen.ue (V3847) (cond ((and (cons? V3847) (and (cons? (tl V3847)) (and (= () (tl (tl V3847))) (= (hd V3847) protect)))) V3847) ((cons? V3847) (map (lambda Z (shen.ue Z)) V3847)) ((variable? V3847) (concat && V3847)) (true V3847)))

(defun shen.ue-sig (V3849) (cond ((cons? V3849) (map (lambda Z (shen.ue-sig Z)) V3849)) ((variable? V3849) (concat &&& V3849)) (true V3849)))

(defun shen.ues (V3855) (cond ((shen.ue? V3855) (cons V3855 ())) ((cons? V3855) (union (shen.ues (hd V3855)) (shen.ues (tl V3855)))) (true ())))

(defun shen.ue? (V3857) (and (symbol? V3857) (shen.ue-h? (str V3857))))

(defun shen.ue-h? (V3865) (cond ((and (shen.+string? V3865) (and (= "&" (pos V3865 0)) (and (shen.+string? (tlstr V3865)) (= "&" (pos (tlstr V3865) 0))))) true) (true false)))

(defun shen.t*-rules (V3873 V3874 V3875 V3876 V3877 V3878 V3879) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3429 (shen.lazyderef V3873 V3878) (if (= () V3429) (do (shen.incinfs) (thaw V3879)) false)) (if (= Case false) (let Case (let V3430 (shen.lazyderef V3873 V3878) (if (cons? V3430) (let Rule (hd V3430) (let Rules (tl V3430) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V3874 V3877 V3878 (freeze (cut Throwcontrol V3878 (freeze (shen.t*-rules Rules V3874 (+ V3875 1) V3876 V3877 V3878 V3879)))))))) false)) (if (= Case false) (let Err (shen.newpv V3878) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V3875 V3878) (cn " of " (shen.app (shen.lazyderef V3876 V3878) "" shen.a)) shen.a))) V3878 V3879))) Case)) Case)))))

(defun shen.t*-rule (V3885 V3886 V3887 V3888 V3889) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V3421 (shen.lazyderef V3885 V3888) (if (cons? V3421) (let Patterns (hd V3421) (let V3422 (shen.lazyderef (tl V3421) V3888) (if (cons? V3422) (let Action (hd V3422) (let V3423 (shen.lazyderef (tl V3422) V3888) (if (= () V3423) (let NewHyps (shen.newpv V3888) (do (shen.incinfs) (shen.newhyps (shen.placeholders Patterns) V3887 NewHyps V3888 (freeze (shen.t*-patterns Patterns V3886 NewHyps V3888 (freeze (cut Throwcontrol V3888 (freeze (shen.t*-action (shen.curry (shen.ue Action)) (shen.result-type Patterns V3886) (shen.patthyps Patterns V3886 V3887) V3888 V3889))))))))) false))) false))) false)))))

(defun shen.placeholders (V3895) (cond ((shen.ue? V3895) (cons V3895 ())) ((cons? V3895) (union (shen.placeholders (hd V3895)) (shen.placeholders (tl V3895)))) (true ())))

(defun shen.newhyps (V3901 V3902 V3903 V3904 V3905) (let Case (let V3408 (shen.lazyderef V3901 V3904) (if (= () V3408) (do (shen.incinfs) (unify! V3903 V3902 V3904 V3905)) false)) (if (= Case false) (let V3409 (shen.lazyderef V3901 V3904) (if (cons? V3409) (let V3404 (hd V3409) (let Vs (tl V3409) (let V3410 (shen.lazyderef V3903 V3904) (if (cons? V3410) (let V3411 (shen.lazyderef (hd V3410) V3904) (if (cons? V3411) (let V (hd V3411) (let V3412 (shen.lazyderef (tl V3411) V3904) (if (cons? V3412) (let V3413 (shen.lazyderef (hd V3412) V3904) (if (= : V3413) (let V3414 (shen.lazyderef (tl V3412) V3904) (if (cons? V3414) (let A (hd V3414) (let V3415 (shen.lazyderef (tl V3414) V3904) (if (= () V3415) (let NewHyp (tl V3410) (do (shen.incinfs) (unify! V V3404 V3904 (freeze (shen.newhyps Vs V3902 NewHyp V3904 V3905))))) (if (shen.pvar? V3415) (do (shen.bindv V3415 () V3904) (let Result (let NewHyp (tl V3410) (do (shen.incinfs) (unify! V V3404 V3904 (freeze (shen.newhyps Vs V3902 NewHyp V3904 V3905))))) (do (shen.unbindv V3415 V3904) Result))) false)))) (if (shen.pvar? V3414) (let A (shen.newpv V3904) (do (shen.bindv V3414 (cons A ()) V3904) (let Result (let NewHyp (tl V3410) (do (shen.incinfs) (unify! V V3404 V3904 (freeze (shen.newhyps Vs V3902 NewHyp V3904 V3905))))) (do (shen.unbindv V3414 V3904) Result)))) false))) (if (shen.pvar? V3413) (do (shen.bindv V3413 : V3904) (let Result (let V3416 (shen.lazyderef (tl V3412) V3904) (if (cons? V3416) (let A (hd V3416) (let V3417 (shen.lazyderef (tl V3416) V3904) (if (= () V3417) (let NewHyp (tl V3410) (do (shen.incinfs) (unify! V V3404 V3904 (freeze (shen.newhyps Vs V3902 NewHyp V3904 V3905))))) (if (shen.pvar? V3417) (do (shen.bindv V3417 () V3904) (let Result (let NewHyp (tl V3410) (do (shen.incinfs) (unify! V V3404 V3904 (freeze (shen.newhyps Vs V3902 NewHyp V3904 V3905))))) (do (shen.unbindv V3417 V3904) Result))) false)))) (if (shen.pvar? V3416) (let A (shen.newpv V3904) (do (shen.bindv V3416 (cons A ()) V3904) (let Result (let NewHyp (tl V3410) (do (shen.incinfs) (unify! V V3404 V3904 (freeze (shen.newhyps Vs V3902 NewHyp V3904 V3905))))) (do (shen.unbindv V3416 V3904) Result)))) false))) (do (shen.unbindv V3413 V3904) Result))) false))) (if (shen.pvar? V3412) (let A (shen.newpv V3904) (do (shen.bindv V3412 (cons : (cons A ())) V3904) (let Result (let NewHyp (tl V3410) (do (shen.incinfs) (unify! V V3404 V3904 (freeze (shen.newhyps Vs V3902 NewHyp V3904 V3905))))) (do (shen.unbindv V3412 V3904) Result)))) false)))) (if (shen.pvar? V3411) (let V (shen.newpv V3904) (let A (shen.newpv V3904) (do (shen.bindv V3411 (cons V (cons : (cons A ()))) V3904) (let Result (let NewHyp (tl V3410) (do (shen.incinfs) (unify! V V3404 V3904 (freeze (shen.newhyps Vs V3902 NewHyp V3904 V3905))))) (do (shen.unbindv V3411 V3904) Result))))) false))) (if (shen.pvar? V3410) (let V (shen.newpv V3904) (let A (shen.newpv V3904) (let NewHyp (shen.newpv V3904) (do (shen.bindv V3410 (cons (cons V (cons : (cons A ()))) NewHyp) V3904) (let Result (do (shen.incinfs) (unify! V V3404 V3904 (freeze (shen.newhyps Vs V3902 NewHyp V3904 V3905)))) (do (shen.unbindv V3410 V3904) Result)))))) false))))) false)) Case)))

(defun shen.patthyps (V3911 V3912 V3913) (cond ((= () V3911) V3913) ((and (cons? V3911) (and (cons? V3912) (and (cons? (tl V3912)) (and (= --> (hd (tl V3912))) (and (cons? (tl (tl V3912))) (= () (tl (tl (tl V3912))))))))) (adjoin (cons (hd V3911) (cons : (cons (hd V3912) ()))) (shen.patthyps (tl V3911) (hd (tl (tl V3912))) V3913))) (true (shen.f_error shen.patthyps))))

(defun shen.result-type (V3920 V3921) (cond ((and (= () V3920) (and (cons? V3921) (and (= --> (hd V3921)) (and (cons? (tl V3921)) (= () (tl (tl V3921))))))) (hd (tl V3921))) ((= () V3920) V3921) ((and (cons? V3920) (and (cons? V3921) (and (cons? (tl V3921)) (and (= --> (hd (tl V3921))) (and (cons? (tl (tl V3921))) (= () (tl (tl (tl V3921))))))))) (shen.result-type (tl V3920) (hd (tl (tl V3921))))) (true (shen.f_error shen.result-type))))

(defun shen.t*-patterns (V3927 V3928 V3929 V3930 V3931) (let Case (let V3396 (shen.lazyderef V3927 V3930) (if (= () V3396) (do (shen.incinfs) (thaw V3931)) false)) (if (= Case false) (let V3397 (shen.lazyderef V3927 V3930) (if (cons? V3397) (let Pattern (hd V3397) (let Patterns (tl V3397) (let V3398 (shen.lazyderef V3928 V3930) (if (cons? V3398) (let A (hd V3398) (let V3399 (shen.lazyderef (tl V3398) V3930) (if (cons? V3399) (let V3400 (shen.lazyderef (hd V3399) V3930) (if (= --> V3400) (let V3401 (shen.lazyderef (tl V3399) V3930) (if (cons? V3401) (let B (hd V3401) (let V3402 (shen.lazyderef (tl V3401) V3930) (if (= () V3402) (do (shen.incinfs) (shen.t* (cons Pattern (cons : (cons A ()))) V3929 V3930 (freeze (shen.t*-patterns Patterns B V3929 V3930 V3931)))) false))) false)) false)) false))) false)))) false)) Case)))

(defun shen.t*-action (V3937 V3938 V3939 V3940 V3941) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3373 (shen.lazyderef V3937 V3940) (if (cons? V3373) (let V3374 (shen.lazyderef (hd V3373) V3940) (if (= where V3374) (let V3375 (shen.lazyderef (tl V3373) V3940) (if (cons? V3375) (let P (hd V3375) (let V3376 (shen.lazyderef (tl V3375) V3940) (if (cons? V3376) (let Action (hd V3376) (let V3377 (shen.lazyderef (tl V3376) V3940) (if (= () V3377) (do (shen.incinfs) (cut Throwcontrol V3940 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V3939 V3940 (freeze (cut Throwcontrol V3940 (freeze (shen.t*-action Action V3938 (cons (cons P (cons : (cons verified ()))) V3939) V3940 V3941)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3378 (shen.lazyderef V3937 V3940) (if (cons? V3378) (let V3379 (shen.lazyderef (hd V3378) V3940) (if (= shen.choicepoint! V3379) (let V3380 (shen.lazyderef (tl V3378) V3940) (if (cons? V3380) (let V3381 (shen.lazyderef (hd V3380) V3940) (if (cons? V3381) (let V3382 (shen.lazyderef (hd V3381) V3940) (if (cons? V3382) (let V3383 (shen.lazyderef (hd V3382) V3940) (if (= fail-if V3383) (let V3384 (shen.lazyderef (tl V3382) V3940) (if (cons? V3384) (let F (hd V3384) (let V3385 (shen.lazyderef (tl V3384) V3940) (if (= () V3385) (let V3386 (shen.lazyderef (tl V3381) V3940) (if (cons? V3386) (let Action (hd V3386) (let V3387 (shen.lazyderef (tl V3386) V3940) (if (= () V3387) (let V3388 (shen.lazyderef (tl V3380) V3940) (if (= () V3388) (do (shen.incinfs) (cut Throwcontrol V3940 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V3938 V3939 V3940 V3941)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3389 (shen.lazyderef V3937 V3940) (if (cons? V3389) (let V3390 (shen.lazyderef (hd V3389) V3940) (if (= shen.choicepoint! V3390) (let V3391 (shen.lazyderef (tl V3389) V3940) (if (cons? V3391) (let Action (hd V3391) (let V3392 (shen.lazyderef (tl V3391) V3940) (if (= () V3392) (do (shen.incinfs) (cut Throwcontrol V3940 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V3938 V3939 V3940 V3941)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V3937 (cons : (cons V3938 ()))) V3939 V3940 V3941)) Case)) Case)) Case)))))

(defun findall (V3947 V3948 V3949 V3950 V3951) (let B (shen.newpv V3950) (let A (shen.newpv V3950) (do (shen.incinfs) (bind A (gensym shen.a) V3950 (freeze (bind B (set (shen.lazyderef A V3950) ()) V3950 (freeze (shen.findallhelp V3947 V3948 V3949 A V3950 V3951)))))))))

(defun shen.findallhelp (V3958 V3959 V3960 V3961 V3962 V3963) (let Case (do (shen.incinfs) (call V3959 V3962 (freeze (shen.remember V3961 V3958 V3962 (freeze (fwhen false V3962 V3963)))))) (if (= Case false) (do (shen.incinfs) (bind V3960 (value (shen.lazyderef V3961 V3962)) V3962 V3963)) Case)))

(defun shen.remember (V3968 V3969 V3970 V3971) (let B (shen.newpv V3970) (do (shen.incinfs) (bind B (set (shen.deref V3968 V3970) (cons (shen.deref V3969 V3970) (value (shen.deref V3968 V3970)))) V3970 V3971))))



